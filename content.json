{"meta":{"title":"microleo的个人博客","subtitle":"工作学习中的学习笔记及技术积累","description":"iOS,Windows开发者","author":"microleo","url":"http://fangliquan.github.io","root":"/"},"pages":[{"title":"tags","date":"2016-07-23T08:20:53.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"tags/index.html","permalink":"http://fangliquan.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2016-07-23T09:09:37.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"about/index.html","permalink":"http://fangliquan.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-23T08:20:38.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://fangliquan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2021-03-14-iOS面试整理(二)","slug":"2021-03-14-iOS面试整理-二","date":"2021-03-16T03:48:09.000Z","updated":"2021-03-16T03:48:55.183Z","comments":true,"path":"2021-03-16/2021-03-14-iOS面试整理-二/","link":"","permalink":"http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/","excerpt":"","text":"91 组件化1.底基层(放置最基础,最常用的相关库)—MMBaseFoundation—baseCypto2.底层基础层(主要提供各种基础功能(网络库,数据库, im等))—MFDB—SDWebimage3.底层应用层(提供各种通用代理等)—DNS—MDAnalyzeRecord4.业务基础层—momokit—MDWebview5.业务应用层(封装一些通用业务的功能)—大图预览 70 pod库循环引用怎么解决如何检测？ Pod install就会报错，解决方案，分层，通过代理解决 71 防Crash 方案1.UI非主线程刷新setNeedsLayout、setNeedsDisplay、setNeedsDisplayInRect:、setNeedsUpdateConstraints四个方法，判断当前是否是主队列，如果不是主队列，则跳转到dispatch_get_main_queue执行。2.KVO 非对称添加删除hook了NSObject的addObserver:forKeyPath:options:context:、removeObserver:forKeyPath:。为被观察对象增加一个map属性，存储所有的observer和keypath的对应关系。每次添加或者删除观察者的时候，都会先去检查observer的keypath是否已存在或者消失，在执行相当逻辑。避免重复添加或者删除3.unrecognized selectorforwardingTargetForSelector4.container类型crash, 数组越界 计算机基础 69 mp3和wav的区别 Wav是无损音乐的一种, 文件较大, 和CD格式一样, 44.1k的取样频率, 最接近无损的音乐格式Mp3文件通过对音频进行编码, 去掉了某些部分, 节省空间Pcm 数据是最原始的音频数据, 完全无损. pcm是没有压缩的编码方式 ,Wav是使用pcm编码的一种音频格式. Wav就是pcm+文件头 68 HTTP2.0 和 HTTP1.1的区别—多路复用, 现在只是并发请求, 相互之间没有影响—首部压缩—流量控制 48 HTTPS HTTPS是HTTP协议+SSL/TLS协议. 让HTTP先和SSL通信, 再由SSL和服务器通信, (私钥还是公钥) HTTPS的采用了混合的加密机制, 使用非对称秘钥加密方式, 传输对称秘钥秘钥加密方式所需要的key, 获取到key后, 在使用对称秘钥加密方式进行通讯, 从而保证效率 如何连接的?, 秘钥怎么交换客户端连接上服务器, 服务器发送CA证书给客户端, 客户端随机生成会话秘钥K, 用CA证书加密, 然后发给服务端, 服务器用自己的私钥解密得到会话秘钥K, 然后用秘钥K进行通信 RSA非对称加密AES对称加密 TCP协议的三次握手和四次挥手客户端和服务器端的通信其实和人与人之间的通信是一样的, 假设两个人相互确认对方三次握手 第一次握手: 客户端给服务发送一个SYN报文, 此时客户处于SYN_SEND状态第二次握手: 服务器收到SYN报文后, 会以自己的SYN报文作为应答, 同时也会以客户端ISN+1作为ACK的值, 表示自己已经收到了客户端的SYN, 此时服务器处于SYN_REVD的状态第三次握手: 客户端收到SYN报文之后, 会发送一个ACK报文, 也是一样把服务器的ISN+1作为ACK的值, 标识已经收到服务器的SYN报文 三次握手可以携带数据吗?第三次可以, 前两次不可以 四次挥手第一次挥手:客户方发送一个FIN报文, FIN=1, 并停止在发送数据,第二次挥手: 服务器收到FIN之后, 会发送ACK报文, 且把客户端的序列号值+1作为ACK报文的序列号第三次挥手:服务器发送FIN报文第四次挥手:客户端收到FIN之后, 一样会发送一个ACK报文作为应答, 且把服务端的序列号值+1. 服务器收到ACK之后, 处于关闭状态, 客户端会在发出确认报文之后, 进入时间等待, 经过2MSL后, 客户端才进入closed状态 为什么连接只用三次握手, 而断开连接却要四次挥手?Tcp 链接是一种全双工传输模式, 既是数据的发送方也是数据的接收方, 所以需要两端都完成数据传输之后在断开, 保证链接释放的可靠性首先, 当客户端数据已发送完毕, 且知道服务器也全部接受到时, 就会去断开连接即向服务器端发送FIN服务器端收到客户端的FIN, 为了标识接收到了, 就会向客户端发送ACK但此时, 服务器可能还在发送数据, 并没有关闭TCP窗口的意思, 所以服务器的FIN和ACK并不是同步发的, 只有当数据发送完, 才会发送FIN 综上所述, 服务器的FIN和ACK需要分开发, 并不是像三次握手那样, SYN可以和ACK同步发, 所以就需要四次挥手 TCP和UDP的区别 0. 基于链接与无连接 0. 对系统资源的要求(TCP较多, UDP较少) 0. Udp 程序结构较简单 0. 流模式与数据包模式 0. Tcp保证数据正确性, UDP可能丢包 0. TCP 保证数据顺序 UDP不保证 HTTP状态码1XX: 请求正在处理2XX: 请求正常处理完毕3XX: 重定向4XX: 客户端错误状态码 404 notFound5XX: 服务器错误 500 Internal server error 服务器正在执行请求时发生错误 对称加密: DES非对称加密 RSA http请求头和响应头常用的请求头accept: / 可以处理所有类型accept-encodingaccept-languageconnection:keep-alivehost:UAcookie:range 响应头Content-type:告诉客户端资源文件的类型connection:keep-alive 七层设计模式, 对应做什么的应用层-HTTP协议 FTP协议表示层-数据的编码解码, 将设备固有的数据格式转换为网络标准传输格式会话层—三次握手,四次挥手在这里完成的传输层—TCP/UDP网络层-根据网络设备地址路由数据包, 地址解析, ip数据链路层—物理地址寻址, 流量控制, 重发物理层:物理设备 5层应用层传输层网络层数据链路层物理层 78 多态子类通过覆盖或重载父类的方法, 使得对同一类对象统一方法的调用产生不同的结果 77 设计模式 java里面有23中, 但是不一定能映射到ios上面单例模式,工厂方法模式观察者模式抽象工厂模式 工厂模式在工厂模式中, 可以根据参数的不同返回不同类的实例. 简单工厂模式专门定义一个类来负责创建其他类的实例. 被创建的实例通常都具有共同的父类 抽象工厂模式生产的事多个不同类型的类, 所以必须将公共点抽象出来 普通工厂产出是一个产品（实例），抽象工厂产出是一个抽象（接口）。区别在于，若添加一个新的产品，前者是修改工厂，后者是创建新工厂（符合“闭合原则”）。 设计模式6大原则1.单一责任原则—一个类就干一类事情, 不要耦合2.开放封闭原则—类,函数等应该是可以拓展的, 但是不可修改3.里式替换原则—只要父类能出现的地方, 子类也能出现, 反之, 父类则未必能胜任4.依赖倒置原则—高层模块不应该依赖于底层模块5.接口隔离原则—建立单一接口, 不要建立庞大臃肿的接口6.迪米特法则—迪米特法则又叫做最少知道原则, 就是一个类对自己依赖的类知道的越少越好. 对于被依赖的类来说, 无论逻辑多么复杂, 都尽量地将逻辑封装在类的内部, 对外提供public放阿飞, 不对外泄漏任何信息. 迪米特发着还有个简单的定义, 只与直接的朋友通信解决方案: 尽量降低类与类之间的耦合 31 数据库索引唯一索引和普通索引使用的都是B-Tree, 执行时间复杂度都是O(logn)普通索引: 由关键字Key或INDEX定义的索引, 唯一任务是加快数据的访问速度. 应该为那些经常出现在查询条件或排序条件中的数据列创建索引. 被索引的数据列包含重复的值唯一索引:确定某个数据列将至包含彼此各不相同的值, 那就应该用关键字 UNIQUE把它定义为一个唯一索引. 好处是, 1.简化了对索引的管理工作, 这个索引也因此而变得更有效率. 二是, 数据库会在有新纪录插入数据表是, 自动检查新纪录的这个字段的值是否已经在某个记录的字段里出现过. 唯一索引既可以保证数据的重复出现, 又可以提高访问速度主键索引: 唯一索引的特殊类型 主键和索引的区别 0. 对于主键, oracle, sql, musql都会自动建立唯一索引 0. 主键课作为外键, 唯一索引不可 0. 主键不可为空, 唯一索引可以 0. 主键也可以是多个字段的组合 0. 主键和唯一索引不同的是, A 有not null属性, B,每个表只能有一个 61 git 原理, git 的各种命令 Git 是一种分布式版本控制系统 从本质上讲, git是一套内容寻址的文件系统, 他存储的也是key-value键值对, 然后根据key值来寻找value. git根据指针来寻址的, 这些指针就存储在git对象中.git共有三种对象, commit对象, tree对象, blob对象 Git的核心是它的对象数据库, 其中保存了git的对象, 其中最重要的事blob(数据对象), tree和commit对象. blob对象实现了对文件内容的记录, tree对象实现了对文件名,文件目录结构的记录, commit对象实现了对版本提交时间, 版本作者, 版本序列,版本说明等附加信息的记录. 这三类对象, 完美实现了git的基础功能: 对版本状态的记录 Git所做的实质工作是将被改写的文件保存为数据对象, 更新暂存区, 记录树对象, 最后创建一个指明了顶层树对象和父提交的提交对象 Git引用是指指向git对象hash键值. 通过git引用, 我们可以更加方便的定位到某一个版本的提交, git分支, tags等功能都是基于git引用实现的 merge 和 rebaseRebase会把你当前的分支的commit放到公共分支的最后面, 所以叫变基Merge 会把公共分支和当前的commit合并带一起, 形成新的commit提交 82 动态库与静态库的区别静态库是在程序编译时会被链接到目标代码中, 动态库是在程序编译是并不会被链接到目标, 只在程序启动的时候, 加载完mach-o文件后才会加载动态库静态库, 以.a和.framwork为文件后缀名, 自建的.framword一般都是静态库. 自己也可以修改动态库, 以.tbd和.framwork为后缀名(系统直接提供给我们的framework都是动态库) App启动后, 动态链接器DYLD, 解析app需要的未定义的外部符号external symbols, 在运行时 dynamic loader也会加载哪些被请求的其他库 动态库分为两种动态链接库:在可执行文件被夹在, 动态库也随着被加载到内存中动态加载库:在需要的时候再使用dlopen等通过代码或者命令的方式来加载 88 LLDB 常用的调试命令Po 打印对象, 会调用对象的description方法Expr 可以在调试的时候动态执行指定表达式P 打印对象Bt 打印调用堆栈, 加all 可打印所有thread的堆栈brl 是breakpoint list 的简写 编译原理 76 ios编译过程OC是编译型语言, 先将代码编译成机器码, 再加以运行. 好处就是运行速度快, 缺点就是开发,调试比较长. c++, OC, swift c java解释型语言开发调试比较短, 运行速度慢, 一遍由相应语言的解释器翻译成目标代码, 一边执行. Js, python, PHP Ios采用三相设计.clang+LLVM编译过程Clang编译前端负责语法分析语义分析,生成中间代码. 编译器后端会进行机器无关的代码优化, 生成机器语言, 并进行机器相关的代码优化, 不同的cpu生成不同的机器码 在预编译阶段. 会做宏替换,删除注释, 头文件引入. 然后将文件转成语法树, 编译器会根据这可语法树, 做一些额外的操作以找出可能存在的错误1.类型检查.即检查程序中是否有类型错误2.检查变量定义了但是未使用. 就是我们看到的warning3.编译, 将AST转换为更低级的中间码(LLVM IR), 对生成的中间码做优化, 生成特定目标代码, 输出汇编代码4.汇编: 将汇编代码转换成目标对象文件5.链接, 将多个目标对象文件合为一个可执行文件6.生成可执行文件 mach-o 编译原理1.词法分析—对字节流进行扫描和分享, 从而识别出一个个单词(token)序列的过程2.语法分析—将单词序列分解成各类语法短语(语法树AST)3.语义分析—审查程序有无语义错误4.中间代码生成5.代码优化—6.目标代码生成—将中间代码变换成特定机器上的指令代码或汇编指令代码 66 ios在编译的时候做了那些事情 Oc是编译语言. 编译的时候先进行, 语法分析,, 语义分析, 然后对无关的代码优化, 生成机器码.编译语言在执行的时候, 必须先通过编译器生成机器码, 机器码可以直接在cpu上运行, 所以执行效率比较高 词法分析是计算机将字符序列为token序列的过程 84 bitCode 的理解和作用bitCode是LLVM编译器的中间代码的一种编码, 他可以转换为任何被支持的CPU架构, 比如打开bitCode功能提交一个app到应用商店, 以后苹果新出了一款手机并cpu也是全新设计, 一样可以编译转换为新cpu的可执行程序 75 app的启动添加环境变量可以打印出app的启动时间分析App的冷启动可以概括3大阶段—dyld(dynamic link editor) apple的动态连接器, 可以用来装载mach-0文件——启动app时, dyld 所做的事情有———装载app的可执行文件, 同时会递归所有依赖的动态库(如何找到动态库的?)———当dyld把可执行文件, 动态库都装载完毕后, 会通知runtime进行下一步的处理—runtime阶段——启动App, runtime所做的事情有———调用map_images进行可执行文件内容的解析和处理———在load_images中调用call_load_methods,调用所有class和category的+load方法(告诉研发已经加载好了)———进行各种objc结构的初始化(注册objc类,初始化类对象等)———调用c++静态初始化器和attribute(constrictor)修饰的函数———到此为止, 可执行文件和动态库中所有的符号(Class,, protocol, selector, IMP)都已经按格式成功加载到内存中, 被runtime所管理—main——调用uoapplicationMain函数, AppDelegate的application:didfinishAltuchingWithOptions方法 优化dyld—减少动态库, 合并一些动态库(定期清理不必要的动态库)—减少Objc类, 分类的数量, 减少selector数量(定期清理不必要的类, 分类)—减少c++虚函数数量—swift进来使用struct runtime—用+initialize方法和dispatch_once取代所有的attribute((constrictor) c++静态构造器, objc的+load) main—在不影响用户体验的前提下, 尽可能将一些操作延迟, 不要全部都放在finishLaunching方法中—按需加载 72 ios程序的内存布局//运行时分配{栈:局部变量+方法实参堆:通过alloc init创建的对象}//编译时分配{BSS段: 未初始化的全局变量和静态变量数据段:已初始化的全局变量, 静态变量,常量代码段:被编译成二进制的代码} 45 悬挂指针 野指针 悬挂指针: 指针指向的内存已经被释放了, 但指针还存在 野指针: 没有进行初始化的指针 BAD_ACCESS 访问了已经被销毁的内存空间, 就会报这个错误, 根本原因是有悬挂指针没有被释放 iOS基础知识 60 iOS 事件的传递和相应机制Ios只有继承了UIResponder的对象才能接受并处理事件 Uibutton-&gt;uicontrol-&gt;uiview-&gt;uiresponder-&gt;NSObject uiviewController-&gt;UIResponder-&gt;NSObject 事件的产生和传递 0. 发生触摸事件后, 系统会将该事件加入到一个UIApplicaiton管理的事件队列中 0. UIApplication会从事件队列中取出最前面的事件, 并将事件分发下去进行处理, 通常先发送事件给应用程序的主窗口 0. 前台App主线程RunLoop收到转发的消息, source0将封装IOHEvent为UIEvent, 然后将UIEvent传递给UIWindow 0. 通过递归调用UIView层级的 hitTest:With 找到对应的view, (hitTest:wtih 底层用有pointInSide 判断是否在点击区域) 0. 找到对应的会调用view 的touchsBegin:withEvent:方法来处理事件. 如果当前第一响应者没有进行出出力, 系统就将事件传递给响应者中的下一个响应者, 看看是否可以进行处理 控件的点击时机和添加在上面的手势谁先相应 0. 如果当前是普通控件, 比如uiview 会先相应手势事件, 不过手势是需要时间的, 时间传递给了响应链的第一个响应对象, 响应链 uiresponder的touchsBegan:withEvent 方法, 之后手势识别成功, 就回去cancel之前传递到的所有响应对象, 于是就会调用他们的touchesCancelled:withEvent 方法. 0. UIGestureRecognizer 有个属性cancelsTouchesInView 这个属性默认值是yes, 即当手势识别成功后, 会发送touchesCancelled消息给view来结束view的响应. 如果cancelsTouchesInView为no, 那么gestureRecognizer和view都可以响应 0. 如果控件是uibutton, uiswitch, , 未来防止事件重叠, 先响应控制事件, 并且拦截了手势事件 事件的传递是从上到下(父控制到子控制), 事件的相应是从下到上(顺着响应者链条向上传递, 子控件到父控件) Uiview 不接受触摸事件的三种情况 0. userinterfaceEnable = NO; 0. hidden = yes 0. alpha = 0.0~0.1 87 ios 如何根据uiview获取所在的uiviewControlleruiview 和UIVIewcontroller 都是直接继承自UIResponder. responder chain 大概的传递规则就是从视图顶层的uiview向下到uiviewcontroller再到rootviewContooler 再到window最后到applicationid responder = self.nextResponder;while (![responder isKindOfClass: [UIViewController class]] &amp;&amp; ![responder isKindOfClass: [UIWindow class]]) { responder = [responder nextResponder]; } if ([responder isKindOfClass: [UIViewController class]]) { // responder就是view所在的控制器 // do something } 64 手势的响应, 单击, 双击的判断, 底层实现-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{ [NSObject cancelPreviousPerformRequestsWithTarget:self]; UITouch *touch = [touches anyObject]; CGPoint touchPoint = [touch locationInView:self]; if (touch.tapCount == 1) &#123; [self performSelector:@selector(handleSingleTap:) withObject:[NSValue valueWithCGPoint:touchPoint] afterDelay:0.3]; &#125;else if(touch.tapCount == 2) &#123; [self handleDoubleTap:[NSValue valueWithCGPoint:touchPoint]]; &#125;38 iOS 深浅拷贝 不可变对象, copy 是指针复制, mutablecopy是内容复制NSString copy之后还是同一个NSString mutableCopy之后是NSMutableString 可变对象, copy是内容复制, mutableCopy 也是内容复制NSMutableString copy 之后是NSString, mutableCopy之后还是NSMutableString 集合的单程深复制,可以用initWithArray:copyItems, 将第一个参数设置为YES即可深复制 如果是完全的深拷贝, 归档实现 NSString 为什么要用copy关键词?当源字符串是不可变类型是, copy strong 都一样当源字符串是可变类型, copy是深拷贝, 会生成一个新对象, strong修饰的属性, 会随着源字符串的改变而改变. 所以一个类型有可变类型, 在声明不可变属性的时候要用copy 67 block和函数指针的理解函数指针和block都可以实现回调的操作, 声明上也很相似, 实现上都可以看成是一个代码片段不同:函数指针只能指向预先定义好的函数代码块, 函数地址是在编译链接时就已经确定好的. block本质是oc对象, NSObject 的子类, 可以接收消息 39 Block的几种形式 block本质上是一个OC对象, 它内部也有个isa指针. block是封装了函数调用以及函数调用环境的OC对象Block: 带有自动变量的匿名函数. 封装了函数调用以及调用环境的OC对象 全局block, 存储在已初始化数据(.data)区—没有访问auto变量栈block 堆区—访问了auto变量堆block 栈区—NSStackBlock__ 调用copy 对栈block 进行copy操作, 就是堆block, 对全局block进行copy, 仍是全局block . 对堆block进行copy, 将会增加引用计数(不copy会怎么样) 0. __block typeof(self) weakSelf = self 和 __weak typdeof(self) weakSelf = self 的区别由于 block 捕获block 修饰的变量会去持有变量, 那么如果用block修饰self, 且self持有block, 并且block内部使用到了block 修饰的self时, 就会造成多循环引用, 即self持有block, block 持有block变量, block变量持有self, 造成内存泄漏. 主动断开block的持有, 就可以解决这种循环引用. 即在block内部使用完weakself后, 将其置为nil, 但这种方式有个问题, 如果block 一直不被调用, 那么循环引用将一直存在. 好处就是在block里面self会一直存在, 所以最好还是用__weak来修饰self -(void)dealloc{ __weak typdeof(self) weakSelf = self; NSLog(%@,weakSelf)}会crash. 添加weak的时候, runtime会通过检查引用计数的个数来判断对象是否在deallocationg, 如果是会让程序crash 0. 为什么__block修饰的变量可以在block里面访问block 修饰的int, clang下文件就会发现, __block修饰的参数, 其实转换成了 __block_byref_valueInt_0 结构体 ,在构造这个结构体的时候, 里面有个参数传递的事&amp;valueint 地址 . 经过block后, 编译器会将value拷贝到了堆上. Block修改的其实是堆上的内容 0. 为什么声明block属性要用 copy? 使用copy 是从MRC 遗留下来的传统, 在mrc中, 手动管理内存, 方法内部的block 是在栈区, 使用copy可以把它放在堆区. 堆由开发自己管理内存, 在ARC中对block 使用copy还是strong 效果是一样的, 但是建议写copy, 因为这样显示告知调用者编译器会自动进行copy操作, 将block复制到堆上 20 互斥锁和自旋锁自旋锁 不会引起调用者睡眠, 如果自旋锁已经被别的执行单元持有, 调用者就一直循环在那里等待是否自旋锁的保持住释放了锁.其作用是为了解决某项资源的互斥使用, 因为自旋锁不会引起调用者睡眠, 所以自旋锁的效率远高于互斥锁 互斥锁: 属于sleep-waiting类型的锁, 如果他要访问的的一个锁正在被别的线程只有, 那么他就会sleep, 然后等待被running 互斥锁适合临界区持锁时间比较长的操作, 比如临界区有IO操作, 临界区代码复杂或者循环量大, 临界区竞争非常结论, 单核处理器 自旋锁主要用于在临界区持锁时间非常短且CPU资源不紧张的情况下, 自旋锁一般用户多核的服务器 自旋锁会忙等, 就是被访问的资源被锁是, 调用者线程不会休眠, 而是不停循环在哪里, 直到被锁资源释放锁. 优点在于, 自旋锁不会引起调用者睡眠, 不会进行线程调度, cpu时间陪轮转等耗时操作. 所以如果能在短时间内获得锁, 自旋锁的效率远高于互斥锁. 缺点就是一直占用cpu. 自旋锁不能实现递归调用 例子: atomic, dispatch_semaphore_t互斥锁会休眠, 所谓的休眠, 即在访问被锁资源时, 调用者线程休眠, 此时cpu可以调度其他线程工作, 直到被锁资源释放锁, 此时会唤醒休眠线程. pthread_metex, @synchronized NSLock, 适合 单核处理器, 临界区有IO操作, 执行时间比较长, 竞争比较激烈 OSSpinLock 自旋锁os_unfaire_lock 互斥锁 pthread_mutex 互斥锁, 等待锁的线程会处于休眠状态/递归锁(允许同一个线程对一把锁重复加锁)NSLock 对mutext的封装dispatch_queue dispatch_semaphore 也可以实现锁@synchronized 对mutex 互斥的封装—传nil是无法启动加锁作用—不会持有传入的对象, 所以在sychronized里面销毁了这个对象, 也不会有问题—乡里低, 传入对象必须等待之前的锁执行完之后才能执行, 无法达到异步的效果 41 死锁 死锁的四个必要条件: 互斥, 请求保持, 不可剥夺, 环路死锁的处理: 鸵鸟策略,预防策略,避免策略,检测与解除死锁 19.一个 NSObject 对象占用多少内存空间？ class_getInstanceSize([Person class]) 获取类对象实际占用的大小两个原则,1.内存对齐(提高内存访问速度): 大小必须是最大成员字节的整数倍 malloc_size((__bridge const void*)p) 获取的是实际内存大小系统实际分配内存大小是16的整数倍 sizeof(p) 运算符函数, 计算的事传入的p, 计算的是p指针的大小为8 64位的系统BOOL 1个字节Int float 基础类型占4个字节NSSting NSInterge Block CGFloat long double 8个字节CGRect 3220 OC的本质OC的面向对象都是基于C/C++数据格式(结构体)实现的 一个OC对象在内存中是如何布局的?以NSObjet为例, 在内存中是一个struct, 里面有个 class ias指针 21 OC的类信息存放在哪里对象方法, 属性, 成员变量, 协议信息,存放在class对象中类方法, 存放在meta-class对象中成员变量的具体值, 存放在instance对象 12 weak的实现原理？SideTable的结构是什么样的 Weak 表明该属性定义了一种”非拥有关系”, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值, 性质同assign类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空runTime维护了一个weak_table_t结构的hash表, 用于存储指向某个对象的所有weak指针. key是对象的地址, value是 weak_entry_t 的一个动态数组, 用来存储 weak_entry_t 类型的元素. weak_entry_t的结构体也是hash结构. 存储了弱引用对象指针的指针 Sidetable 主要用于管理对象的引用计数和weak表struct SideTable{ spinlock_t slock; //保证原子操作的自旋锁 RefcountMap refcnts //引用计数hash表 weak_table_t weak_table //weak 引用全局 hash表} 13 引用计数当调用allock new copy mutableCopy方法返回了一个对象, 在不需要这个对象是, 需要调用release 或者autorelease来释放它 引用计数存储在isa指针里面, 如果不够存储就存在一个散列表里 10 load、initialize方法的区别什么？在继承关系中他们有什么区别调用时机不一样, load是app一启动就会调用, Initialize,只有在对象初始化的时候才会调用Load调用时机, 先父类在子类, 主类先于类别Load 函数只要你动态加载了这个类, load方法就会执行 在执行load方法之前, 会调用load_image方法, 用来扫描+load符号, 将需要调用load方法的类添加到一个列表中loadable_classes, 在这个列表, 会先把父类接入到待加载列表, 这样保证父类在子类前调用load方法, 而load方法会在类的load的方法后面加入另外一个待加载列表loadable_categories. 待扫描结束后, 先从loadable_classes调用类的load方法, 然后会调用loadable_categories中分类的方法+(load)方法是根据方法地址直接调用, 并不是经过objc_msgSend函数调用. 而initialize是通过objc_msgSend进行调用 1.分类的load方法和编译有关, 先编译的先调用, 后编译的后调用2.多个category方法冲突, 会找到最后一个编译的category对于的方法3.类的load方法能否调用category中声明的方法? 可以的. 因为附加category到类的工作会先于load方法的执行4.category的方法和类的方法冲突了. 想调用类的方法咋办, 运行时获取当前类的方法列表, 然后遍历, 获取最后一个方法 initalize 会强制父类先调用, 子类和父类同时实现initalize, 父类的先被调用, 然后调用子类, 如果本类和category同时实现了initialize, category会覆盖本类的方法, 只调用category的initialize 只会调用一次一次. 如果子类没实现+initalize, 会调用父类的+initialize(父类的+initalize可能会调用多次) 4 category的实现原理 Category 编译之后的底层结构是struct category_t, 里面存储这分类的对象方法,类方法,属性, 协议信息在程序运行时的时候, runtime会将category的数据, 合并到类信息中(类对象, 元类对象中) 6 category &amp; extension区别，能给NSObject添加Extension吗，结果如何Category 只能添加方法, extension可以为已知类新增方法和属性, 不能为NSObject新增extension, 因为不知道NSObject里面方法的实现Extension在编译的时候, 它的数据就已经包含在类信息中Category是在运行时, 才会将数据合并到类信息中 28 Category 在编译过后，是在什么时机与原有的类合并到一起的 1 程序启动后, 通过编译之后, runtime 会进行初始化, 调用 objc_init2 然后会map_images3 接下来调用map_images_nolock4 然后就是 read_images, 这个方法会读取所有的类的相关信息5 然后调用reMethodizeClass: 这个方法是重新方法化的意思6 在reMethodizeClass, 方法内部会调用attachCategories, 这个方法会传入class和Category, 会将方法列表, 协议列表等与原有的的类合并, 最后加入到class_rw_t结构体中 29 Category 有哪些用途？ Category 的实现原理？ 将方法分类, 添加属性和协议比如添加方法, 声明方法和实现, 然后在runtime的时候将声明的方法, 协议, 和主类的方法进行合并, 放在class_rw_t 类别如果设计的不好的话容易出现方法冲突, 至于先调用哪个和编译顺序有关 13 关联对象的应用？系统如何实现关联对象的在category里面添加假属性objc_setAssociatedObject(self,”name”,OBJC_ASSOCIATION_COPY);objc_getAssociatedObject(self,”name”); associationManager 维护了一个hash表, key是对象地址, value是一张hash表, hash表里又是关联对象的key和ObjcAssocation的映射, objcAssocation是一个C++的类, 表示一个具体的关联对象, 包括两个实例变量, _policy表示关联策略, _value标识关联对象 14 关联对象的如何进行内存管理的？关联对象如何实现weak属性内存管理是通过赋值的时候设置一个policy, 根据这个policy的类型来对设置的对象进行retain/copy操作, 当poliy是asign的时候, 设置的关联值是以weak的方式进行内存管理 19 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗Atomic,确保属性的赋值的原子性, 只保证的getter 和setter存取的线程安全, 并不能保证整个对象的线程安全, 为了保证线程安全可以考虑加锁, 比如最简单的@synchronized NSLock pthread_mutex (互斥锁) OSSpinLock (自旋锁, 但是ios因为优先级反转的问题, 已经不安全了) 多个线程, 线程A写,线程B写, 线程A读. 这个时候读到的事线层B写的 62 OC和c交换对象内存权限__bridge 只做类型转换, 但是不修改对象的内存管理权__bridge_retained 将OC对象转换成CF对象, 同事将对象内存的管理权交给开发, 后续使用CFRelease来释放对象__bridge_transfer 将CF对象转换成OC对象, 同时将对象内存的管理权交给ARC 59 const extern static Const 与 宏的区别 宏是预编译, const 是编译阶段宏不做检查, 不会报编译错误, 只是替换, const会编译检查, 会报编译错误宏能定义一些函数,方法, const不能使用大量的宏, 容易造成编译时间久, 每次都需要重新替换 Static:用static修饰的变量, 在其所限定的作用域中只会有一份内存.如果在一个函数内部, 说明是一个静态局部变量, 不管这个函数调用多少次, static修饰的变量只会有一份内存如果在一个文件内部, 是一个静态全局变量, 该文件中的函数都可以访问, 并且不同函数在对改变量修改是都是在上一次函数修改的基础上修改的 extern 外部变量用extern修饰的变量, 可以被其他类所访问, 凡是引用了extern所修饰的变量的头文件, 那么就可以使用该变量 Const 一个变量如果用const修饰, 说明该变量不可以被修改 混搭static 和 const 混用 定义一个宏 static NSString *const identifier = @“hello“ extern 和 const混用 .h文件中 extern NSString *const hello.在.m文件中赋值 NSString *const hello = @“hello”; 用来多个文件使用同一个变量 int const *p // *p只读 ;p变量 int * const p // *p变量 ; p只读 const int * const p //p和*p都只读 int const * const p //p和*p都只读 58 tagged Pointer 为了节省内存和提高执行效率, 苹果首次在64位处理器上面提出了tagged pointer的概念. 对于64位程序, 引入tagged pointer后, 相关逻辑减少一半的内存占用, 以及3倍的访问速度提升, 100倍的创建,销毁速度提升 tagged pointer的特点 0. 专门用来存储小的对象, 比如 NSNumber, NSDate, 个别NSSTring 0. taggedPointer 指针的值不在是地址了, 而是真正的值 0. 在内存的读取上有着3倍的效率, 创建时比以前快了100倍 NSString 是个类簇_NSCFConstantString 常量字符串NSTaggedPointerString_NSCFString 对象类型的字符串 1 dynamic 告诉系统不用自动生成set get方法 54 pod install 和 pod update CocoaPods原理是将所有的依赖库都放在另一个名为Pods的项目中, 然后让主项目依赖Pods项目 Pod install 是第一次在工程里使用pods的时候使用, 并且每次编辑podfile (添加, 移除, 更新)的时候使用. 每次运行pod isntall的时候, 在下载, 安装新的库的同时, 也会把你安装的每个库的版本都写在Podfile.lock文件里面. 这个文件记录你每个安装库的版本号, 并且锁定了这些版本 当使用podinstall它只解决了pods里面, 但不在Podfile.lock文件里面的那些库直接的依赖. 对于在Podfile.lock里面所列出的那些库, 会下载在Podfile.lock里面明确的版本, 并不会去检查是否该库有最新的版本 Pod update. 会帮你更新这个库的新版本, 而不需要考虑Podfile.lock里面的限制. 他会更新到这个库尽可能的新版本, 只要符合Podfile里面的版本限制 90 iOS包签名1.从keychain里的从”从证书颁发机构请求证书”, 这里就本地生成了一对公私钥, 保存的certificateSigningRequest 就是公钥, 私钥保存在本地电脑里2.把对应的certificateSigningRequest 传到苹果后台生成证书(用苹果后台的私钥去签名), 并下载到本地. 这时候本地有两个证书, 一个是第一步生成的, 一个是从这里下载的. keychain会把这两个证书关联起来.3.在苹果后台配置AppID/权限/设备等, 最后下载Provisioning profile文件4.Xcode会通过第三步下载回来的证书(存着公钥), 在本地找到对应的私钥, 用本地私钥去签名app, 并将Provisioning profile文件命名为embedded.mobileprovision 一起打包进去.5.安装时, iOS系统取得证书, 通过系统内置的公钥, 验证embedded.mobileprovision, 验证成功后, 取出里面的数据, 做各种验证, 比如公钥L验证app签名, 验证设备ID是否在列表上, 权限是否一样 certificateSigningRequest 本地公钥P12 本地私钥provisioning profile:包含了证书/entitlements等数据, 并由苹果后台私钥签名的数据包 89 为什么不能再子线程刷新uiUikit 并不是线程安全的类, 如果异步操作会存在读写的问题, 如果加锁的话会消耗大量的资源并拖慢运行速度 如何避免在子线程刷新uiruntime swizzling 解决, 刷新ui的时候, 一定会调用uilayer和uiview的 setNeedsDisplay, SetNeedsLayout, SetNeedsDisplayInRect , 确保这几个方法在main thread中执行就行了 87 沙盒目录结构是怎样的application:存放程序源文件Document:常用目录, iCloud备份目录, 存放数据library—caches:存放体积大又不需要备份的数据—preference: 设置目录, iCloud 会备份设置信息tmp: 存放历史文件 85 APM application performance management ,应用性能管理, 通过对应用的可靠性, 稳定性等方面的监控, 进而达到快速修复问题, 提供用户体验的目的 83 coreAnimation 和 coreGraphics 的区别coreGraphics是核心图形库, 包含Quartz2D绘图API接口CoreAnimation是核心动画库, 用来做iOS相关动画 CoreAnimation 是依赖于openGL ES做GPU渲染, coreGraphincs做cpu渲染 做动画的时候获取frame每个CALayer有个presentationLayer属性, 当CAAniamtion做动画的时候, 其实是看到的事presentationLayer, 开启一个计时器去获取presentationLayer的frame 82 drawRect调用情况 -如果UIView 没有设置frame大小, drawRect不会被自动调用-drawRect在loadview 和viewDidLoad这两个方法之后调用-调用sizeToFit后自动调用drawRect-调用setNeedsDisplay或者setNeedsDisplayinRect会触发调用-设置contentmode属性值为UIViewContentModeRedraw. 每次设置/更改frame的时候自动调用drawRect 81 drawrect空实现 是否会有影响重写drawRect 会导致内存大量上涨. 画板视图的 -drawRect: 方法背后实际上都是底层的 CALayer 进行了重绘和保存中间产生的图片. 每次重绘的时候都需要重新抹掉内存然后重新分配. 空寄宿图的产生消耗了大量内存, 这就是drawRect内存暴增的原因 解决方案使用专有图层 CAShapeLayer. 他是一个通过矢量图形而不是bitmap来绘制图层子类. 用CGPath 来定义要绘制的图形, CAShapeLayer会自动渲染. 它可以完美替代我们之间使用CoreGraphics绘制layer优点 0. 渲染快速 0. 高效使用内存, 不会像普通CALayer一样创建一个寄宿图形 0. 不会被图层编辑剪裁掉 0. 不会出现像素化 63 setNeedsLayout与layoutIfNeeded 和 setNeedsDisplaylayoutIfNeeded 方法被调用, 主线程会立即强制重新布局, 他会从当前视图开始, 一直到完成所有字数图的布局. layoutSubviews 用来自定义视图尺寸, 他是系统调用的, 开发者不能手动调用(手动调用怎么样), 可以重写该方法, 让系统在调整布局时候按照我们希望的方式进行布局. 选择屏幕,滑动/触摸屏幕修改子视图的时候被处罚—addsubview会触发—修改view的frame会触发layoutSubviews—滚动uiscrollview—旋转screen会触发父uiview的layoutSubviews—直接调用setlayouSubviews setNeedsLayout 触发布局, 他不回立即强制视图重新布局, 而是在下一个布局周期才会被触发. 异步执行.. 默认调用layoutSubviews setNeedsDisplay 标记为需要重绘. 会自动异步调用drawRect 方法, 然后拿到currentContext 就可以画画了-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘 35 利用RunLoop 解释下页面的渲染过程 当我们调用 [uiview setNeedsDisplay] 时, 这时会调用当前的 view.layer 和 [view.layer setNeedsDisplay] 方法. 这等于给当前的 layer 打上一个脏标记, 而此时并没有直接绘制工作, 而是会到当前的 RunLoop 即将休眠, 也就是 beforeWaiting 时才会进行绘制工作.紧接着会调用 [CALayer display], 进入真正绘制的工作. CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理工作 displayer: 这个代理方法是异步绘制的入口. 如果没有实现这个方法, 那么会继续进行系统绘制的流程, 然后绘制结束CALayer 内部会创建一个 Backing Store 用来获取图形上下文, 接下来会判断这个 layer 是否有 delegate. 如果有的话,会调用 [layer.delegate drwaLayer:inContext:] 并且会返回给我们 [UIView DrawRect] 的回调, 让我们在系统绘制的基础上在做一些事情如果没有 delegate,那么会调用 [CALayer drawInContext]以上两个分支, 最终 CALyaer 都会将位图提交到 Backing Store, 最后提交给 GPU, 至此绘制的过程结束 80 OOM机制和监控方式由于iOS的Jetsam 机制造成的另一种另类crash, 他不同于常规的crash, 通过singal 捕获等crash监控方案无法不会oom事件原因1.系统内存使用较高, 系统基于优先级杀死优先级较低的app2.当前使用的App达到了””high water mark, 也就是达到了对单个app的内存限制, 系统会kill你 常见的导致问题 0. uigraphicsEndImageContext — UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏 0. uiwebview 0. autoreleasePool 0. 相互引用 0. 大图片处理, 处理大分辨图片时, 往往容易oom, 因为解码的时候, 生成原始分辨率大小的bitmap, 这很消耗性能 0. uiview太大时 74 图片解码加载完图片之后, 不能直接展示到屏幕上, 加载完之后需要先进行解码, 解码是在主线程进行的, 如果图片比较多也会导致卡顿解决方案:1.拿到图片后获取CGImage2.将CGImage解码, 创建图形上下文, 然后将图片画在图形上下文, 这样就完成了解码操作, 然后在从上下文获取图片, 这个图片是解码过的, 然后将这个图片包装成uiimage 74 渲染过程Cpu一般用户显示内容的计算， 而GPU的并行计算能力更强， 能够通过计算将图形结果显示在屏幕像素中在渲染过程中， CPU专门用来处理渲染内容的计算， 比如视图创建，布局，图片解码等，内容计算完成后，在传输给GPU进行渲染原生渲染的过程：1.CPU计算要显示的内容，包括视图创建，计算布局，视图布局。 当Runloop在BeforWaiting和Exit时，会通知注册的监听， 然后对图层打包，打包后将打包数据发送给一个独立负责渲染的进程Render Server。2.数据达到Render Server后会被反序列化，得到图层树，然后再次过滤之后得到渲染树，渲染树的信息会转给OpenGL/Metal， 3.Render Server会调用GPU，总结一句话，CPU处理完渲染内容会输入到Render Server中， 经图层树和渲染树的转换，通过OpenGL接口提供给GPU，GPU处理完后在屏幕上显示 73 屏幕成像 Cpu——计算——&gt;GPU—渲染—&gt;帧缓存———读取——&gt;视频缓存器——显示——&gt;屏幕 卡顿产生的原因, vsync(垂直信号)来的时候, 页面没渲染完, 就会等待下一次的再来的时候渲染—cpu—&gt;—GPU—&gt;(VSync)— 卡顿优化—CPU1.尽量用轻量级的对象, 比如用不到事件点击处理的地方, 可以考虑使用CALayer取代uiview2.不要频繁调用uiview的相关属性, 比如 frame bounds3.尽量提前计算好布局, 在需要时一次性调整对应的属性4.autolayout会比直接设置frame消耗更多的cpu资源5.图片的size最好刚好跟uiimageView的size保持一致6.控制一下线程的最大并发数量7.尽量将耗时的操作放在子线程—文字处理(尺寸计算, 绘制)—图片处理(解码,绘制) 卡顿优化—GPU1.降级避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示2.GPU能处理的最大纹理尺寸是4096*4096, 一旦超过这个尺寸, 就会占用cpu资源进行处理3.尽量减少视图数量和层次4.减少透明的视图5.尽量避免出现离屏渲染 耗电优化1.尽可能降低CPU,GPU功耗2.少用定时器3.优化IO操作—尽量不要频繁写入小数据, 最好批量一次性写入—读写大量重要数据时, 考虑用dispatch_io 其提供了基于GCD异步操作文件IO的api, 用dispatch_io系统会优化磁盘—数据量比较大的, 建议使用数据库4.网络优化—减少,压缩网络数据—如果多次请求的结果相同, 尽量使用缓存—断点续传—网络不可用, 不要尝试执行网络请求—网络操作设置超时时间5.定位优化 74 离屏渲染在openGL中, GPU有两种渲染方式——当前屏幕渲染, 在当前用于显示的屏幕缓冲区进行渲染操作——离屏渲染, 在当前屏幕缓冲区外开辟一个缓冲区进行渲染操作(当使用圆角, 阴影,遮罩的时候, 图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制, 所以就需要离屏渲染) 离屏渲染消耗的原因—需要创建新的缓冲区—离屏渲染的整个过程, 需要多多次切换上下文环境, 先从当前屏幕切换到丽萍,哪些操作会触发离屏渲染—光栅化—遮罩—maskstoBounds +cornerRaudius,解决方案:通过coreGraphics 绘制剪裁圆角或者uibezierpath+CAShapeLayer来做—阴影——如果设置了layer.shaowpath 就不会产生离屏渲染 49 离屏渲染 离屏渲染的代价很高, 想要进行离屏渲染, 首先要创建一个新的缓冲区, 屏幕渲染会有一个上下文环境的概念, 离屏渲染的整个过程需要切换上下文环境, 从当前屏幕切换到离屏, 等结束后, 又要讲上下文环境切换回来 离屏渲染触发的场景 0. 圆角 0. 图层蒙版 0. 阴影 0. 光栅化 50 如何提高 tableview 的流畅度 优化cpu 0. 尽量用轻量级的对象, 比如用不到点击时机的地方可以考虑用calayr取代uiview 0. 不要频繁的调用uiview的相关属性, 比如frame, bounds,transform等属性, 尽量减少不必要的修改 0. 尽量提前计算好布局, 在有需要时, 一次性调整对应的属性, 不要多次修改属性 0. autolayout 会比直接设置 frame 消耗更多的cpu资源 0. 图片的size最好刚好跟uiimageview的size保持一致 0. 控制一下线程的最大并发数量 0. 尽量把耗时的操作放在子线程 0. 文本的处理 尺寸计算, 绘制 0. 图片处理, 解码, 绘制 优化GPU 0. 避免出现离屏渲染 0. 尽量减少视图数量和图层 0. 尽量避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示 65 实现监听卡顿添加Observer到主线程RunLoop中, 通过监听RunLoop状态切换的耗时, 以达到监控卡顿的时间—结束休眠到处理source0,这段时间—监听beforeSource和afterWaiting, 也就是source0回调和接受mach_port 消息两个状态. 一旦发现进入睡眠前的KCFRunloopBeforeSource状态, 或者唤醒后的状态 KCFRunloopAfterWaiting, 在设置的时间阈值内一直没有变化, 即可判定为卡顿—dump 出堆栈的信息, 从而进一步分析出具体哪个方法执行时间过长 62 CALayer 的一些具体属性, 介绍下各个layercontents id类型, 可以是任何类型的对象, 但是一般都是复制CGimagemask 遮罩, 让父图层部分区域可见 一个渐变色, 如果不创建新的layer, 如果写一个view.layer.mask = CAGradientLayer CAShapeLayer: 指定CGpath和贝塞尔曲线, 可以画出各种图形CAGradientLayer: 渐变色CATiledLayer:大图绘制 隐式动画: CoreAnimation 在每个runloop周期中自动开始一次新的食物. 任何在一次runloop循环中属性的改变都会被集中起来, 然后做一次0.25s动画关闭 [CATransaction begin]; [CATransaction setDisableActions:YES]; XXX [CATransaction commit]; 76 安装包瘦身资源—采取无损压缩—去除没有用到的资源 可执行文件瘦身—去掉异常支持 检测未使用的代码检测重复代码, 未被调用的代码 55 NSTimer 循环引用 RunLoop强引用了Timer, timer强引用了VC, 所以无法释放为什么用weakSelf也不行? 因为timer传进入的对象, 会重新strong一下 71 CADisplayLink 和 NSTImer 注意点这里俩都会对target产生强引用, 如果target又对他们强引用, 就会引发循环引用使用NSProxy弱引用解决NSPorxy本身是一个抽象类, 他遵守NSObject协议, 提供了消息转发的通用接口VC强引用了Timer, Timer强引用了porxy, 但是porxy弱引用了VC NSProxy 一个抽象的超类, 通常发给proxy的消息会被转发给实际对象 47 访问 __weak 修饰的变量是否已经被注册在了 @autoreleasePool中__weak修饰的变量属于弱引用, 如果没有被注册到 @autoreleasePool中, 创建之后也就会随之销毁, 为了延长它的生命周期, 必须注册到 @autoreleasePool 中, 亿延缓释放 _unsage_unretained, 和 weak一样, 表示的事对象的一种弱引用关系, 唯一的区别是, __weak 修饰的对象别释放后, 指向对象的指针会置空, 也就是指向nil, 不会产生野指针. 而_unsafe_unretained修饰的对象被释放后, 指针不会置空, 而是变成野指针, 那么此时如果访问这个对象的话, 程序就会crash, 抛出BAD_ACCESS的异常 ARC 16 ARC的实现原理？ARC下对retainrelease做了哪些优化ARC 是LLVM编译器你和runtime系统相互协作的一个结果RAC所做的无非就是在合适的时机帮我们添加retain, release 或者autoRelease, 无需程序员手动写这些代码, 本质上和MRC一样, 但是比MRC手动写更高效, 因为ARC是直接调用C语言的方法https://blog.csdn.net/wangyanchang21/article/details/79461511 Copy 或者strong 会增加引用计数吗? Strong 会, copy. 分情况, 可变对象, 还是不可变对象 以alloc,copy, mutableCopy new这些方法会被标记位 __attribute(ns_returns_retained). 以这些方法创建的对象, 编译器会在调用方法外网要加上内存管理代码 retain/release, 所以会在作用域结束的时候就会释放. 而不以这些关键字开头的方法, 会被标记为 __attribute(ns_returns_not_retained). 编译器会在方法内部自动加上 autorelease方法, 这些方法会被注册到自动释放池, 同时其释放会延迟, 等到自动释放池销毁的时候才释放 MRC中对一个对象执行autorelease 会发生什么, 引用计数1. ARC中用 autoreleasing 修饰 引用计数为2. 因为他转换成了 id o = [obj retain] autorelease];-(id)autorelease{[NSAutoreleasePool addobject:self]} 15 Autoreleasepool的原理？所使用的的数据结构是什么struct __AtAutoreleasePool{ void *atAutoreleaseobj = objc_autoreleasePoolPush(); objc_autoRealeasePoolpop(autoreleasepoolobj);}objc_autoreleasePoolPush ==&gt; autoreleasePoolPage:pushobjc_autpreleasePoolPop ===&gt;autoreleasePoolPage::pop(ctxt) autoreleasePoolPage 是一个双向链表class autorealsePoolPage{ magic_t const magic id *next pthread_t const thread AutorealesePoolPage * parent AutorealeasePoolPage *child depth hiwat} 哨兵对象 POOL_SENTINEL, 就是nil, 释放的时候一直释放到哨兵对象为止 16 什么对象会放到autoreleasepool里面什么对象不都会__autoreleasing声明的对象都会放到pool里—静态变量不会放到autoreleasepool—objc_autoreleaseReturnValus()后面跟着objc_retainautoreleaseReturnValue()不会放到autoreleasePool, 比如 NSMutableArray的array方法 17 ARC下哪些情况会造成内存泄漏Block 两个对象循环引用, 错误的delegate属性, nstimer MRC下重写set方法 (Void)setA:(int)A{ if (_A != A){ _A release; _A = [A retain]}} (Void)setA:(int)A{[A retain]_A relase_A = A} 44 MRC 下重写Set 和get -(Void)SetA:(NSString *)brand{ if (_brand != brand){ _brand release; _breand = [brand retain]}} -(NSString *)getBrand{ return [_brand retain] autorelease]} -(void)dealloc{ _string release]; super dealloc]} runtime 1 什么是RuntimeOC是一门动态性的编程语言, 允许很多操作推迟到程序运行时在进行. OC的动态性就是由Runtime来支撑和实现的, Runtime是一套C语言的API, 封装了很多动态性相关的函数. 平时编写的OC代码, 底层都是转换成了Runtime API进行调用 具体应用 0. 关联对象给分类添加属性 0. 遍历类的所有成员变量 0. 交换方法实现 0. 利用消息转发机制解决方法找不到的异常 1.介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）Struct objc_class{ class isa class superClass cache_t cache //方法缓存 class_data_bits_t bits //用于获取具体的类的信息} Struct class_rw_t{ uint32_t flags; unit32_t version; const class_ro_t *ro method_list_t *methods; //方法列表 property_list_t *perperties //属性列表 const protocol_list_t *protocols //协议列表} Struct class_ro_t { unit32_t instanceSize; // instance 对象占用的内存空间 const char *name method_list_t *baseMethodlist protocol_list_t *baseProtocols const ivar_list_t *ivars // 成员变量列表} 2.isa详解 在arm64架构之前, isa就是一个普通的指针, 存储这calss, meta-class对象的内存地址从arm64架构开始, 对isa进行了优化, 变成了一个共用体(union)结构, 还是用位域来存储更多的信息 20.对象的isa指针指向哪里 instance对象的isa指针指向class对象,class对象的isa指针指向meta-class对象,meta-class对象的isa指针指向基类的meta-class对象,基类自己的isa指针也指向自己 runtime面试题 [self class] //当前类[super class] //当前类 —objc_msgsendSuper((_rw_objc_super){(id)self, (id)class_getSuperClass(objc_getClass(“当前类”))}, @selector(“class”)), 里面的receiver 依然是self, 后面的class, 决定方法从哪里开始找—从当前类的父类开始寻找class方法, 最后找到了NSObject [self superclass] //父类[super superclass] //父类 [super message]的底层实现 0. 消息接受者仍然是子类对象 0. 从父类开始查找方法的实现 -(class) class{ return object_getClass(self);} -(class)superClass{ return class_getSuperclass(object_getClass(self))} 面试题1 BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; 1 BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; 0 BOOL res3 = [(id)[Person class] isKindOfClass:[Person class]]; 0 BOOL res4 = [(id)[Person class] isMemberOfClass:[Person class]] ; 0 BOOL res5 = [(id)[Person class] isKindOfClass:[NSObject class]]; 1 BOOL res6 = [(id)[Person class] isMemberOfClass:[NSObject class]]; 0 -(BOOL)isMemberOfCLass:(class )cls{return object_getClass(self) == cls} -(BOOL)isKindOfClass:(class)cls{ for(class cls == object_GetClass(self);tcls = tcls-&gt;SuperClass){ if tcls == cls return yes }} 面试题2@interface MDPerson: NSObjct@property (nonatomic, copy) NSString *name-(void)print@end @implementation MJPerson-( void)print{NSLog(@“my name %@”,self.name)} id cls = [MJPerson class]Void *obj = &amp;cls((__bridge id)objc print)打印输出— my name [uiviewcontroller ] 为什么可以输出?通过objc 找到对应内存, 然后取出前8个字节, 这前八个字节刚好是isa指针, 通过isa可以找到类 为什么输出 uiviewcontroller [super viewdidLoad] 导致的内存布局, 从高到低 21 iOS 中内省的几个方法有哪些？内部实现原理是什么isKindOfClass:isMemberOfClass:respondToSelector:conformToProtocol: 会查父类class_conformToProtocl 只查当前类 23 class、object_getclass ,objc_getClass方法有什么区别?当参数为实例对象的时候, class 和 object_getclass 返回的都是当前的类如果参数是类, class返回的是当前类, object_getclass获取的是元类 objc_getClass 根据字符串获取类 https://www.jianshu.com/p/0d4d8a79fd97 2.为什么要设计metaClass功能分离, 各司其职, 符合单一职责设计原则, metaClass是关于类的类, 类方法会存在metaClass里面 3 class_copyIvarList 和 class_copyPropertyList的区别class_copyIvarList 会获取所有属性和成员变量, 属性会有个_class_copyPropertyList 会获取所有的属性 4 子类如何获取父类的属性通过class_copyPropertyList 获取的只有子类的属性, 如果想获取父类的属性就需要调用 [self superclass], 同理, method_list 和 iva_list都是一样的, 只能包含当前类的, 不包含父类的 4 class_rw_t 和 class_ro_t的区别class_rw_t结构体包含class_ro_t, class_ro_t主要是类无法修改, 已经确定的东西, class_rw_t是可以扩充的, 在runtime新增的东西都放在了class_rw_t里面 14 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？不需要, 因为被关联的对象在生命周期内要比对象本身释放的晚, 他们会在NSObject - dealloc调用objct_dispose()方法中释放对象的内存销毁时间表, 分为四个步骤 1 调用 -release 引用计数变为0 2 父类调用 -dealloc 3 NSObject 调用dealloc, 在这里只做了一件事情, 调用object_dispose()方法 4 调用 object_dispose 1 解除所有使用Runtime Associate方法管理的对象 2 解除所有 _weak引用 24 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？不可以向编译后得到的类添加实例变量, 因为编译后的类已经注册在runtime中, 类结构体重的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定运行时创建的类是可以添加实例变量, 调用class_addIvar函数. 但是得在调用objc_allocateClassPaird之后, objc_registerClassPair之前 25 runtime如何通过selector找到对应的IMP地址？ 先介绍下struct method_t{SEL, IMP, chat } SEL 和 IMP是一一对应的在寻找IMP地址时, runtime提供了两种方法A IMP class_getMethodImplementation(Class cls, SEL name) B IMP method_getImplementation(Method m), 对于方法A, 类方法和实例方法实际上都是通过调用class_getMethodImplementation来寻找IMP地址, 不同之处是传入的第一个参数不同, 类方法传的是 objc_getMetalClass(“A”), 实例方法 [A class], 通过传入不同的参数, 找到不同的方法列表, 对于方法B, 类方法 Method class_getClassMethod(class cls, SEL name) 实例方法 Method class_getInstanceMethod(Class cls, SEL name), 最后调用 IMP method_getImplementation(Method m)获取IMP地址 8在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么1 先看当前方法是不是可以被忽略 2.查看self是不是nil 3. 查找cache 4.从当前类查找methodList, 然后再去父类, 已知找到NSobejct , 如果还没找到开始动态方法解析和重定向,转发 9 IMP、SEL、Method的区别和使用场景Method是一个method_t的结构体, 里面有IMP函数指针, 指向具体的方法实现, SEL是方法名类型使用场景: 实现类的swizzle的时候会用到, 通过class_getInstanceMethod(Class, SEL), 获取类的方法Method, class_addMethod(Class, SEL,IMP) 11 说说消息转发机制的优劣可以预防crash, 实现多继承 22 什么是method swizzling（俗称黑魔法), 为什么可以做到先说下 Method的结构Struct Method{ imp 指向具体的实现 SEL 方法名 char *types} 23 什么时候会报unrecognized selector的异常说下方向寻找的过程,objc_class:objc_object{ cache} 先去cache中寻找, 如果cache没有找到, 就是methodlist中寻找, 先子类在父类, 一直找到NSObject, 如果还没有找到, 就进入消息转发, 这里给了三步 27 objc在向一个对象发送消息时，发生了什么？objc_sendMsg(self,SEL,…);先去判断self是不是nil, 如果是nil, 直接return, 否则进入下一步查找sel, 先去cache中查, 如果没有就去methodList查, 先子类在父类, 最后调用到了Nsobject, 如果还没有就进入动态方法解析和消息转发阶段 //第一步,动态方法解析 给个机会让类添加这个实现的函数—这个方法需要在类的本身上动态添加它本身不存在的方法, 这些方法对于该类来说是冗余的 (BOOL)resolveInstanceMethod:(SEL)aSEL{ if (aSEL == @selector(foo:)){class_addMethod([self class], aSEL, (IMP)fooMethod,”V@:”)Return YES} return [super resolveInstanceMethod]} // 第二步消息转发 让别的对象去执行这个函数——将这个消息转发给一个对象, 开销较小, 并且被重写的概率较低, 适合重写-(id)forwardingTargetForSelector:(SEL)aSelector{ if (aSelector == @selector(foo:)){ return [BackupClass alloc]ini];}Return [super forwardingTragetForSelector:aSelector]} 返回self会咋么样 会继续执行, 先执行methodSignatureForSelector, 在走回resolveInstanceMethod, 在直接执行到forwardInvocation //第三步 —通过NSInvocation的形式将消息转发给多个对象, 但是其开销较大, 需要创建新的NSInvocation对象, 并且forwardInvocation的函数经常被使用者调用, 来做多层消息转发机制, 不适合多次重写里面的invocation 是从methodsignatureForSelector 获取, 如果返回nil转发流程终止, 抛出无法处理的异常-(void)forwardInvocation:(NSInvocation *)invocation{ SEL sel = invocation.selector if (newObject invokeWithTarge:sel){ [invocation invokeWithTarget:alternateObjct]}else{ [self doesNotRecognizeSelector:sel];}} //通过类型编码获取方法签名 如果返回nil直接crash, 如果调用super 方法会走到resolveInstanceMethod 然后crash-(NSMethodSingature *)methodSignatureForSelector:(SEL)aSelector{ NSMethodSignature *methodSignature = [super methodsingatureForSelector:aSelector]; if (!methodSignautre){ methodsignature = [NSMethodSignature signatureWithObjcTypes:””V@:X]} return methodsignaure } https://juejin.im/post/5ae96e8c6fb9a07ac85a3860 26 objc中向一个nil对象发送消息将会发生什么？ 不会有任何错误, 也不会崩溃 如果这个方法返回值是一个对象, 那么发送给nil的消息将返回null如果返回值是float, doubel, 返回0如果方法返回值是结构体, 返回的结构体的值都是0 30 _objc_msgForward函数是做什么的 objc_msgForward是IMP类型, 用于消息转发, 当向一个对象发送一条消息, 但它并没有实现的时候, objc_msgForward 会尝试做消息转发涉及到的流程 18 Method Swizzle注意事项 在change之前, 先添加下, 看看当前类有没有这个方法, 防止更换了父类的方法防止多次更换, 两次更换相当于没有更换 Class = object_getClass([self class]); Method originalMethod = class_getInstanceMethod(className, ori); Method swizzleMethod = class_getInstanceMethod(className, swi); BOOL didAddMethod = class_addMethod(className, ori, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod)); if (didAddMethod) &#123; class_replaceMethod(className, swi, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else&#123; method_exchangeImplementations(originalMethod, swizzleMethod); &#125;RunLoop31 RunLoop 一个RunLoop 是一个事件处理环, 系统利用这个事件处理环来安排事物, 协调输入的各种事件. RunLoop的目的是让你的线程在有工作的时候忙碌, 没有工作的时候休眠, 节省CPU事件 RunLoop 实际上就是一个对象, 这个对象管理了其需要处理的事件和消息, 并提供了入口函数来执行事件. 线程执行了这个函数后, 就会一直处于这个函数内部”接收消息-&gt;等待-&gt;处理”的循环中, 直到这个循环结束, 函数返回 32 AFNetworking 中如何使用了RunLoop AFURLConnnectionOperation 这个类是基于NSURLConnection构建的, 为了希望能在后台线程接受Delegate回调, 为此AF单独创建了一个线程, 并在线程里启动了RunLoop, (void)networkRequestThreadEntryPointer:{ [NSThread currentThread] setName:@“AFNetworking”]; NSRunLoop *runLoop = [NSRunloop currentRunLoop] runLoop addPort:[NSMackPort Port] forMode:NSDefaultRunLoopMode][runloop run]} RunLoop启动前必须有至少一个timer observer source, 所以AFNetworking在[runloop run]之前先创建了一个新的NSMackPort 添加进去, 通常情况下, 调用者持有这个 NSMachPort(mack_port)并在外部线程通过这个Port 发送消息到Loop内,但此处添加Port 只是为了让RunLoop 不至于退出, 并没有用于实际发消息 当需要在这个后台线程执行任务的时候, AF通过[NSobject performSelectr:onThread]将这个任务扔到了后台线程的runLoop中 33 AutoReleasePool 何时释放 App启动后, 苹果在主线程RunLoop注册了两个Observer, 其回调都是 wrapRunLoopWithAutorealeasePoolHandler() 第一个Observer监视的事件是 Entry(即将进入Loop), 其回调内会调用 _objc_AutoRelaasePoolPush() 创建自动释放池, 其Order是-2147483647, 优先级最高, 保证创建释放池在其他回调之前 第二个 Observer 监听了两个事件,1. BeforeWaiting (准备进入休眠)时调用 _objc_autorealesePoolPop() 和 _objc_autoreleasePoolPush() 释放旧池并创建新池. 2. Exit (即将退出Loop)时调用 _objc_autorealeasePoolPop() 来释放自动释放池, 这个Observer的order 是2147347474, 优先级最低, 保证释放池子发生在其他所有回调之后 34 RunLoop的mode KCFRunLoopDefaultMode: 默认模式, 主线程是在这个运行模式下运行UITrackingRunLoopMode, 跟踪用户交互事件(用于scrollview追踪触摸滑动, 保证界面滑动时不受其他mode影响)UIInitializationRunLoopMode 在刚启动App的进入的第一个mode, 启动完成后就不再使用GSEventReceiveRunLoopMode 接受系统内部事件, 通常用不到KCFRunLoopCommonModes 伪模式, 不是一种真正的运行模式, 是同步Source/Timer/Observe到多个mode中的一种解决方案 36 RunLoop 的数据结构 NSRunLoop 是 CFRunLoop 的封装, 提供了面向对象的API RunLoop相关的主要涉及五个类CFRunLoop: RunLoop 对象CFRunLoopMode 运行模式CFRunLoopSource 输入源/事件源CFRunLoopTimer: 定时源CFRunLoopObserver 观察者 1 CFRunLoop 由 pthread, currentMode, modes, commonModes, commonModelItems 构成 2 CFRunLoopMode 由name source0 source1 observers timers 构成 3 CFRunLoopSource 分两种 source0 和 source1 source0 即非基于port 的, 也就是用户触发的事件. performSelector:onTHread,需要手动唤醒线程, 将当前线程从内核态切换到用户态Source1 基于port , 包含一个 mach_port 和一个回调, 可监听系统端口和通过内核和其他线程发送的消息, 能主动唤醒RunLoop, 接手分发系统事件, 具备唤醒线程的能力 4基于时间的触发器, 基本上说的就是NSTimer. 在预设的时间点唤醒RunLoop 执行回调. 因为他是基于RunLoop的, 因此他不是实时的5 CFRunLoopObserver 监听以下时间点: CFRunLoopActivity KCFRunLoopEntry RunLoop 准备启动 KCFRunLoopBeforeSources RunLoop 将要处理一些Source事件 KCFRunLoopBeforeWating 将要进行休眠状态, 即将由用户态切换到内核态 KCFRunLoopAfterWaiting RunLoop 被唤醒, 即从内核态切到用户态 KCFRunLoopExit RunLoop 退出 KCFRunLoopAllActivities 监听所有状态 什么叫内核态和用户态内核态:运行操作系统程序, 操作手机硬件资源, 比如协调CPU资源, 分配内存资源用户态:运行用户程序. 内核提供通用的访问接口, 让用户态调用当一个进程在执行用户自己的代码是处于用户态. 用户态没有能力直接操作硬件, 只能通过操作操作系统内核提供的调用使用硬件资源当一个进程因为系统调用陷入内核代码中执行时处于内核态 37 解释下事件相应的过程 苹果注册了一个 source1 用来接收系统事件, 其回调函数为 IOHIDEventSystemClientQueueCallBack() 当一个硬件事件(触摸/锁屏/摇晃等)发生后, 首先由 IOKit.framework 生成一个 IOHIDEvent 事件, 并由 SpringBoard 接收. SpringBoard 只接收按键(锁屏/静音等) 触摸, 加速, 接近传感器等几种 event, 并调用 UIApplicationHandleEventQueue() 进行应用内部的分发. UIApplicationHandlerEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理分发, 其中包括识别 UIGesture/处理屏幕旋转.发送给 UIWindow 等. 通常事件, 比如 UIButton 点击 touchesBegin/move/end/cancle 事件都是在这个回调中完成的 KVC&amp;KVO 53 KVCsetValue:forkey setObject:forKeysetValue 中value可以为nil, 但是setobject不行, 如果setValue中value是nil, 会自动调用removeObjectForKeysetValue中的key只能是NSString, 但是setObject中的key可以使任意类型 使用KVC给一个对象赋值时, 会有以下方法和属性的调用顺序 0. 查看setXXX 或者 _setXXX 方法 0. 查看+ (Bool)accessInstanceVariablesDirecty 方法的返回值, 默认返回yes 0. yes: 可以访问成员变量, 进入下一步 0. NO 不可以访问成员变量, 同时调用 -(void)setValue:(id)value forUndefinedKey:(nsstring *)key方法, 如果方法不存在会抛出异常 0. 调用成员变量: _key _isKey key isKey 0. 调用顺序, 从左到右, 只要发现存在成员变量, 就不会调用后续变量 0. 如果没有成员变量, 会调用-(void)setValue:(id)value forUndefineKey 方法, 如果方法不存在会抛出异常 KVC取值是, 方法和成员变量的调用顺序 0. 判断是否有这几个方法 getKey key isKey _key, 依次调用 0. 调用+ (Bool)accessInstanceVairablesDirectkly 勘察是否可以访问成员变量 默认yes 0. Yes, 可以访问成员变量, 进入下一步 0. No, 不可以访问成员, 判断是否实现 -(id)valueForUndefinedKey:(NSString *)key, 实现是调用, 未实现报错 0. 判断是否有这几个成员变量 _key _iskey key isKey, 一次调用 0. 判断是否实现 -(id)valueForUNdefineKey:(NSSTring *)key方法, 实现时调用, 未实现报错 KVC可以修改只读. (为什么?) 51 KVO 实现原理 KVO 是通过 isa-swizzling 技术实现的, 在运行时根据原类创建一个中间类 NSKVONotifying_XXX, 这个中间类是原类的子类, 并动态修改当前对象的isa指向中间类, 并且将class方法重写返回原类的 class, dealloc. isKVO方法, , 所以苹果建议在开发中不应该依赖isa指针, 而是通过class实例方法获取对象类型 重写的类classdeallocset方法isKVO 苹果也会重写对于的set方法, 将原来的setXXX方法转换成C语音的foundation框架的 _NSSetXXXValueAndNofity 函数, 子类拥有自己的set方法实现, set方法实现内部会顺序调用 willChangeValueforKey 原来的setter方法实现, didChangeValueforKey方法. didChangeValueforKey 会调用监听器的方法 KVO可以监听category中的属性, 也是重写了set方法 如何手动触发KVO? 通过实例对象调用willChangeValueForKey 和 didChangeValueForKey, 能否不调用willChangeValueForKey 不调用Didchange? 不可以. 因为didChange内部会检查是否执行了willchange, 如果没有被调用是不会触发监听方法的 通过KVC赋值也会触发KVO. 通过KVC修改成员变量也会触发KVO, 可能内部会调用willchangevalueforkey didchangevalueforkey但是 直接修改成员变量不会触发KVO 52 NSNotification 实现原理 [NSNotificationCenter defaultCenter] addObserver:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; name:&lt;#(nullable NSNotificationName)#&gt; object:&lt;#(nullable id)#&gt;通知中心是单例类, 并且通知中心维护了一个包含所有注册的观察者的集合 首先在初始化 NSNotificationCenter会创建一个对象, 这个对象里面保存了 NamedTable ,unNameTable ,wildcard 和一些其他东西根据传入的参数实例化一个obarvation, observation对象保存了观察者对象, 接收到通知观察者所执行的方法, 以及下一个observation对象的地址根据是否传入notificationName, 选择操作NamedTable 还是NameLessTable若传入了NotificationName, 则会以NotificaitonName为key去查找对应的table(这个table key是object, value 是一个链表), 若找到table, 则取出对应的table. 若未找到对应的table, 则新建一个table, 然后将这个table以NotificaitonName为key添加到NamedTable中若在保存Observation 的table找那个, 以object为key取对应的链表. 若找到了则直接在链表尾部插入之前创建的observation. 若未找到则以之前实例好的Observation对象作为头结点插入进入 NSNotification是同步的 多线程 40 线程和进程 多线程的优点 适当提高程序的执行效率, 适当提高资源利用率 (Cpu, 内存利用率) 缺点: 开启线程需要占用一定的内存空间, 默认情况下, 主线程1M, 子线程512kb, 如果开启大量线程, 会占用大量的内存空间, 降低程序的性能线程越多, cpu在调度线程上的开销就越大程序设计更加复杂, 比如线程之间的通信, 多线程的数据共享 42 NSOperation NSOperation 是苹果对GCD的面向对象的封装, 他使用起来比GCD更加灵活, 功能更加强大, 虽然会增加一点点额外的开销, 但是却换来了非常强大的灵活性和功能, 我们可以给operation直接添加依赖关系, 取消一个正在执行的opreation, 暂停和回复 operation queue等. NSOperation 和 NSOperationQueue 还提供了判断执行状态, 取消任务, 控制线程数量等更多任务管理的api 添加依赖NSoperationQueue *queue = []NSBlockOperation *op1 = []NSBlockOperation *op2 = []op2.completionBlock = ^{} [Op1 addDependency:op2]Queue addOperation:op1] 63 GCD GCD 是基于XNU内核实现的 自动利用CPU的高性能多线程解决方案. 能自动管理分配线程池GCD 有三种队列 0. 主线程队列 0. 全局队列 0. 自定义队列 同步: 只能在当前线程中执行任务, 不具备开启新线程的能力, 任务立刻马上执行, 会堵塞当前线程并等待block中的任务执行完毕, 然后当前线程才会继续往下执行异步: 可以在新的线程中执行任务, 具备开启新线程的能力, 但不一定会开新线程, 当前线程会直接往下执行, 不会堵塞当前线程 线程和队列队列是保存以及管理任务的, 线程负责去队列中取得任务进行执行 0. dispatch_async用来异步执行任务, 可以分成三个阶段, 第一阶段是更新队列链表, 第二部分是从队列取任务, 第三部分是执行任务如果是async到主队列, 则会向主线程的RunLoop发送消息并唤醒Runloop, 接着会在回调函数中取出block并执行如果是async到其他线程, 会检测线程池中可用的线程, 从队列中依次取出任务执行 0. dispatch_sync—向串行队列提交同步任务, 执行的是dispatch_barrier_sync_f函数——如果当前队列没有任务执行, 则调用_dispatch_barrier_sync_f_invoke 执行任务——如果当前队列有任务执行, 等待该队列的任务执行完之后用信号量通知队列继续执行任务—向并发队列提交同步任务——如果队列存在其他任务, 使用信号量等待——没有任务, 直接调用_dispatch_sync_f_invoke执行任务 0. dispatch_barrier_async—如果是全局队列, 和dispath_async一样—如果是串行队列,同dispatch_sync 一样—自定义并行队列——等待前面任务执行完——修改suspend_count保证其他任务不会同步执行——barrier block执行完之后重置suspend_count实现多读单写的功能-(id)objectForKey:(NSString*)key{ dispatch_sync(concurrent_queue),^{}}-(void)setobject:(id)obj{ dispatch_barrier_async(concurrent_queue,^{})} dispath_barrier_sync 和 dispatch_barrier_async 都会隔离队列中栅栏前后的任务, 不同的是会不会阻塞当前队列 0. dispatch_groupdispatch_group本质是初始化一个LONG_MAX的信号量, 等到group中的任务完成其实是等待value回复初始值—dispatch_group_enter 和 _leave必须成对出现, 如果enter比leave多一次, 则wait函数等待的线程不会被唤醒和注册的notify回调block不会执行—如果leave比enter多一次, 则会引起崩溃 0. dispatch_once —用原子性操作block执行完成标记位, 同时用信号量确保只有一个线程执行block, 等block执行完在唤醒所有等待中的线程 0. Dispatch source 使用最多的就是用来实现定时器, source创建后默认是暂停状态, 需要手动调用 resume 启动定时器. dispatch_after 只是封装调用了dispatch_source定时器, 然后在回调中执行定义的block—resume和suspend调用次数需要平衡, 如果重复调用resume则会崩溃—source在suspend状态下, 如果直接设置source=nil或者重新创建source都会造成crash. 正确的方式是在resume状态下调用dispatch_source_cancle(source)后重新创建 0. dispatch_after 延迟提交,不是延迟执行, 函数依赖于 dipatch_source 定时器, 他注册了一个定时器, 然后在回调函数中执行block 0. dispatch_apply 类似一种for循环, apply是同步调用,block任务执行N次后才会返回, 用并行队列才能发挥最大的作用, 效率一般快于for循环的串行机制 0. 判断是否是执行线程使用dispath_queue_set_specific &amp; dispatch_get_speific 标记并获取指定队列dispatch_queue_t queueA = dispatch_queue_create(“com.lyk.queueA”, NULL); static int kQueueSpecific; CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;); dispatch_queue_set_specific(queueA, &amp;kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease); dispatch_sync(queueA, ^&#123; dispatch_block_t block = ^&#123; NSLog(@&quot;NO deadlock!&quot;); &#125;; CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific); if (retrievedValue) &#123; block(); &#125; else &#123; dispatch_sync(queueA, block); &#125; &#125;); 0. 死锁-(void)viewDidload{ [super viewDidLoad]; dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@“”deallock) })}同步对于任务是立即执行, 那么当把任务放进主队列是, 他就会立即执行, 只有执行完这个任务, viewDidLoad才会继续往下执行. 由于队列是先进先出原则, 任务有需要等待viewDidLoad执行完毕后才能继续执行. viewDidLoad和这个任务就形成了相互循环等待, 就造成了死锁 GCD面试题1dispatch_queue_t queue = dispatch_Get_global_queue(0,0)dispatch_async(queue, ^{nslog(@“1”)[self performSelector:@selector(test) withObject:nil afterDelay:0.0]NSLog(@“3”)}) 只会输出1,3 , test方法不执行, 因为没有runloop 面试题2NSThread *thread = [NSThread alloc]initWithBlock:^{ NSLog(@“1”)}];[thread start][self perforemSelector:@selector(test) onTheard:thread withObject:nil waitUntilNode:yes] 只输出1, 因为start之后, 线程就结束了, 解决方法, 新增runloop 面试题363 同步线程Aaa;dispatch_semaphore_t sema = dispatch_semaphore_create(0);AsyncNetRequest^(id response){ // use responsedispatch_semaphore_signal(sema, DISPATCH_TIME_FOREVER);Bbb;}dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);ccc; 方案2dispatch_group_t disGroup = dispatch_group_create()dispatch_group_enter(group);Aaa;AsyncNetRequest^(id response){ // use responseBbb;dispatch_group_leave(group);} dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^{ ccc }); 单例 +(id *)shared{Static manager *m = nilStatic dispathc_once_t onceToken;dispathc_once(&amp;onceToken, ^{ m = [manager alloc]init];});Return manager} 0. 线程和RunLoop的关系—Runloop和线程是一一对应的, 他们的关系保存在一个全局的字典里—对于主线程, runloop在程序一启动就默认创建好了, 但是子线程默认没有创建runloop. 需要使用懒加载的方式去获取 熟悉的第三方库 —Aspects实现原理—通过将目标函数的方法实现改写为转发函数的实现(objc_msgForward), 从而使对目标方法的调用可以走入主流程-方法改写中被改写的转发函数实现中, 从而相当于调用了改写后的方法 —-为什么在forwardInvocation?——因为消息转发的几个阶段的特性不太一样, resolveInstanceMethod:适合给类/对象动态添加一个相应的实现, forwardingTargetForSelector:适合将消息转发给其他对象处理 forwardInvocation: 是里面最灵活, 最能符合需求的——当执行objc_msgForward 会直接触发消息转发机制, 即 forwardInvocation 替换流程—动态创建子类—将子类的forwardInvocation的实现替换成ASPECTS_ARE_BEING_CALLED—将子类的元类的isa指向原生的类—注册子类—把self对象的isa指针指向子类—添加别名方法—替换原始方法为转发方法 _objc_msgForward 无法hook类方法因为在获取的方法的时候用的是[object class] instanceMethodsignatureForSelector:selector], 如果是类方法, 会返回nil —SDWebImage—先使用占位图—在缓存里找图片—硬盘里找图片—开始下载图片, 图片下载用NSURLConnection来做—下载成功后, 在NSOperationqueue完成解码—通知主线程宣告解码完成,然后回调展示图片—保存图片到内存和硬盘里源码再看看 如何加载高分辨率的图片—未来避免内存暴增, 将原图剪裁成多个小图, 然后依次绘制到目标位图context中—或者用苹果提供的异步绘制内容的图层CATiedLayer , 不需要加载全部图片, 可以将大图分解成小图片, 然后在载入显示 如何加载一个内存很大的图片: 降低采样率 AsyncDisplayKit将消耗时间的渲染,图片解码, 布局以及其他ui操作等等全部移除主工程, 这样主工程对用户的操作及时作出反应, 达到流畅运行的目的ASDisplayNode用UIView-CALayer 实现了ASNode-&gt;UIView的一种关系. 当不需要相应触摸事件时, ASDisplayNode 可以被设置为layer backed, node刚创建的时候, 并不会在内部创建uiview和calyer, 只有第一次在主线程访问uiview和calyer属性是, 他才会在内部生成相应对象. 当frame改变后, 等待runloop设置内部的uiviiew和layerASDK的图层预合成. 把一个大的层级绘制到一张图上, 性能会获得很大提升. cpu也避免了创建uikit对象的资源消耗 86 如将一张内存极大的图片可以像地图一样的加载出来使用CATiledLayer加载大图, tilelayer 设置一个缩放区间的集合和重绘阈值, 让让scrollView 在缩放时, 绘制层根据这些区域和缩放阈值去重新绘制当前显示的区域 图片内存大小, 字节数 = 宽高高度4(颜色RGBA占用的4个字节)1.之所有图片的大小与硬盘的占用大小无关是因为硬盘中的图片都是以不同的容器格式被编码了的, 如png, jpeg 等格式, 这些不能被用来直接显示;2.能够被用来直接显示的只有一种格式就是 bitmap 位图的方式. 要从硬盘中的容器格式变成位图,就会经历 图片解码的过程. 而解码后的位图大小计算方式如上 64 实现内存泄漏的检测为nsobject 新增一个属性willDealloc, 然后hook VC的dismiss或者pop方法, 在页面消失之后遍历页面的subviews, 访问新增的属性是否是nil 68 RN的声明周期getDefaultPropsgetInitalState:创建的时候调用的第一个函数. 对组件的一些状态进行初始化componentWillMount: 控件渲染前触发Render:渲染控件的方法componentDidMount:控件渲染后触发 66请画出一条开始和结束比较慢, 中间比较快的贝塞尔曲线1.创建CAShapeLayer 和 贝塞尔曲线 yellowLayer = [shapeLayer [alloc init]UIBezierPath *path = [UIBezierPath alloc]init]path moveToPointpath addLineToPointyellowLayer.path = path.cgpathself.view.layer addsubLayer:yellowLayer]2.动画CALayer *carcar.frame = CGRectMakecar.contents = (__bridge id _Nullable)([UIImage imageName:@“”].CGImage)CAKeyframeAnimation *ani = [CAkeyframeAnimation animationWithKeyPath:@“position”]Ani.path = yellowLayer.pathAni.duration = 1Ani.atuoreverses = NOAni.repeatCount = 1Ani.timingFunction = [CAMediaTimingFunction funcitonWithName:kCAMediaTimingFunctionEaseInEaseOut]yellowLayer addSubLayer:carCar addAnimation:ani forKey:@“carAni” 67递归搜索指定目录下指定类型文件的函数 (NSMutableArray *)filePathArray:(NSString *)directoryPath{ NSMutableArray *mFilePathArray = [NSMutableArray array]; NSFileManager *fileManager = [NSFileManager defaultManager]; //获取当前路径的文件 NSArray *array = [fileManager contentsOfDirectoryAtPath:directoryPath error:nil]; __block BOOL isDir = YES; [array enumerateObjectsUsingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) { NSString *path = [directoryPath stringByAppendingPathComponent:obj]; if ([fileManager fileExistsAtPath:path isDirectory:&amp;isDir])&#123; if ([path hasSuffix:@&quot;.png&quot;]) &#123; [mFilePathArray addObject:path]; &#125; if (isDir) &#123; NSLog(@&quot;继续遍历&quot;); [mFilePathArray addObjectsFromArray:[self filePathArray:path]]; &#125; &#125; }]; return mFilePathArray;} 57 wkwebview 的优点 0. 单独的进程加载url, app进程内存消耗不大, 但是ohter process的内存占比会增加 0. 在uiwebvew上内存占比太大的时候, app process 会crash, 但在wkwebview上当总体的内存占用比较大的时候, webContentProcess 会crash, 从而出现白屏现象 0. Ios9 有 customUserAgent, 单独页面定制ua 0. 代理回调很多, 比如https权限认证代理方法回调 0. 有一些坑没解决, 比如拦截post请求丢参数 0. Uiwebview 执行一段简单的js代码, 也会占用app大量内存, 而wkwebview, 不仅有出色的渲染性能, 而且他还有独立进程, 一些网页相关的内存消耗移到自身进程中, 最适合取代uiwebview 0. 39 打通前端与原生的桥梁: JSScore能干那些事情 0. JavaScriptCore, 原本是WebKit中用来解释执行JavaScript代码的核心引擎 0. JSCore框架主要由JSVirtualMachine JSContext JSValue类组成 0. JSVirtualMachine的作用是为JavaScript代码的运行提供一个虚拟机环境 0. JSContext是JavaScript运行环境的上下文, 负责原生和JavaScript的数据传递 0. JSValue是JavaScript的值对象, 用来记录JavaScript的原始值, 并提供进行原生值对象转换的接口方法 0. JavaScriptCore内部是由Parser InterPreter Compiler GC等部分组成 0. Js调用原生除了Block外, 我们还可以通过JSExport协议来实现在JavaScript中调用原生代码, 也就是原生代码中让遵循JSExport协议的类, 能够供JavaScript使用, 比如Weex 0. 原生调用js全局函数, 需要使用jsvalue的invokeMethod:WithArguments方法bridge调用, 拦截 decidePolicyForNavigationActionmk注入js, [mkwebview.configuration.userContentController addUserScript:时机 WKUserScriptInjectionTimeAtDocumentStart 注入时机为document的元素生成之后,其他内容load之前.. WKUserScriptInjectionTimeAtDocumentEnd 注入时机为document全部load完成,任意子资源load完成之前. UIWebView 支持全局的cookie可以共享 NSHTTPCookieStorage单利中的cookie而WKWebView不能共享（ WKWebView存储cookie的路径和NSHTTPCookieStorage存储cookie的路径目前是不同的 iOS 11.0后增加了【WKHTTPCookieStore】类，专门用来管理与之关联的WKWebView的Cookie 应用1.获取ios内存 #import &lt;sys/sysctl.h&gt;#import &lt;mach/mach.h&gt;获取当前设备的可用内存 获取到的是字节, 转换成M需要处于1024/1024 (double)availableMemory{vm_statistics_data_t vmStats;mach_msg_type_number_t infoCount =HOST_VM_INFO_COUNT;kern_return_t kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount);if (kernReturn != KERN_SUCCESS) { return NSNotFound;}return ((vm_page_size *vmStats.free_count) /1024.0) / 1024.0;}获取当前任务所占的内存 (double)usedMemory{task_basic_info_data_t taskInfo;mach_msg_type_number_t infoCount =TASK_BASIC_INFO_COUNT;kern_return_t kernReturn =task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;taskInfo, &amp;infoCount);if (kernReturn != KERN_SUCCESS) &#123; return NSNotFound;}return taskInfo.resident_size / 1024.0 / 1024.0;} 2.ios启动周期1.didfinishLaunchingWithOption2.applicationDidBecomeActive //进入后台2.applicationWillResignActive3.applicationDidEnterBackground //进入前台4.applicationWillEnterForeground5.applicationDidBecomeActive App的声明周期1.loadview—不应该被直接调用, 如果self.view 为nil 会调用self.loadview 创建uiview2.viewDidLoad3.viewWillAppear4.viewwillLayoutsubviews5.viewDidLayoutSubviews6.viewDidAppear7.viewWillDisapper8.viewDidDisappear9.viewWillUnload10.viewDidUnloaddealloc 3.strlen和sizeof的区别sizeof是求数据类型所占的空间大小,而strlen是求字符串的长度 4.宏最大值#define MAX(x,y) (((x)&gt;(y))?(x):(y)) 5 隐式动画和显示动画隐式动画一直存在, 如需隐藏需设置显示动画不存在, 如果显示要创建 6.NSInvocation与PerformSelector区别作用一样, 都可以实现直接调用某个对象的消息在参数个数&lt;= 2的时候performSelector：的使用要简单一些，但是在参数个数 &gt; 2的时候NSInvocation就简单一些 7.autolayoutAutolayout基于布局算法CAssowary. autoLayout的核心是一个layout Engine 的布局引擎系统. 每个视图在得到自己的布局之前, layout Engine 会将视图, 约束, 优先级, 固定大小通过计算转换成最终的代销和位置. 在layout engine里, 每当约束发生变化, 都会触发layout, 完成后进入监听约束变化的状态.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"iOS面试","slug":"iOS面试","permalink":"http://fangliquan.github.io/tags/iOS%E9%9D%A2%E8%AF%95/"}]},{"title":"iOS面试整理(一)","slug":"iOS面试整理(一)","date":"2021-03-14T07:53:58.000Z","updated":"2021-03-16T03:24:54.576Z","comments":true,"path":"2021-03-14/iOS面试整理(一)/","link":"","permalink":"http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/","excerpt":"","text":"iOS一、内存管理1.谈谈对内存管理的理解MRC (手动引用计数) 和ARC (自动引用计数) MRC 核心思想：引用计数式内存管理 四个法则 自己生成的对象自己持有 (使用 alloc/new/copy/mutableCopy 开头的方法生成对象后持有对象) 非自己生成的对象自己也能持有 (retain) 123id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有&#x2F;&#x2F; 通过autorelease使对象的持有权在AutoreleasePool[obj retain]; &#x2F;&#x2F; 自己持有对象 不再需要自己持有的对象时释放 (release) 非自己持有的对象不能释放 对象操作对应的方法 对象操作 OC中方法 retainCount变化 生成并持有对象 alloc/new/copy/mutableCopy +1 持有对象 retain +1 释放对象 release -1 废弃对象 dealloc 无 alloc/new方法通过调用 allocWithZone: 类方法分配存储空间并初始化，同时使得retainCount = 1。 调用 retain 方法后引用计数值+1。 调用release方法后引用计数-1。 当retainCount = 0 时，调用 dealloc 方法废弃对象。 苹果将引用计数保存在引用计数表中（是一个散列表） 优点： 对象内存块的分配无需考虑内存块头部 引用计数表各记录中有内存块地址，可从各个记录追溯到各对象的内存块。（即使对象占用内存块损坏，能够根据引用计数表找到各内存块的位置） autorelease autorelease使得对象在超出其作用作用域（生命周期）后，在废弃autoreleasepool时，其中所有对象的release方法会被调用一次，可以指定变量的作用域。 步骤： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 对象方法 废弃NSAutoreleasePool对象。（调用 - drain 对象方法） release 和 autorelease 区别： 调用 release 方法，对象会立即被释放 调用 autorelease 方法，对象不会立即被释放，而是被注册的 autoreleasepool 中，当autoreleasepool 对象被废弃时（drain），对其中的对象都做一次 release 操作。 ARC 本质还是引用计数式内存管理 由编译器进行内存管理。实际上是 编译器 + 运行时库。在编译时，系统自动在合适的位置添加 retain/ release/ dealloc/ autorelease 方法。 所有权修饰符 ARC中通过变量所有权修饰符，不需要使用 retain/release 就能完美满足引用计数式的思考方式： 从手写 release 语句变为通过控制对象的作用域控制对象的释放。 “自己生成的对象自己持有” 和 “非自己生成的对象自己也能持有” 通过对带 __strong 修饰符的变量赋值即可达到，“不再需要自己持有的对象时释放”通过废弃带 __strong 修饰符的变量（变量作用域结束或成员变量所属对象被废弃）或变量赋值（nil）（block中打破循环引用）做到。 __strong、__weak、__autoreleasing 修饰的自动变量会自动初始化为nil 对象没有被变量强引用着时，该对象被释放。 __strong : id 类型和对象类型默认的所有权修饰符。表示对对象的强引用。 在被 __strong 修饰的变量超出其作用域时，即在该变量被废弃时，会释放其被赋予的对象（随强引用的失效，引用的对象随之释放）。当要废弃被强引用的对象时，要保证所有指向该对象的强引用变量都置为nil。 __weak 提供弱引用，弱引用不能持有对象。当持有对象的弱引用时，若该对象被废弃，则此弱引用自动失效，且被置为nil。 使用 __weak 修饰符的变量，就是使用注册到 autoreleasepool中的对象。 __unsafe_unretained 声明这个引用不会保持对象的存活，如果对象被废弃，不会被置nil，该变量会变成野指针。使用被其修饰的变量时，先判断是否存在。被其修饰的变量不属于编译器的内存管理对象。 __autorelease 在ARC中替代 - autorelease 方法。如果方法名不以 alloc/new/copy/mutableCopy 开头，编译器自动将返回值的对象注册到 autoreleasepool 中（ init 开头的方法返回的对象不会被注册到 autoreleasepool 中，只是对 alloc 方法返回值的对象） 内存泄漏：应当被废弃的对象在超出其生存周期后依然继续存在。 2.ARC如何实现？通过变量所有权修饰符，满足引用计数式内存管理。 编译器+运行时。 ==通过运行时发送消息，通过编译器自动插入release==。 __strong 修饰符 使用 alloc/new/copy/mutableCopy 产生对象 123&#123; id __strong obj &#x3D; [[NSObject alloc] init];&#125; 在编译后转换为 123id obj &#x3D; obj_msgSend(NSObject, @selector(alloc));obj_msgSend(obj, @selector(init));obj_release(obj); &#x2F;&#x2F; 编译器插入 两次调用 obj_msgSend() 方法，在作用域结束调用 obj_release 释放对象。编译器自动插入了release。 非 alloc/new/copy/mutableCopy 产生对象 123&#123; id __strong obj &#x3D; [NSMutableArray array];&#125; 编译后转换为 123id obj &#x3D; objc_magSend(NSMutableArray, @selector(array));objc_retainAutoreleaseReturnValue(obj); &#x2F;&#x2F; 编译器插入objc_release(obj); objc_retainAutoreleaseReturnValue() 函数用于持有对象，但持有的对象应为函数的返回值或者注册在 autoreleasepool 中的对象。 123+ (id) array &#123; return [[NSMutableArray alloc] init];&#125; 编译后转换为 12345+ (id) array &#123; id obj &#x3D; objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 调用obj_autoreleaseReturnValue() 时，如果方法或函数的调用方在调用了方法或函数后紧接着调用了 objc_retainAutoreleaseReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool 中-而是直接传递给方法或函数的调用方。 3.对MRC的理解4.GC（垃圾回收）和ARC的区别？ ARC 相比 GC 优点： ARC 工作在编译期，在运行时没有额外的开销。 ARC 的内存回收是平稳进行的，当对象不被持有时会立即被回收。 GC 的内存回收时需要暂停程序，会有一定的卡顿。 ARC 相比 GC 缺点： ==ARC 需要手动处理循环引用等内存管理问题，GC 不需要。== 5.内存关键字（assign, weak, strong, copy, retain)介绍 assign：用于非对象类型。其 setter 方法只是执行简单的赋值操作。 weak：用于对象类型，表示弱引用。其 setter 方法中既不保留新值，也不释放旧值，同assign类似。 但是在属性所指对象遭到废弃时，属性值会被置nil。 strong：用于除 NSString/block 之外的对象类型，表示一种“拥有关系”，表示对对象的持有和强引用。其 setter 方法中，先 relsease 旧值，再 retain 新值。 copy：所表达的所述关系与 strong 类似。在其 setter 方法中，不保留新值，而是将其 copy。当属性类型为 NSString 类型时，通过 copy 关键字保护器封装性，防止指向 MutableString 类型。 retain：MRC中使用，作用同 strong 相同。 6.weak和strong关键字内部做了什么？7.除了NSString什么情况下用copy？block为什么要复制到堆中？ 带有可变类型的对象，比如 NSArray、NSDictionary等。 因为父类指针能够指向子类对象，使用 copy 的目的是让本对象的属性不受外界影响，使用 copy 后无论传入的是可变还是不可变的对象，==本身持有的就是一个不可变对象==。 当用 strong 时，该属性可能指向一个可变对象，如果这个对象在外部被修改了，那么就会修改该属性。 用作 block 的关键字。 在 ARC中，对 block 使用 strong 和 copy 效果一样，ARC 中会自动将栈上的 block 拷贝到堆中。这里使用 copy 关键字是为了提醒我们这里的 block 被复制到了堆中。 扩展：block 为什么要复制到堆中？ 将栈中的 block 复制到堆上，这样即使 block 语法记述的变量作用域结束，堆上的 block 还可以继续存在。 当 block 从栈复制到堆时，block 中使用的 __block 变量也全部从栈复制到堆中，此时 blcok 持有 __block 变量。如果堆上的 block 被废弃，那么它使用的 __block 变量也就被释放。 8.调用静态方法（类方法）时需要release么？静态方法（类方法）创建的对象自动加入了自动释放池中，所以不需要release。 9. autorelease，AutoreleasePool的原理是什么？autoreleasepool 以==队列数组的形式==实现，主要通过3个函数完成： 1.objc_autoreleasePoolPush 创建 autoreleasepool，相当于NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]。 2.objc_autoreleasePoolPop 倾倒 autoreleasepool，相当于 [pool drain]。 3.objc_autorelease 将对象加入 pool 中。 扩展：如果 autorelease NSAutoreleasePool对象会如何？ 答：发生异常。无论调用哪一个对象的 autorelease 实例方法，实际上是调用 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已经被重载，因此运行时会出错。 10.autoreleasepool的drain时机 手动创建的 autoreleasepool（指定的autoreleasepool）：当作用域大括号结束时释放。 系统创建的 autoreleasepool（不指定autoreleasepool）：autorelease 对象出作用域后，被添加到==最近一次创建的== autoreleasepool 中，==在当前 runloop 结束时释放==。 当 runloop 检测到事件并启动后，会自动创建一个 autoreleasepool 。 所有延迟释放的对象都被添加到这个 autoreleasepool 中。 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。 当 runloop 即将结束时，倾倒 autoreleasepool ，向其中所有的对象发送 release 消息后，autoreleasepool 被销毁。 11.autoreleasepool的作用ARC中，不允许使用 autorelease 方法，每个 runloop 循环中系统都自动加入了autoreleasepool 的创建和释放 但是，==在需要创建和销毁大量对象时（大数的 for 循环中创建和销毁对象），使用手动创建的 autoreleasepool 可以避免内存峰值的出现==。如果不手动创建，被加入系统创建的 autoreleasepool 中的对象在 runloop 结束时才会被统一执行 release 操作，如果在 for 循环内部创建 autoreleasepool，那么每循环一次都会执行 release 操作。 12345678for (int i &#x3D; 0; i &lt; 100000000; i++)&#123; @autoreleasepool &#123; NSString* string &#x3D; @&quot;ab c&quot;; NSArray* array &#x3D; [string componentsSeparatedByString:string]; &#125;&#125; 12.iOS中堆栈的理解？ 堆栈的区别 堆空间的内存是动态分配的，一般存放对象，需要手动释放。 栈空间的内存是系统自动分配的，一般存放局部变量等，系统自动回收。 13.weak在对象销毁时使指向对象的指针置nil的原理？ 使用哈希表（散列表实现） key：对象的内存地址。 value：被__weak修饰的变量的地址。 当对象被废弃时发生： 从weak表中获取被废弃对象的地址为key的记录。（获取记录） 将包含在记录中所有被__weak修饰的变量的地址，赋值为nil。(赋值为nil) 从weak表中删除记录。(删除记录) 从引用技术表中删除被废弃对象的地址为键值的记录。 14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？会发生。 在block代码块之前使用__weak typeof(self) weakSelf = self;，打破闭环。 二、多线程1.对多线程的理解？进程：CPU分配资源和调度的最小单位 线程：CPU执行任务的最小单位 2.iOS中实现多线程的方式有哪些？3.GCD和NSOperation优缺点？ GCD是纯C语言的 API，NSOperation 是基于 GCD 的面向对象的封装。 NSOperation 可以轻松在 operation 间设置依赖，设置它们的优先级，任务能够被方便地暂停、恢复，可以自定义子类。可以将 KVO 应用在 NSOperation 中，监听一个 operation 是否完成、取消、正在执行。可以设置最大并发数。 GCD 以 block 为单位，代码简洁，更为轻量化。对于一次性运算，或是仅仅为了加快现有方法的运算速度，选择轻量化的 GCD 更为方便。 4.死锁发生的原因是什么？如何避免？12345@autorelease &#123; dispatch_sync(dispatch_get_main_queue(), ^(void)&#123; NSLog(@&quot;发生死锁&quot;)； &#125;)；&#125; 同步函数，会把 block 加入指定队列中，会一直等待 block 执行完成才返回。因此在 block 执行完之前，调用同步函数的线程是阻塞的。 异步函数，会把 block 加入指定队列中，不会等待 block 执行，会立即返回。只负责向队列中添加任务。 串行队列：按照任务的添加顺序执行任务。并且保证在执行某个任务时，它前面进入队列的任务都执行完了。 并发队列：按照任务的添加顺序 开始 执行任务。任务执行的结束时间不确定，取决于每个任务的耗时。 原因：主线程是串行的，在执行同步函数时被阻塞，同步函数要求 block 块执行完毕后才返回，这样主线程才能继续向下执行；由于在主线程中，执行 block 块要求同步函数执行完毕才进行，这样就造成了双方的互相等待，导致了死锁的发生。 导致死锁的原因一定是：在某个串行队列中，同步地向这个队列添加任务。(在串行队列中，同步函数向相同串行队列中添加任务) 注意：发生死锁要具体分析同步函数所在的队列是并发队列还是串行队列，并且 block 要添加到哪种队列。 如果使用异步函数添加任务，无论任务是否添加到串行队列都不会发生死锁，因为异步函数不会阻塞线程。 只在解决数据竞争问题时使用串行队列。 使用同步函数 + 串行队列的组合不一定会发生死锁。同步函数所在的串行队列和要添加任务的队列不同时，不会发生死锁。 5.iOS中有哪些锁？锁：一段代码在一段时间内只能被一个线程访问。 NSLock NSCondition 条件锁 NSConditionLock 条件锁 NSRecursiveLock 递归锁 6.iOS中线程安全有哪些情况？死锁，数据竞争，优先级反转 7.多线程操作对同一块资源发生数据竞争时能怎样做？ 互斥锁 @synchronized 优点：不需要在代码中显式地创建锁对象，就能实现锁的机制。 缺点：消耗大量CPU资源。 串行队列：一个串行队列就会开一条子线程，多个串行队列并发执行，可以用dispath_set_target_queue设置执行阶层。将不同的串行队列设置到新的串行队列中串行执行。 栅栏函数：使用并发队列和栅栏函数能实现高效的数据库访问和文件访问。 信号量：当信号量为1时可以当做锁使用。控制同时访问特定资源的线程数量。优势在于等待时不会消耗CPU资源。 dispatch_semaphore_create(long value) 创建信号量，括号中的数字表示能允许同时操作的线程数量。 dispatch_semaphore_wait(dispatch_semaphore_t _Nonnull dsema, dispatch_time_t timeout) 第一个参数：信号量 第二个参数：阻塞时间。表示如果信号量为0时阻塞线程的时间。DISPATCH_TIME_FOREVER 表示永久阻塞。 当信号量 = 0 时，函数返回1，表示需要等待，不允许操作。 当信号量 &gt;= 1是，函数返回0，表示不需要等待，继续执行操作。并把信号量 - 1 dispatch_semaphore_signal(dispatch_semaphore_t _Nonnull dsema) 执行完操作后调用，将信号量 + 1。 NSMutableArray *array = [[NSMutableArray alloc] init]; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i = 0; i &lt; 100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 信号量是0时等待，非0时，经过dispatch_semaphore_wait函数后信号量-1，其他线程等待 [array addObject:[NSNumber numberWithInteger:i]]; NSLog(@&quot;%d---%ld---%@&quot;, i, array.count, [NSThread currentThread]); dispatch_semaphore_signal(semaphore); // 信号量+1 &#125;); &#125; 1234567891011121314151617181920212223- NSLock - 通过 &#96;- (void)lock &#96;和 &#96;- (void)unlock &#96;配对使用实现代码的锁定，只能执行被锁定的代码。需要使用相同的锁对象才能实现互斥。 &#96;&#96;&#96;objective-c &#x2F;&#x2F; 实例类person Person *person &#x3D; [[Person alloc] init]; &#x2F;&#x2F; 创建锁 NSLock *myLock &#x3D; [[NSLock alloc] init]; &#x2F;&#x2F; 线程A dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; &#x2F;&#x2F; 锁定 [person personA]; [NSThread sleepForTimeInterval:5]; [myLock unlock]; &#x2F;&#x2F; 解锁 &#125;); &#x2F;&#x2F; 线程B dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; &#x2F;&#x2F; 锁定 [person personB]; [myLock unlock]; &#x2F;&#x2F; 解锁 &#125;); - (BOOL)tryLock：尝试锁定，如果加锁失败（已经被锁定）返回NO，不会阻塞线程。如果成功，同 -lock效果一样，用 -unlock 解锁。 - (BOOL)lockBeforeDate:(NSDate *)limit：在date时间之前尝试锁定，如果在date时间内都不能完成锁定，返回NO。如果成功，同 -lock效果一样，用 -unlock 解锁。 NSCondition：最基本的条件锁，手动控制线程 wait（等待）和 signal （继续） [condition lock] 锁定代码，其他线程的命令需要在lock 外等待，只到unlock ，才可访问。 [condition unlock 与lock 同时使用。 [condition wait] 让当前线程处于等待状态。 [condition signal] CPU发信号告诉线程不用在等待，可以继续执行。 123456789101112131415161718192021222324252627NSCondition *condition &#x3D; [[NSCondition alloc] init];NSMutableArray *products &#x3D; [NSMutableArray array];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; if ([products count] &#x3D;&#x3D; 0) &#123; NSLog(@&quot;wait for product&quot;); [condition wait]; &#x2F;&#x2F; 线程等待 &#125; [products removeObjectAtIndex:0]; NSLog(@&quot;custome a product&quot;); [condition unlock]; &#x2F;&#x2F; 解锁 &#125;&#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;produce a product,总量:%zi&quot;,products.count); [condition signal]; &#x2F;&#x2F; 恢复线程 [condition unlock]; &#x2F;&#x2F; 解锁 sleep(1); &#125;&#125;); ​ NSConditionLock：条件锁，可以设置加锁/解锁条件，只有满足条件时才能加锁/解锁。 - (void)lockWhenCondition:(NSInteger)condition 满足条件时才能加锁。 - (void)unlockWithCondition:(NSInteger)condition 满足条件时才能解锁。 - (BOOL)tryLockWhenCondition:(NSInteger)condition 满足条件尝试加锁。 - (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit 满足条件在limit时间内尝试加锁。 同时 NSLock 的相关方法依旧能够使用，可以使用 - lock 和 - unlock 方法加锁或解锁。 1234567891011121314151617181920212223NSMutableArray *products &#x3D; [NSMutableArray array];NSInteger HAS_DATA &#x3D; 1;NSInteger NO_DATA &#x3D; 0;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [lock lockWhenCondition:NO_DATA]; &#x2F;&#x2F; 满足条件加锁 [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;produce a product,总量:%zi&quot;,products.count); [lock unlockWithCondition:HAS_DATA]; &#x2F;&#x2F; 满足条件解锁 sleep(1); &#125;&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; NSLog(@&quot;wait for product&quot;); [lock lockWhenCondition:HAS_DATA]; &#x2F;&#x2F; 满足条件加锁 [products removeObjectAtIndex:0]; NSLog(@&quot;custome a product&quot;); [lock unlockWithCondition:NO_DATA]; &#x2F;&#x2F; 满足条件解锁 &#125;&#125;); NSRecursiveLock：递归锁，这个锁可以被同一线程多次使用，而不会引起死锁。主要用在循环及递归操作中。递归锁会跟踪它被 lock 的次数。每次成功的 lock 都必须平衡调用 unlock 操作。只有这样锁才会被最终释放。 123456789101112131415161718&#x2F;&#x2F;NSLock *lock &#x3D; [[NSLock alloc] init];NSRecursiveLock *lock &#x3D; [[NSRecursiveLock alloc] init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveMethod)(int); RecursiveMethod &#x3D; ^(int value) &#123; [lock lock]; if (value &gt; 0) &#123; NSLog(@&quot;value &#x3D; %d&quot;, value); sleep(1); RecursiveMethod(value - 1); &#x2F;&#x2F; 递归调用 &#125; [lock unlock]; &#125;; RecursiveMethod(5);&#125;); 在这里如果把锁对象换为 NSLock 类型的话，从第二次递归调用开始会发生死锁。因为每次进入 block 都会加一把锁，从第二次开始因为已经加了锁并且没有解锁， 所以要等待解锁，造成了死锁，造成线程阻塞而 crash。如果换成 NSRecursiveLock 类就不会造成死锁。 8.atomic实现原理atomic为原子属性，为setter方法加互斥锁 123456@property(atomic, assign)int age;- (void)setAge:(int)age &#123; @synchronized(self)&#123; _age &#x3D; age; &#125;&#125; atomic 和 nonatomic 比较 atomic：线程安全（并非真正安全），需要消耗大量CPU资源。 例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。 nonatomic: 非线程安全，适合移动设备。 9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？dispatch_sync() 向当前线程中添加一个任务到指定队列 如果指定队列同调用dispatch_sync() 的队列是同一个串行队列。串行队列中的任务是上一个任务执行完毕才会执行下一个任务。dispatch_sync()会将Block任务添加到队列尾部，等队列中所有任务执行完毕后才会执行；dispatch_sync() 需要Block任务执行完毕才会返回，造成互相等待。 在追加Block执行结束之前，dispach_sync 会一直等待，等待意味着线程停止。 如果指定队列同调用dispatch_sync() 的队列不是同一个队列。系统会在当前线程中新开一条指定队列，并加入Block任务到新开队列中，Block任务被执行并返回，然后dispatch_sync() 返回。指定队列无论是串行和并行的，在dispatch_sync() 所在队列中串行执行任务，因为dispatch_sync() 是阻塞的。 dispatch_async() 新开线程执行任务，不等Block执行完毕就返回。 10.为什么使用atomic关键字的对象不一定是线程安全的？使用atomic只能保证 setter 方法和 getter 方法是线程安全的。但是仍然可能出现线程不安全的情况： @property(atomic, strong)NSMutableArray *array一个线程循环读数据，另一个线程循环存数据，这时就不是线程安全的，因为跟 setter 和 getter 方法没有关系。比如使用[array addObject:object]向数组中添加对象，因为不涉及到 setter 和 getter 方法，故不是线程安全的。 多线程数据为什么不安全？ 每条线程都有自己独立的栈空间，但是它们公用堆空间，所以可能同时访问同一块内存空间，因此造成数据竞争。 三、UI1.UITableView优化 使用 UITableViewCell 重用机制。 利用 RunLoop 空闲时间执行预缓存任务。 利用 RunLoopObserver 观察当前 RunLoop 的运行状态，并在状态切换时收到通知。 在 RunLoop 即将进入睡眠时使用。 将预缓存任务分解到多个 RunLoop 中执行。 2.UITableViewCell重用机制的原因和原理是什么？ 关键： ==可变数组NSMutableArray *visiableCells 保存屏幕正在显示的cell。== ==可变字典NSMutableDictionary *reusableTableCells 保存可重复利用的cell, key是重用标识identifier。== ==[tableView dequeueReusableCellWithIdentifier:identifier] 从reusableTableCells中根据identifier取可被重用的cell。== 原因：设备内存有限，TableView中有许多cell，而屏幕只能显示有限个cell，如果根据数据将cell全部创建完毕，会造成很大的内存负担。屏幕外的cell不需要立即创建，当滑动屏幕浏览cell时再加载。 作用：只创建了屏幕可显示的最大cell数+1个cell，然后循环使用这些cell，同时改变cell显示的数据，达到节省空间的目的。 原理： 第一次执行-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 方式时，reusableTableCells为空，[tableView dequeueReusableCellWithIdentifier:idertifier forIdentifiter:identifiter] 方法的返回值为nil。 此时通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifier:identifier] 创建新的cell。 当数据很多，整个屏幕的cell显示不完全时 调用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifiter:identifier] 创建整个屏幕能显示的cell个数+1个cell（滑动屏幕时，第一个cell还没移出，最后一个cell已经出现），并且制定标识符identifier。 将创建并显示除最后一个外的cell加入visiableCells 数组，此时reusableTableCells字典为空。 滑动屏幕时，顶端的cell移出屏幕，该cell从visiableCells 数组中移除，并加入到reusableTableCells 字典中，key为该cell的identifier。将最后一个cell加入到visiableCells 数组中。 继续滑动时，reusableTableCells 中已经有值。需要显示新的cell时，cellForRowAtIndexPath 再次被调用，执行[tableView dequeueReusableCellWithIdentifier:identifier] 方法，返回一个标识为identifier的cell。该cell从reusableTableCells 中移除，添加到visableCells 中，如果resuableTableCells 中没有identifier类型的cell，就会创建一个；同时，移出屏幕的cell从visiableCells 中移除，添加到resuableTableCells 中。 iOS6中新方法 [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier] 当从reusableTableCells 中取cell时，如果没有，系统会自动创建给定类型的cell；如果有，直接重用。 在cellForRowAtIndexPath 中只需要 12345- (UITableViewCell *)table:(UITableView *)tableView cellForRowAtIdexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 系统会自动判断cell是否存在，不需要手动判断。 UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifiter:identifiter forIndexPath:indexPath]; return cell;&#125; 3.怎样裁剪圆头像4.自定义控件的封装5.viewController生命周期 viewWillAppear 之后，viewDidAppear 之前会调用 viewWillLayoutSubviews 和viewDidLayoutSubviews ，可以修改subviews。 -loadView 中初始化view, 由系统调用，==在 viewController 的 view 被访问并且为nil时调用==（self.view = …），可能被调用多次。 6.改变UIButton的点击面积重写UIButton的-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event方法。 该方法返回BOOL值表示判断当前的点击或触摸事件是否在当前的UIView中。 123456789@inplementation NewButton-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; CGRect bounds &#x3D; self.bounds; bounds &#x3D; CGRectInset(bounds, -50, -50); &#x2F;&#x2F; 该按钮上下左右范围各扩大了50. return CGRectContainsPoint(bounds, point);&#125;@end bounds = CGRectInset(bounds, -50, -50) 后两个参数是在左右方向和上下方向扩大或缩小的长度，正值表示缩小，负值表示扩大。该行代码表示在水平和竖直方向各扩大了100。 苹果要求：点击的热点区域不小于44*44 pt。 7.UIView、UIButton 、UITableView的继承关系?UIView -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView - &gt; UIResponder -&gt; NSObject UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject 四、设计模式1.KVO的原理？KVO的实现依赖于Runtime，使用isa混写（isa-swizzling）实现。当观察对象A时，KVO机制动态的创建对象A当前类的子类，并为这个新类重写了被观察属性的setter方法，在setter方法中通知观察对象属性的改变情况。将对象A的isa指针的指向修改为创建的新类。 具体实现 当观察对象A时，KVO机制动态地创建一个名为NSKVONotifying_A的新类，该类继承自对象A原来的类，并重写了被观察属性值的setter方法。重写的setter方法负责在调用原setter方法之前和之后，通知所有观察对象：属性值得更改。最后通过isa混写（isa-swizzling）把这个对象的isa指针指向新创建的子类，对象变成了新创建子类的实例。 setter方法剖析： KVO依赖于两个方法-willChangeValueForKey:和-didChangeValueForKey:，在原setter方法之前和之后分别调用。重写setter方法的注入是在运行时而不是在编译时。 -willChangeValueForKey:在属性值发生改变之前即原setter方法之前调用，通知keyPath属性值即将发生改变。 -didChangeValueForKey:在属性值发生改变之后即原setter方法之后调用，通知keyPath属性值已经发生改变。 之后-observerValueForKeyPath:ofObject:change:context也会被调用 - (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; [super setValue:newName forKey:@&quot;name&quot;]; // 调用父类的存取方法,KVC实现 [self didChangeValueForKey:@&quot;name&quot;]; &#125; 12345678910111213141516171819- 使用前提 KVO被观察的是对象属性，只有__通过setter方法__或__KVC方法__修改对象属性时KVO才能被触发，使用KVO机制的__*前提是遵循KVO的属性设置方式来变更属性值*__。#### 2.手写KVO观察对象过程：1. 为__观察的对象__注册观察者 &#96;&#96;&#96;objective-c &#x2F;* 第一个参数：观察者，负责处理监听事件的对象 第二个参数：被观察的属性 第三个参数：被观察属性新旧值得一些配置 第四个参数：上下文，可以为KVO回调方法传值 *&#x2F; [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; 被观察的属性发生变化时，收到通知，调用方法： 12345678910&#x2F;* 第一个参数：被观察的属性 第二个参数：被观察的对象 第三个参数：改变的属性值，前后的变化都存在字典中 第四个参数：上下文，context传递的值 *&#x2F;- (void)observeValueForKeyPath:(NSString *)keyPath object:(id)object change:(NSDictionary *)change context:(void *)context &#123; if([keyPath isEqualToString:@&quot;name&quot;] &amp;&amp; object &#x3D;&#x3D; self.person) &#123; &#x2F;&#x2F; 响应变化处理 NSLog(@&quot;new:%@, old:%@&quot;, [change valueForkey:@&quot;old&quot;], [change valueForKey:@&quot;new&quot;]); &#125;&#125; 在-dealloc方法中注销观察者 123- (void)dealloc&#123; [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:nil];&#125; 3. 怎样手动触发KVO？​ 手动调用-willChangeValueForKey:和-didChangeValueForKey: ​ 场景：希望能控制”回调的调用时机时“（控制-didiChangeValueForKey调用） 4.KVC中setValue: forKeyPath: 复制过程？ 调用 setter 方法。 如果没有对应的 setter 方法，判断是否有与 key 值同名的成员属性，如果有，直接赋值。 如果没有与 key 值同名的成员属性，判断是否有与 key 值同名带下划线的成员属性，如果有，直接赋值。 报错：找不到对应的成员属性。 5.对MVC的理解？6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate） delegate：一对一 优点： 语法严谨，所有收听到的事件都必须有清楚的定义。 delegate协议中的方法如果没有实现编译器会报错。 每个controller可以遵守多个协议，每个协议有不同的delegate。 能够接收调用协议的协议方法的返回值。delegate可以返回信息给controller。 没有第三方对象要求保持/监视通信过程。 缺点： 需要定义的代码多：协议的定义，controller的delegate属性，在delegate本身中实现delegate方法的定义。 释放代理对象的时候，需要将delegate改为nil，否则调用对象的方法会crash。 block： 优点 代码量比delegate少，更轻型，使用方便。 缺点： 需要注意循环引用的问题。 有多个方法时，假如每个方法设置一个block会更麻烦。 Notifaction：一对多 优点： 需要写的代码少。 一对多实现简单。 controller能传递context对象（NSDictionary），context对象携带了发送通知的自定义信息。 缺点： 编译期不会检查通知是否能被被观察者正确的处理。 释放注册的对象时，需要在通知中心取消注册。 需要第三方管理controller和观察者的关系。 通知发出后，发出通知的对象不能从观察者获得任何反馈。 KVO：可以一对多 优点： 能够提供观察的属性的新值和旧值。 通过keyPath观察属性，因此也可以嵌套对象。 能够对非我们创建的对象，即内部对象的状态改变做出相应，而且不需要改变内部对象的实现。 不需要额外的代码允许观察值能够被观察。 缺点： 被观察的属性必须用string定义，编译器不会对其进行检查，可能写错。 对属性的重构导致代码不可用。 所有的观察代码通过一个方法来指向，导致方法中复杂的if语句。 释放观察者时需要移除观察者。 五、网络请求1.NSURLSession和NSURLConnection区别？NSURLConnection从iOS 9废弃，NSURLSession在WWDC2013发布。 普通任务和上传 NSURLSession 针对普通会话、上传、下载有三种不同的任务NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownnloadTask。创建的会话都是挂起状态，需要resume才能启动。 当服务器返回的数据较小时，NSURLSession和NSURLConnection执行普通任务的操作没有区别。 执行上传任务时，NSURLSession和NSURLConnection一样需要设置POST请求的请求体进行上传。 请求方法的不同 NSURLConnection实例化对象， 通过-initWithRequest: delegate:创建的请求被自动发送 通过-initWithRequest: delegate: startImmediately:NO创建的请求通过[connect start]发送请求，方法内部把connect对象作为一个source添加到当前线程的runloop的默认模式下执行。(如果runloop不存在会自动创建当前线程对应的runloop) NSURLSession可以cancel(取消)、suspend(暂停)、resume(恢复)会话，暂停以后可以恢复继续请求。 下载任务的方式不同 NSURLConnection下载文件时，先将文件下载到内存，再写入沙盒，如果文件比较大，会出现内存暴涨的情况。 NSURLSessionDownloadTask 下载文件，默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况。但是下载完成后会把tem中的临时文件删除，需要在completionHandler回调方法中将下载的文件移动到别的文件夹。 在代理方法中，能够方便地监听文件的下载进度。 断点续传方式不同（NSURLSession更加方便） NSURLConnection实现断点续传需要通过设置请求头的HTTPHeaderField的range属性进行。 NSURLSessionDownloadTask进行断点续传 当Task暂停时，如果downloadTask非空，调用-cancelByProducingResumeData:(void(^)(NSData *resumeData))completionHandler接收resumeData参数，保存已下载文件。(注意block中的循环引用，定义self的属性_resumeData, weakSelf.resumeData = resumeData) 再次下载是，如果self.resumeData != nil那么调用[[self.session downloadTaskWithResumeData:self.resumeData] rusume]继续下载，否则创建会话和下载任务。 NSURLSession可以设置配置信息Configuration。 +(NSURLSession *)sessionWithConfiguration: delegate: delegateQueue: 可以设置缓存策略，是否在后台进行请求，最大主机连接数，网络超时等。 2.AFN框架为什么封装NSURLSession？六、底层相关1.iOS程序的加载过程是什么？ 执行 main 函数。 执行 UIApplicationMain 函数。 创建 UIApplication 对象（是单例的）。 创建 UIApplication 的代理，并且设置 application 的代理。 开启 主RunLoop。 加载完毕后调用 - application: didFinishLaunchingWithOptions:。 2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？ - application: didFinishLaunchingWithOptions: 应用被加载完毕后被调用 - applicationWillResignActive: 当应用即将变为不活动状态时调用，比如电话进入、退出应用程序或开始进入后台状态。 - applicationDidEnterBackground: 当应用进入后台状态后调用。在后台状态中应用工作，但是不派发新的事件到响应器。 - applicationWillEnterForeground 应用将要回到前台时调用。 - applicationDidBecomeActive: 应用已经变为活动状态时调用。 - applicationWillTerminate: 应用即将结束时调用。 - applicationDidReceiveMemoryWarning: 收到内存警告时调用。 3.+load 方法和 +initialize 方法异同 相同： 都在实例化对象==之前==调用。 内部都使用了锁，应该避免线程阻塞在方法中。 +load 方法 +load 方法在这个==文件被程序加载时==调用，程序启动时会调用所有类的+load 方法。与类的使用与否无关。 +load 方法在main函数之==前==调用。 先调用父类的 +load 方法，再调用子类的 +load 方法。自动完成。 如果一个子类没有实现 +load 方法，那么也就不会调用父类的+load 方法。 使用场景：在+load方法中实现 Method swizzle。 +initialize 方法 当第一次给一个类发送消息时，它的+initiallze方法会被调用。只会调用一次。 如果一个类一直没有被使用，它的+initialize方法不会被调用。 在main函数之==后==被调用。 先调用父类的+initialize方法，再调用子类的+initialize方法。 如果子类没有实现+initialize方法没有被实现，父类的+initialize方法也会被调用。 使用场景：初始化全局变量或静态变量。 4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？ _objc_msgForward是 IMP 类型(一个函数指针)，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 IMP: 指向方法实现开头的指针。 我们可以这样创建一个_objc_msgForward对象： 1IMP msgForwardIMP &#x3D; _objc_msgForward; objc_msgSend在“消息传递”中的作用： 在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。 消息转发过程： 调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。 调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。 最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。 _objc_msgForward在进行消息转发的过程中会涉及以下这几个方法： resolveInstanceMethod:方法 (或 resolveClassMethod:)。 forwardingTargetForSelector:方法 methodSignatureForSelector:方法 forwardInvocation:方法 doesNotRecognizeSelector: 方法 直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。 一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”， 如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend： “我没有在这个对象里找到这个方法的实现” 有哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。 5.__block为什么能够 block 在内部修改 blcok 外部变量？ 我们都知道：Block不允许修改外部变量的值，这里所说的==外部变量的值，指的是栈中指针的内存地址。==__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址 变量在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。 网络1.访问域名和访问IP地址的区别？ IP地址是服务器的物理地址，一台服务器可能对应多个网站，访问IP地址可能不知道要访问哪个。 一个域名可能对应多个IP地址，通过域名访问自动选择速度最快的建立连接。 2.访问www.xxx.com的过程？ 首先找本机的HOSTS文件，映射为IP地址或客户端向 DNS 服务器请求解析该 URL 中域名对应的 IP 地址。(域名解析) 根据 IP 地址和端口，客户端同服务器建立连接。(建立连接) 客户端向服务器发送请求。(发送请求) 该请求报文作为 TCP 三次握手第三个报文的数据发送给服务器。 服务器对请求做出响应，并把对应的数据发送给客户端。(作出相应) 释放 TCP 连接。(释放连接) 客户端对响应数据进行解析、处理。(解析数据) 3.GET和POST请求的区别？POST一定安全么？ 请求形式 GET 请求：请求的数据附在 URL 之后（数据在请求头中）。以？分割URL和传输数据，多个参数用&amp;相连。 POST 请求：请求的数据封装在请求体中。 安全性 GET 请求：请求的数据在地址栏中显示。 POST 请求：请求的数据虽然在请求体中，但也不安全，需要加密。 传输数据的大小 GET 请求：传输数据受URL长度限制，特定浏览器和服务器对URL的长度有限制。 POST 请求：理论上不受限制，实际服务器会对 POST 请求提交的数据大小进行限制。 获取变量值的方式 GET 请求：Request QueryString POST 请求：Request Form 4.HTTPS安全协议请求过程(HTTPS握手)是什么？ 涉及密钥： 对称加密密钥A 。 用于加密密钥A的非对称密钥B。公钥发送给客户端，私钥服务器持有。 用于加密密钥B公钥的CA证书密钥C。公钥保存在浏览器或系统中，私钥服务器持有。 请求过程(HTTPS握手)： 客户端发送HTTPS请求，请求对称加密公钥B。 服务器响应客户端请求，发送CA数字证书。 证书中包括：密钥B的公钥，域名，服务器信息，数字签名，数字摘要算法等信息。 客户端验证CA数字证书的正确性。 验证域名的正确性，比较CA证书中的域名和请求域名，可以验证证书是否是服务器发送的。 验证CA证书中数字签名，可以验证CA证书是否被第三方篡改。 客户端用CA证书的公钥对密文解密，得到密钥B的公钥。 客户端生成密钥A，用密钥B的公钥进行加密，发送给服务器。 服务器用密钥B的私钥对密文进行解密，得到密钥A。 安全连接建立完成，双方用密钥A对信息进行对称加密传输。 HTTPS加密在传输层 HTTPS报文在包装成TCP报文的时候完成加密过程，报文的header和body都会被加密。 5.HTTPS作用？ 内容加密：建立一个信息安全通道，来保证数据传输的安全。 身份认证：认证用户或服务器，确保数据发送到正确的客户或服务器。 数据完整性：防止内容被第三方冒充或篡改。（原因：数字摘要） 6.HTTP和HTTPS区别？ HTTPS需要到CA申请证书或自制证书。 HTTP直接进行明文传输。 HTTPS先经过具有安全性的SSL/TSL（表示层）加密，再传输密文。 HTTP端口：80。 HTTPS端口：443。 7.数字证书作用？ 确定得到公钥的正确性 确定目标主机的正确性 ​ 数字证书包括： 用户个人信息、公钥信息、颁发机构名称、证书本身的数字签名、证书数字签名用的HASH算法。 8.数字签名 数字签名 = 非对称加密 + 数字摘要 数字签名验证数据完整性过程： 将摘要信息用发送者私钥加密后，与原文一起传送给接受者。(摘要+原文) 接受者用发送者的公钥将被加密的摘要解密。(解密) 接受者用与发送者相同的HASH算法对接收到的明文产生一个摘要信息。(产生摘要) 将产生的摘要与解密得到的摘要进行对比，如果相同，则数据没有被修改。(比较摘要) 9.请求报文包括哪些？请求体和请求报文的关系？请求报文包括：请求行、请求头、空行、请求体。 请求报文包括请求体。 响应报文包括：状态行、响应头、空行，响应体。 10.UDP和TCP的区别？ TCP：面向连接，三次握手最低限度保证连接可靠性 UDP：无连接，传送数据前无需建立连接，数据到达后也无需确认。（发送端不知道数据是否到达接收端，也不知道数据是否被正确接受） TCP：可靠交付。 UDP：不可靠交付。 TCP：报文头部长，传输开销大 UDP：报文头部短，传输开销小，时延较短，实用性更好。 11.TCP三次握手和四次挥手过程 三次握手 四次挥手 C语言1.strstr函数是什么？2.free() 函数做了什么？3.strcpy和strnpy函数的区别？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"iOS面试","slug":"iOS面试","permalink":"http://fangliquan.github.io/tags/iOS%E9%9D%A2%E8%AF%95/"}]},{"title":"swift3.0_协议(Protocal)和扩展(Extension)","slug":"swift3-0-Protocol-And-Eextension","date":"2017-03-20T10:13:44.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-20/swift3-0-Protocol-And-Eextension/","link":"","permalink":"http://fangliquan.github.io/2017-03-20/swift3-0-Protocol-And-Eextension/","excerpt":"协议(Protocal使用protocol 来声明一个协议。 ExampleProtocal&#123; var simpleDesp:String&#123;get&#125; mutating func adjust()&#125;","text":"协议(Protocal使用protocol 来声明一个协议。 ExampleProtocal&#123; var simpleDesp:String&#123;get&#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议。class SimpleClass: ExampleProtocal&#123; var simpleDesp: String &#x3D; &quot;A simple class&quot; var anotherProperty:Int &#x3D; 45621 func adjust() &#123; simpleDesp +&#x3D; &quot; NO 100% adjusted&quot; &#125;&#125; 注意声明SimpleStructure 时候mutating 关键字用来标记一个会修改结构体的方法。SimpleClass 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。使用extension来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。var simple &#x3D; SimpleClass()simple.adjust()let aDesp &#x3D; simple.simpleDespstruct SimpleStructure:ExampleProtocal&#123; var simpleDesp: String &#x3D; &quot;A simple structure&quot; mutating func adjust() &#123; simpleDesp +&#x3D; &quot;(adjusted)&quot; &#125;&#125;var b &#x3D; SimpleStructure()b.adjust()let bDesp &#x3D; b.simpleDespextension Int:ExampleProtocal &#123; var simpleDesp :String &#123; return &quot;The number\\(self)&quot; &#125; mutating func adjust() &#123; self +&#x3D; 42 &#125;&#125;print(7.simpleDesp) 你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。let protocolValue : ExampleProtocal &#x3D; simpleprint(protocolValue.simpleDesp)&#x2F;&#x2F;print(protocolValue.anotherProperty) &#x2F;&#x2F; 去掉注释可以看到错误 即使protocolValue 变量运行时的类型是simpleClass ，编译器会把它的类型当做ExampleProtocol 。这表示你不能调用类在它实现的协议之外实现的方法或者属性。","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_类和对象","slug":"swift3-0-Class-And-Object-study","date":"2017-03-19T11:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-Class-And-Object-study/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-Class-And-Object-study/","excerpt":"类和对象和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。","text":"类和对象和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。 class Shape&#123; var numberOfSize &#x3D; 0 func simpleDescription() -&gt; String &#123; return&quot;A shape with \\(numberOfSize) sides.&quot; &#125; func simpleDescription(str:String) -&gt; String &#123; return&quot;A shape with \\(numberOfSize) sides.&quot; &#125;&#125; 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。var shape &#x3D; Shape()shape.numberOfSize &#x3D; 7var shapeDescription &#x3D; shape.simpleDescription()class NameShape&#123; var numberOfSides:Int &#x3D; 0 var name:String init(name:String) &#123; self.name &#x3D; name; &#125; func simpleDescription() -&gt; String &#123; return&quot;A shape with \\(numberOfSides)&quot; &#125;&#125; 注意self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides ）还是通过构造器（就像name ）。 如果你需要在删除对象之前进行一些清理工作，使用deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。子类如果要重写父类的方法的话，需要用override 标记——如果没有添加override 就重写父类方法的话编译器会报错。编译器同样会检测override 标记的方法是否确实在父类中class Square:NameShape&#123; var sideLength:Double &#x3D; 0.0; init(sideLength:Double,name:String) &#123; super.init(name: name) self.sideLength &#x3D; sideLength numberOfSides &#x3D; 4 &#125; func area() -&gt; Double &#123; return sideLength*sideLength &#125; override func simpleDescription() -&gt; String &#123; return &quot;A square with sides of length \\(sideLength)&quot; &#125;&#125;let test &#x3D; Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription() 除了储存简单的属性之外，属性可以有 getter 和 setter 。class EquilateralTriangle:NameShape&#123; var sideLength: Double &#x3D; 0.0 init(sideLength:Double,name:String) &#123; super.init(name: name) self.sideLength &#x3D; sideLength; numberOfSides &#x3D; 3 &#125; var perimeter :Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength &#x3D; newValue&#x2F;3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return &quot;an equilateral triagle with sides of length \\(sideLength).&quot; &#125;&#125;var triangle &#x3D; EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)print(triangle.perimeter)triangle.perimeter &#x3D; 9.9print(triangle.sideLength) 在perimeter 的 setter 中，新值的名字是newValue 。你可以在set 之后显式的设置一个名字。注意EquilateralTriangle 类的构造器执行了三步： 设置子类声明的属性值 调用父类的构造器 改变父类定义的属性值。其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用willSet 和didSet 。class TriangleAndSquare &#123; var triangle: EquilateralTriangle &#123; willSet &#123; square.sideLength &#x3D; newValue.sideLength &#125; &#125; var square:Square&#123; willSet&#123; triangle.sideLength &#x3D; newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square &#x3D; Square(sideLength: size, name: name) triangle &#x3D; EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare &#x3D; TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square &#x3D; Square(sideLength: 50, name: &quot;larger square&quot;)print(triangleAndSquare.triangle.sideLength) 处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加? 。如果? 之前的值是nil ， ? 后面的东西都会被忽略，并且整个表达式返回nil 。否则， ? 之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。let optionalSquare:Square? &#x3D; Square(sideLength: 2.5, name: &quot;optional Square&quot;)let sideLength &#x3D; optionalSquare?.sideLength","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_枚举(Enum)和结构体(struct)","slug":"swift3-0-Struct-and-Enum","date":"2017-03-19T09:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-Struct-and-Enum/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-Struct-and-Enum/","excerpt":"枚举和结构体使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。","text":"枚举和结构体使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。 enum Rank: Int&#123; case Ace &#x3D; 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return &quot;ace&quot; case.Jack: return &quot;jack&quot; case.Queen: return &quot;queen&quot; case.King: return &quot;king&quot; default: return String(self.rawValue) &#125; &#125;&#125;let ace &#x3D; Rank.Acelet aceRawValue &#x3D; ace.rawValuelet kingRawValue &#x3D; Rank.King.rawValuelet queenString &#x3D; Rank.simpleDescription(.Jack)print(queenString()) 默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中， Ace 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为 枚举的原始值。使用rawValue 属性来访问一个枚举成员的原始值。使用init?(rawValue:) 初始化构造器在原始值和枚举值之间进行转换。if let convertedRank &#x3D; Rank(rawValue: 3)&#123; let threeDescription &#x3D; convertedRank.simpleDescription()&#125; 枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return &quot;spades&quot; case .Hearts: return &quot;hearts&quot; case .Diamonds: return &quot;diamonds&quot; case .Clubs: return &quot;clubs&quot; &#125; &#125; func color() -&gt; String &#123; switch self &#123; case .Spades: return &quot;balck&quot; case .Hearts: return &quot;red&quot; case .Diamonds: return &quot;red&quot; case .Clubs: return &quot;black&quot; &#125; &#125;&#125;let hearts &#x3D; Suit.Heartslet heartsDescription &#x3D; hearts.simpleDescription()let heartsColor &#x3D; hearts.color()let shapeColor &#x3D; Suit.Clubs.color() 注意，有两种方式可以引用Hearts 成员：给hearts 常量赋值时，枚举成员Suit.Hearts 需要用全名来引用，因为常量没有显式指定类型。在switch 里，枚举成员使用缩写.Hearts 来引用，因为self 的值已经知道是一个suit 。已知变量类型的情况下你可以使用缩写。 一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。 例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。enum ServerResponse&#123; case Reasult(String,String) case Failure(String)&#125;let success &#x3D; ServerResponse.Reasult(&quot;6:00pm&quot;, &quot;8:09pm&quot;)let failure &#x3D; ServerResponse.Failure(&quot;Out of cheese&quot;)switch success &#123;case let .Reasult(sunrise,sunset): let serRepsonse &#x3D; &quot;Sunrise is at\\(sunrise) and sunset is at\\(sunset)&quot;case let .Failure(message): print(&quot;Failure....\\(message)&quot;)&#125; 注意日升和日落时间是如何从ServerResponse 中提取到并与switch 的case 相匹配的。 使用struct 来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。struct Card&#123; var rank :Rank var suit :Suit func sampleDesp() -&gt; String&#123; return &quot;The \\(rank.simpleDescription()) of \\(suit.simpleDescription())&quot; &#125;&#125;let threeOfSpades &#x3D; Card(rank: .Three, suit: .Spades)let threeOfSpadesDesp &#x3D; threeOfSpades.sampleDesp()let threeOfRank &#x3D; threeOfSpades.rank.hashValue","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_函数和闭包","slug":"swift3-0-func-study","date":"2017-03-19T09:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-func-study/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-func-study/","excerpt":"函数和闭包使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型func great( person:String,day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125;","text":"函数和闭包使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型func great( person:String,day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125; 默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用_表示不使用参数标签。func greaton(_ person:String,on day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125;great(person: &quot;&quot;, day: &quot;&quot;)greaton(&quot;John&quot;, on: &quot;Sunday&quot;) 使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。func calculateStatistics(scores:[Int]) -&gt;(min:Int,max:Int,sum:Int)&#123; var minInt &#x3D; scores[0] var maxInt &#x3D; scores[0] var sum &#x3D; 0 for score in scores &#123; if score&gt;maxInt &#123; maxInt &#x3D; score &#125;else if score&lt;minInt&#123; minInt &#x3D; score &#125; sum+&#x3D;score &#125; return(minInt,maxInt,sum)&#125;let statistics &#x3D; calculateStatistics(scores: [3,4,567,89,99])print(statistics.sum)print(statistics.max)print(statistics.min)print(statistics.2) 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：func sumOf(numbers:Int...)-&gt;Int&#123; var sum &#x3D; 0; for number in numbers &#123; sum+&#x3D;number &#125; return sum&#125;sumOf(numbers: 34,56,78)sumOf() 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。func returnFifteen()-&gt;Int&#123; var y &#x3D; 10 func add()&#123; y+&#x3D;10 &#125; add(); return y;&#125;returnFifteen() 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。func makeIncrementer()-&gt;((Int) -&gt;Int)&#123; func addOne(number:Int)-&gt;Int&#123; return 1+number &#125; return addOne&#125;var increment &#x3D; makeIncrementer()increment(10) 函数也可以当做参数传入另一个函数func hasAnyMatches(list:[Int],condition:(Int) -&gt;Bool)-&gt;Bool&#123; for item in list &#123; if condition(item) &#123; return true; &#125; &#125; return false;&#125;func lessThanTen(number:Int)-&gt;Bool&#123; return number&lt;10&#125;var numbers &#x3D; [20,19,6,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{} 来创建一个匿名闭包。使用in 将参数和返回值类型声明与闭包函数体进行分离。numbers.map &#123; (number :Int) -&gt; Int in let result &#x3D; 3*number; return result;&#125;print(numbers) 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。let mappedNumbers &#x3D; numbers.map(&#123;number in 3*number&#125;)print(mappedNumbers) 你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。let sortedNumbers &#x3D; numbers.sort&#123;$0&gt;$1&#125;print(sortedNumbers)","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"iOS 解决蓝牙音箱输出App播放的音频问题","slug":"IPhone-Bluetooth-speaker-output-audio","date":"2016-09-16T03:31:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-09-16/IPhone-Bluetooth-speaker-output-audio/","link":"","permalink":"http://fangliquan.github.io/2016-09-16/IPhone-Bluetooth-speaker-output-audio/","excerpt":"App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。","text":"App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。 AVAudioSession的设置 如果app需要支持蓝牙外设输出及耳机 的控制需要添加 对OverrideAudioRoute OverrideCategoryEnableBluetoothInput的支持 同时还要设置AVAudioSession的Category为AVAudioSessionCategoryPlayback. AVAudioSession * session = [AVAudioSession sharedInstance];[session setCategory:AVAudioSessionCategoryPlayback error:nil];[session setActive:YES error:nil];UInt32 audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;AudioSessionSetProperty (kAudioSessionProperty_OverrideAudioRoute, sizeof (audioRouteOverride), &amp;audioRouteOverride);//kAudioSessionProperty_OverrideCategoryDefaultToSpeakerUInt32 allowBluetoothInput = 1;AudioSessionSetProperty ( kAudioSessionProperty_OverrideCategoryEnableBluetoothInput, sizeof (allowBluetoothInput), &amp;allowBluetoothInput );//[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;];[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];[[UIApplication sharedApplication] becomeFirstResponder]; 处理输出路径的变换的通知 AVAudioSessionRouteChangeNotification 的监听 注册通知后 要对监听做处理 AVAudioSession *audioSession = [AVAudioSession sharedInstance];NSInteger changeReason = [[notification.userInfo objectForKey:AVAudioSessionRouteChangeReasonKey] integerValue];AVAudioSessionRouteDescription *oldRoute = [notification.userInfo objectForKey:AVAudioSessionRouteChangePreviousRouteKey];NSString *oldOutput = [[oldRoute.outputs objectAtIndex:0] portType];AVAudioSessionRouteDescription *newRoute = [audioSession currentRoute];NSString *newOutput = [[newRoute.outputs objectAtIndex:0] portType]; 具体实现请看代码 - (void)currentRouteChanged:(NSNotification *)notification&#123; AVAudioSession *audioSession = [AVAudioSession sharedInstance]; NSInteger changeReason = [[notification.userInfo objectForKey:AVAudioSessionRouteChangeReasonKey] integerValue]; AVAudioSessionRouteDescription *oldRoute = [notification.userInfo objectForKey:AVAudioSessionRouteChangePreviousRouteKey]; NSString *oldOutput = [[oldRoute.outputs objectAtIndex:0] portType]; AVAudioSessionRouteDescription *newRoute = [audioSession currentRoute]; NSString *newOutput = [[newRoute.outputs objectAtIndex:0] portType]; NSLogDebug(@&quot;changeReason - ------------------ %d&quot;,(int)changeReason); switch (changeReason) &#123; case AVAudioSessionRouteChangeReasonOldDeviceUnavailable: &#123; if ([oldOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = NO; // Special Scenario: // when headphones are plugged in before the call and plugged out during the call // route will change to &#123;input: MicrophoneBuiltIn, output: Receiver&#125; // manually refresh session and support all devices again.// [audioSession setActive:NO error:nil];// [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionAllowBluetooth error:nil];// [audioSession setMode:AVAudioSessionModeVoiceChat error:nil];// [audioSession setActive:YES error:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [WawaAudioBookListView pauseCurrentAudio]; &#125;); &#125; else if ([self isBluetoothDevice:oldOutput]) &#123; BOOL showBluetooth = NO; // Additional checking for iOS7 devices (more accurate) // when multiple blutooth devices connected, one is no longer available does not mean no bluetooth available if ([audioSession respondsToSelector:@selector(availableInputs)]) &#123; NSArray *inputs = [audioSession availableInputs]; for (AVAudioSessionPortDescription *input in inputs)&#123; if ([self isBluetoothDevice:[input portType]])&#123; showBluetooth = YES; break; &#125; &#125; &#125; if (!showBluetooth) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; &#125; break; case AVAudioSessionRouteChangeReasonNewDeviceAvailable: &#123; if ([self isBluetoothDevice:newOutput]) &#123; self.bluetoothDeviceAvailable = YES; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = YES; &#125; &#125; break; case AVAudioSessionRouteChangeReasonCategoryChange: &#123; if ([self isBluetoothDevice:newOutput]) &#123; self.bluetoothDeviceAvailable = YES; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = YES; &#125; NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults]; [defaults setObject:@&quot;YES&quot; forKey:@&quot;WawaAVAudioSessionRouteChangeReasonCategoryChange&quot;]; &#125; break; case AVAudioSessionRouteChangeReasonOverride: &#123; if ([self isBluetoothDevice:oldOutput]) &#123; if ([audioSession respondsToSelector:@selector(availableInputs)]) &#123; BOOL showBluetooth = NO; NSArray *inputs = [audioSession availableInputs]; for (AVAudioSessionPortDescription *input in inputs)&#123; if ([self isBluetoothDevice:[input portType]])&#123; showBluetooth = YES; break; &#125; &#125; if (!showBluetooth) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortBuiltInReceiver]) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; &#125; break; default: break; &#125;&#125;- (BOOL)isBluetoothDevice:(NSString*)portType &#123; return ([portType isEqualToString:AVAudioSessionPortBluetoothA2DP] || [portType isEqualToString:AVAudioSessionPortBluetoothHFP]);&#125;- (void)start&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(currentRouteChanged:) name:AVAudioSessionRouteChangeNotification object:nil];&#125; 处理RemoteControl 音频蓝牙音箱的外设可以进行下一首 等操作 所以对RemoteControl做处理 来控制音频的播放 - (void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; switch (event.subtype) &#123; case UIEventSubtypeRemoteControlPlay: &#123; [self postNotification:kRemoteControlPlayTapped]; &#125; break; case UIEventSubtypeRemoteControlPause: [self postNotification:kRemoteControlPauseTapped]; break; case UIEventSubtypeRemoteControlNextTrack: [self postNotification:kRemoteControlNextTapped]; break; case UIEventSubtypeRemoteControlPreviousTrack: [self postNotification:kRemoteControlPreviousTapped]; break; default: break; &#125;&#125;- (void)postNotification:(const NSString *)notificationName&#123; [[NSNotificationCenter defaultCenter] postNotificationName:(NSString *)notificationName object:nil];&#125;- (void)observeRemoteControl:(id)observer selector:(SEL)selector&#123; NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlNextTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPauseTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPlayTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPreviousTapped object:nil];&#125; 处理事件 - (void)onRemoteControlNotification:(NSNotification *)notification&#123; NSLog(@&quot;changeReason - ------------------ kRemoteControlPlayTapped&quot;); //[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;]; if ([notification.name isEqualToString:kRemoteControlPlayTapped]) &#123; if (self.audioSteamSate == kFsAudioStreamRetrievingURL || self.audioSteamSate == kFsAudioStreamStopped) &#123; // 当前选中的 audio 处于准备中则播放此 url self.needResume = YES; [self playFromUrl:self.currentPlayAduio]; &#125; else &#123;// 否则暂停或者播放 if (self.audioSteamSate ==kFsAudioStreamPlaying) &#123; self.needResume = YES; &#125; //只在当前播放状态为播放时处理蓝牙设备的接入 [self.audioStream pause]; &#125; &#125; else if ([notification.name isEqualToString:kRemoteControlPauseTapped]) &#123; [self.audioStream pause]; &#125; else if ([notification.name isEqualToString:kRemoteControlNextTapped]) &#123; [self next]; &#125; else if ([notification.name isEqualToString:kRemoteControlPreviousTapped]) &#123; [self previous]; &#125;&#125;","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"AVAudioSession","slug":"AVAudioSession","permalink":"http://fangliquan.github.io/tags/AVAudioSession/"},{"name":"AudioSessionProperty","slug":"AudioSessionProperty","permalink":"http://fangliquan.github.io/tags/AudioSessionProperty/"}]},{"title":"iOS 解决支付宝SDK在没有安装支付宝时不能启动网页支付","slug":"To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment","date":"2016-08-28T03:31:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/","link":"","permalink":"http://fangliquan.github.io/2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/","excerpt":"在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。","text":"在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。 配置plist 文件配置 LSApplicationQueriesSchemes &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;alipayauth&lt;/string&gt; &lt;string&gt;alipay&lt;/string&gt; &lt;string&gt;alipayshare&lt;/string&gt; &lt;string&gt;safepay&lt;/string&gt; &lt;string&gt;aliminipayauth&lt;/string&gt; &lt;string&gt;cydia&lt;/string&gt; &lt;/array&gt;配置NSAppTransportSecurity ，添加NSExceptionDomains支持 &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;alipay.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.1&lt;/string&gt; &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpac&#123; return YES;&#125;- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123; NSArray *trustedHosts = [NSArray arrayWithObjects:@&quot;alipay&quot;,nil]; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust])&#123; if ([trustedHosts containsObject:challenge.protectionSpace.host]) &#123; [challenge.sender useCredential:[NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge]; &#125; &#125; [challenge.sender continueWithoutCredentialForAuthenticationChallenge:challenge];&#125; 我们的项目是通过storyboard启动的，所以需要将第一个Window 的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View 移除掉。__block UIWindow* window = nil;NSURL * app_Alipay_URL = [NSURL URLWithString:@&quot;alipay:&quot;];UIView *bgView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, Main_Screen_Width, Main_Screen_Height)];bgView.backgroundColor = [UIColor whiteColor];if (![[UIApplication sharedApplication] canOpenURL:app_Alipay_URL]) &#123; //如果没有安装支付宝 NSArray *array = [[UIApplication sharedApplication] windows]; window = [array firstObject]; if (window) &#123; [window.rootViewController.view addSubview:bgView]; [window setHidden:NO]; &#125;&#125;[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123; if (window) &#123; [window setHidden:YES]; [bgView removeFromSuperview]; window = nil; &#125; if (_callBack) &#123; _callBack([self requestFromResultDic:resultDic]); &#125;&#125;];","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"支付宝SDK","slug":"支付宝SDK","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9DSDK/"},{"name":"支付宝","slug":"支付宝","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"}]},{"title":"iOS 多线程同时访问数组出现was mutated while being enumerated","slug":"was_mutated_while_being_enumerated","date":"2016-08-13T02:41:15.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-08-13/was_mutated_while_being_enumerated/","link":"","permalink":"http://fangliquan.github.io/2016-08-13/was_mutated_while_being_enumerated/","excerpt":"错误：iOS 多线程同时访问数组出现was mutated while being enumerated__NSArrayM: 0x96be3e0 was mutated while being enumerated.意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突","text":"错误：iOS 多线程同时访问数组出现was mutated while being enumerated__NSArrayM: 0x96be3e0 was mutated while being enumerated.意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突 + (NSArray *)getAudioPlayArray:(NSArray *)array playingId:(long long)playingId&#123; NSArray * targetArray = nil; NSMutableArray * tempArray = [NSMutableArray array]; for (NSObject * model in array) &#123; AudioPlayModel * playModel = [[AudioPlayModel alloc] init]; if ([model isKindOfClass:[GenBookListDTO class]]) &#123; GenBookListDTO * picBook = (GenBookListDTO *)model; playModel.playId = picBook.bookId; playModel.playName = picBook.name; playModel.playCover = picBook.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[GenSongListDTO class]]) &#123; GenSongListDTO * songRes = (GenSongListDTO *)model; playModel.playId = songRes.songId; playModel.playName = songRes.name; playModel.playCover = songRes.audioCover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_Song; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[AudioPlayModel class]]) &#123; AudioPlayModel * audioModel = (AudioPlayModel *)model; playModel.playId = audioModel.playId; playModel.playName = audioModel.playName; playModel.playCover = audioModel.playCover; playModel.publisher = @&quot;&quot;; playModel.audioType = audioModel.audioType; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[PictureBook class]]) &#123; PictureBook * picBookModel = (PictureBook *)model; playModel.playId = (long long)picBookModel.bookId; playModel.playName = picBookModel.title; playModel.playCover = picBookModel.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[GenBookBorrowedDTO class]]) &#123; GenBookBorrowedDTO * borrowBookModel = (GenBookBorrowedDTO *)model; playModel.playId = borrowBookModel.bookId; playModel.playName = borrowBookModel.name; playModel.playCover = borrowBookModel.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; [tempArray addObject:playModel]; &#125; if (tempArray.count) &#123; [AudioPlayModel saveAudioPlayList:tempArray]; &#125; targetArray = tempArray; return targetArray;&#125; 解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。 NSArray* array=[NSArray arrayWithArray:b];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://fangliquan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"解决Xcode开发组件失效的命令","slug":"solve-Xcode-development-component-failure-of-the-command","date":"2016-07-30T15:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-30/solve-Xcode-development-component-failure-of-the-command/","link":"","permalink":"http://fangliquan.github.io/2016-07-30/solve-Xcode-development-component-failure-of-the-command/","excerpt":"","text":"find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID","categories":[{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/categories/xcode/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/tags/xcode/"}]},{"title":"iOS开发--多线程 NSThread GCD 学习","slug":"iOS-multithreading-NSThread-GCD","date":"2016-07-28T15:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-28/iOS-multithreading-NSThread-GCD/","link":"","permalink":"http://fangliquan.github.io/2016-07-28/iOS-multithreading-NSThread-GCD/","excerpt":"1.基本概念 1.1 进程 进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。","text":"1.基本概念 1.1 进程 进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 1.2 线程 （1）基本概念 1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。（2）线程的串行 1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 1.3 多线程 （1）基本概念 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。（2）线程的并行 并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C。（3）多线程并发执行的原理 在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象（4）多线程优缺点 优点 1）能适当提高程序的执行效率。 2）能适当提高资源利用率（CPU、内存利用率） 缺点 1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 2）线程越多，CPU在调度线程上的开销就越大。 3）程序设计更加复杂：比如线程之间的通信、多线程的数据共享 1.4 多线程在iOS开发中的应用 （1）主线程 1）一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。 2）作用。刷新显示UI,处理UI事件。（2）使用注意 1）不要将耗时操作放到主线程中去处理，会卡住线程。 1.5 iOS中多线程的实现方案 （1）pthread 01 特点： （1）一套通用的多线程API （2）适用于Unix\\Linux\\Windows等系统 （3）跨平台\\可移植 （4）使用难度大 02 使用语言：c语言 03 使用频率：几乎不用 04 线程生命周期：由程序员进行管理（2） NSThread 01 特点： （1）使用更加面向对象 （2）简单易用，可直接操作线程对象 02 使用语言：OC语言 03 使用频率：偶尔使用 04 线程生命周期：由程序员进行管理（3）GCD 01 特点： （1）旨在替代NSThread等线程技术 （2）充分利用设备的多核(自动) 02 使用语言：OC语言 03 使用频率：经常使用 04 线程生命周期：自动管理(4) NSOperation 01 特点： （1）基于GCD（底层是GCD） （2）比GCD多了一些更简单实用的功能 （3）使用更加面向对象 02 使用语言：OC语言 03 使用频率：经常使用 04 线程生命周期：自动管理 2.pthread（1）pthread的基本使用（需要包含头文件） //使用pthread创建线程pthread_t thread; NSString *name = @&quot;wendingding&quot;; //使用pthread创建线程 //第一个参数：线程对象地址 //第二个参数：线程属性 //第三个参数：指向函数的执行 //第四个参数：传递给该函数的参数 pthread_create(&amp;thread, NULL, run, (__bridge void *)(name)); 3.NSThread（1）NSThread的基本使用 //第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置 //创建线程 /* 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） */ NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;wendingding&quot;]; //启动线程 [thread start];//第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置 /* 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 */ [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;我是分离出来的子线程&quot;];//第三种创建线程的方式：后台线程//特点：自动启动县城，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@&quot;我是后台线程&quot;]; （2）设置线程的属性 //设置线程的属性 //设置线程的名称 thread.name = @&quot;线程A&quot;; //设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5 thread.threadPriority = 1.0; （3）线程的状态（了解） //线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 （4）线程安全 01 前提：多个线程访问同一块资源会发生数据安全问题 02 解决方案：加互斥锁 03 相关代码：@synchronized(self)&#123;&#125; 04 专业术语-线程同步 05 原子和非原子属性（是否对setter方法加锁）（5）线程间通信 -(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; （6）如何计算代码段的执行时间 //第一种方法 NSDate *start = [NSDate date]; //2.根据url地址下载图片数据到本地（二进制数据） NSData *data = [NSData dataWithContentsOfURL:url]; NSDate *end = [NSDate date]; NSLog(@&quot;第二步操作花费的时间为%f&quot;,[end timeIntervalSinceDate:start]);//第二种方法 CFTimeInterval start = CFAbsoluteTimeGetCurrent(); NSData *data = [NSData dataWithContentsOfURL:url]; CFTimeInterval end = CFAbsoluteTimeGetCurrent(); NSLog(@&quot;第二步操作花费的时间为%f&quot;,end - start); ###4.GCD （1）GCD基本知识 01 两个核心概念-队列和任务 02 同步函数和异步函数（2）GCD基本使用【重点】 01 异步函数+并发队列：开启多条线程，并发执行任务 02 异步函数+串行队列：开启一条线程，串行执行任务 03 同步函数+并发队列：不开线程，串行执行任务 04 同步函数+串行队列：不开线程，串行执行任务 05 异步函数+主队列：不开线程，在主线程中串行执行任务 06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 07 注意同步函数和异步函数在执行顺序上面的差异（3）GCD线程间通信 //0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@&quot;下载操作所在的线程--%@&quot;,[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@&quot;刷新UI---%@&quot;,[NSThread currentThread]); &#125;); &#125;); （4）GCD其它常用函数 01 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;--dispatch_barrier_async-&quot;); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;---%@&quot;,[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-----&quot;); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); 学习小马哥·文顶顶）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"NSThread","slug":"NSThread","permalink":"http://fangliquan.github.io/tags/NSThread/"},{"name":"GCD","slug":"GCD","permalink":"http://fangliquan.github.io/tags/GCD/"}]},{"title":"iOS 轻量级播放器","slug":"wawa-mediaplayer","date":"2016-07-24T15:30:11.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-24/wawa-mediaplayer/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/wawa-mediaplayer/","excerpt":"公司项目 娃娃 中播放小视频的播放器控件抽取出来，分享一下。WaWaVideoPlayer是一款轻量级视频播放器组件,利用原生MPMoviePlayerController参考kr-video-player编写的一款视频控件。解决项目中微视频播放问题。","text":"公司项目 娃娃 中播放小视频的播放器控件抽取出来，分享一下。WaWaVideoPlayer是一款轻量级视频播放器组件,利用原生MPMoviePlayerController参考kr-video-player编写的一款视频控件。解决项目中微视频播放问题。 WaWaVideoPlayer使用说明使用方法// 视频播放WawaVideoPlayViewController *vc= [[WawaVideoPlayViewController alloc] init];vc.videoURL =[NSURL URLWithString:@&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;];vc.content = @&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;;UINavigationController *rootVedioVc = [[UINavigationController alloc]initWithRootViewController:vc];rootVedioVc.navigationBarHidden = YES;[self presentViewController:rootVedioVc animated:NO completion:nil]; 下载视频核心方法 播放器使用 AFNetworking 进行视频文件的下载，用MBProgressHD实现了下载进度 -(void)downloadVideo :(NSURL *)video andMsgContent:(NSString *)content isOnlyDown:(BOOL )isOnlyDown&#123; NSString *videoPath = [self getVideoSaveFolderPathString];//文件名 NSString *file = [videoPath stringByAppendingPathComponent:[content stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;_&quot;]]; if (![file hasSuffix:@&quot;.mp4&quot;]) &#123; file = [file stringByAppendingString:@&quot;.mp4&quot;]; &#125; self.currentVideoFile = file; NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:file]) &#123; [self createVideoFolderIfNotExist];//创建文件file //初始化进度条 MBProgressHUD *HUD = [MBProgressHUD showMessag:nil toView:self.view]; HUD.tag = 1000; HUD.mode = MBProgressHUDModeAnnularDeterminate; HUD.labelFont = [UIFont systemFontOfSize:12]; HUD.detailsLabelText = @&quot;正在下载...&quot;; HUD.detailsLabelFont = [UIFont systemFontOfSize:14]; HUD.square = YES; //初始化队列 NSOperationQueue *queue = [[NSOperationQueue alloc ]init]; __weak typeof(self)weakSelf = self; //保存路径 AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc]initWithRequest:[NSURLRequest requestWithURL:video]]; op.outputStream = [NSOutputStream outputStreamToFileAtPath:file append:NO]; // 根据下载量设置进度条的百分比 [op setDownloadProgressBlock:^(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead) &#123; CGFloat precent = (CGFloat)totalBytesRead / totalBytesExpectedToRead; HUD.progress = precent; HUD.labelText = [NSString stringWithFormat:@&quot;%0.0f%%&quot;,precent*100]; &#125;]; [op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //NSLog(@&quot;下载成功&quot;); [responseObject writeToFile:file atomically:YES]; if (!isOnlyDown) &#123; [weakSelf playVideoWithURL:[NSURL fileURLWithPath:file]]; &#125;else&#123; if (weakSelf.currentVideoFile &amp;&amp; weakSelf.currentVideoFile.length &gt;0) &#123; [weakSelf.videoController reloadLocalVideo:[NSURL fileURLWithPath:weakSelf.currentVideoFile]]; &#125; &#125; [HUD removeFromSuperview]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //NSLog(@&quot;下载失败&quot;); HUD.labelText = [NSString stringWithFormat:@&quot;下载失败&quot;]; [HUD removeFromSuperview]; if (!isOnlyDown) &#123; [weakSelf dismissViewControllerAnimated:NO completion:nil]; &#125; &#125;]; //开始下载 [queue addOperation:op]; &#125;else&#123; if (!isOnlyDown) &#123; [self playVideoWithURL:[NSURL fileURLWithPath:file]]; &#125;else&#123; [self.videoController reloadLocalVideo:[NSURL fileURLWithPath:self.currentVideoFile]]; &#125; &#125;&#125; 更多具体实现请下载工程实例源码下载","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS视频播放器","slug":"iOS视频播放器","permalink":"http://fangliquan.github.io/tags/iOS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"}]},{"title":"使用Hexo和github pages搭建博客","slug":"使用Hexo-和github-pages-搭建博客","date":"2016-07-24T11:50:26.000Z","updated":"2016-07-24T14:30:26.000Z","comments":true,"path":"2016-07-24/使用Hexo-和github-pages-搭建博客/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/%E4%BD%BF%E7%94%A8Hexo-%E5%92%8Cgithub-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows/MAC/Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo","text":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows/MAC/Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo 2. 配置环境2.1 安装git作者用的是mac，可以使用brew下面命令安装 $ brew install git 也可以直接上git官网下载安装 2.2 安装node.js同样的，mac可以使用brew安装，新版的node.js已经包含npm工具，不需要再另外安装了 $ brew install node 可以通过下面命令检查是否已安装 $ node -v$ npm -v 如果是windows用户可以通过官网下载 jode.js 2.3 Hexo安装上面的安装完成后，接下来安装hexo npm install hexo-cli -g #-g表示全局安装, npm默认为当前项目安装hexo init blog #在当前目录下新建blog目录初始化博客cd blog #进入blog目录#npm install hexo generate #根据当前配置生成静态页面hexo server #启动本地服务，默认为：[http://localhost:4000/](http://localhost:4000/) 接下来就可以通过http://localhost:4000/查看效果了 3. 配置github pages每个github账户都可以有一个外部空间/Responsitory，可以直接通过用户名.github.io访问到该仓库的内容 在github上新增一个responsitory，仓库名为 用户名.github.io 或 用户名.github.com 创建完成后，github会自动将 用户名.github.io指向该仓库，默认访问根目录下的index.html页面 可以进入Responsitory的Setting页查看 github会提供几个模板搭建站点，我们可以不用他提供的模板，可以在仓库里面，添加一个简单的index.html文件，如果能通过用户名.github.com访问，则表明创建成功了 4. 写博客hexo的文章存放在source目录下 ├── source | ├── _posts #存放文章 | └── _drafts #存放草稿 $ hexo new post &quot;postName&quot; # 在source/_posts 目录下创建postName.md文件 创建文件的命名格式可以在_config.yml文件配置 # Writingnew_post_name: :year-:month-:day-:title.md 文件创建完成后会自动生成以下格式（可以自己添加） ---title: 使用Hexo和github pages搭建博客date: 2016-04-18 19:50:26categories: blog # 分类tags: [blogs, hexo] # 标签，格式：[标签, 标签2]--- 关与写作的各种参数可以参见：https://hexo.io/docs/writing.html 写完后预览的时候发现，文章在首页就全部显示出来了，如果不想全部显示，可以在文章中间添加下面标记，在首页列表就会出现Read More的标记 &lt;!--more--&gt; Hexo支持使用Markdown语法写文章，我比较习惯用Atom写Markdown，Atom有个hexo插件 5. 主题官方自带主题基本够用，有能力可以自己改造，当然，网上已经有很多人做了一些很好看的主题了，我们可以直接拿来用，下面是官方列出的一些主题，找到喜欢的可以直接用 https://github.com/hexojs/hexo/wiki/Themeshttps://hexo.io/themes 在hexo上，主题放在themes目录下，我们只需要把别人做好的主题clone下来就好了，然后在_config.yml修改一下配置例如：我们可以https://github.com/xiangming/landscape-plus这个主题clone下来 git clone git@github.com:xiangming&#x2F;landscape-plus.git themes&#x2F;landscape-plus 修改设置_config.yml theme: landscape-plus 6. 添加多说评论插件到多说官网注册和创建一个站点 修改配置到themes/landscape-plus/_config.yml添加多说的配置，shortname即注册的站点名称 # Duoshuoduoshuo_shortname: bomo 参见官方说明，替换评论相关的代码http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9 完成，如下图评论有了 7. 部署到github上修改配置_config.yml deploy: type: git repository: https://github.com/zhengbomo/zhengbomo.github.io.git branch: master 安装 hexo-deployer-git $ npm install hexo-deployer-git --save 部署hexo到git上 $ hexo deploy 部署过程需要输入账号密码，然后会push到github上，参考：https://hexo.io/docs/deployment.html hexo部署时会把最终生成的博客文件（public目录下的文件）push到git远程仓库，而博客程序还是在本地，当我们切换电脑的时候，无法对博客进行重新编辑和发布，这个时候我们可以在git添加一个分支hexo用来存放博客程序和编写的内容，详情可以参见： git创建分支hexo存放博客程序 8. 域名绑定 通常域名在godaddy注册比较靠谱，这个是最大的域名提供商，而且不需要备案，支持支付宝付款，购买的时候可以使用优惠码会便宜一些，网上有很多优惠码，可以自行搜索，购买过程很简单，这里就不贴了 注册和配置DNS服务器Godaddy自带的域名解析服务器比较慢，在国内推荐使用DNSpod：快，免费，稳定。 到DNSpod注册登陆，然后到用户中心，添加域名，例如我的域名为bomobox.org 进入设置添加两个A记录指向github提供的ip，参见这里 192.30.252.153192.30.252.154 添加一个CNAME记录指向自己的github域名：username.github.io把其他的删除 注册域名和配置DNS 到Godaddy购买域名完成后完成后进入MyAccount 进入DNS Manager修改DNS服务器 f1g1ns1.dnspod.netf1g1ns2.dnspod.net 到github仓库的根目录添加CNAME文件，文件内添加自己的域名，否则会出现404访问错误，也可以在hexo的source目录下添加，然后不熟到github 上面步骤设置完成后可能会有几个小时的延迟，才能生效，总的来说还是比较简单的 9. 问题在使用别人的主题的时候可能会报错或者有些功能用不了，原因可能是部分插件没有安装，例如RSS用不了，那可能是hexo-generator-feed没安装，下面列举一些常用的插件，建议都安装，没有用到也没有关系，需要先到hexo程序目录下在执行命令，插件位于node_modules目录下 $ npm install hexo-generator-feed --save #支持RSS$ npm install hexo-generator-sitemap --save #生成站点地图$ npm install hexo-generator-baidu-sitemap --save #生成百度站点地图$ npm install hexo-html-minifier --save #HTML 压缩$ npm install hexo-uglify --save #JavaScript 压缩$ npm install hexo-clean-css --save #CSS 压缩插件$ npm install hexo-generator-seo-friendly-sitemap --save #SEO优化$ npm install hexo-deployer-git --save #git部署插件 并在博客配置文件_config.yml配置plugin Plugins:- hexo-generator-feed- hexo-generator-sitemap 更多插件可以在https://hexo.io/plugins/找到 10. Atom插件由于我编写md使用的是Atom，这里推荐几个Atom上的插件 markdown-scroll-sync：Markdown预览实时滚动，自带的预览不支持实时滚动 markdown-writer：Markdown协作工具 Date：快速插入当前时间的工具 atom-hexo：快速添加draft，post，publish，deploy 11. 总结使用hexo搭建博客环境还是非常方便的，基本上都是自动的，当然还有一些详细的配置，例如分页，分类，评论等，Hexo支持的插件也相当多的，接下来可以好好写博客了，以后再慢慢完善了，今天先到这里 12. 参考链接 https://hexo.io 转自 bomo大神的博客","categories":[{"name":"blog","slug":"blog","permalink":"http://fangliquan.github.io/categories/blog/"}],"tags":[{"name":"blogs","slug":"blogs","permalink":"http://fangliquan.github.io/tags/blogs/"},{"name":"hexo","slug":"hexo","permalink":"http://fangliquan.github.io/tags/hexo/"}]},{"title":"iOS开发--图文混排","slug":"iOS-multi-graphic-solution-Frame-model","date":"2016-07-24T05:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-24/iOS-multi-graphic-solution-Frame-model/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/iOS-multi-graphic-solution-Frame-model/","excerpt":"iOS开发中会遇到页面展示多图文的问题，尤其是新闻等图文混排，而且是图片不知道到宽高的情况。 此时就需要先异步下载图片然后根据得到的image通过 宽高比来更新对应ImageView的Frame。最后通过每个ImageView的Frame变化在重新更新多图文UI的Frame。","text":"iOS开发中会遇到页面展示多图文的问题，尤其是新闻等图文混排，而且是图片不知道到宽高的情况。 此时就需要先异步下载图片然后根据得到的image通过 宽高比来更新对应ImageView的Frame。最后通过每个ImageView的Frame变化在重新更新多图文UI的Frame。 根据页面设计得出页面的Frame模型 例： @property(nonatomic ,assign ,readonly) CGRect noticeTitleF;@property(nonatomic ,assign ,readonly) CGRect noticeTimeF;@property(nonatomic ,assign ,readonly) CGRect noticeSenderF;@property(nonatomic ,assign ,readonly) CGRect noticecontentF;@property(nonatomic ,strong ,readonly) NSArray *noticeImagesF;@property(nonatomic ,strong ,readonly) NSArray *noticeImagesDespF; 给通过Frame模型中setModel方法来计算对应的Rect值 项目中的图文和标题内容是分开的 以AttachModel集合的方式返回过来，先假设集合中的每一项都有image和对应的描述来计算对应的Attach的ViewModelFrame，例：HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i];ViewFrameModel *imageRect = [[ViewFrameModel alloc]init];imageRect.x = rightAndLeftMargin;imageRect.y = offsetY + upImageDespH;imageRect.width = contentWidth;imageRect.height = 300;[imagesF addObject:imageRect]; CGFloat imageDespH = [BabyScheduleTaskHeaderFrame textFrameWithString:pictureTopicPost.desp width:contentWidth fontSize:WAWA_TEXTFONT_FLOAT_TITLE].height + 2;ViewFrameModel *imageDespRect = [[ViewFrameModel alloc]init];imageDespRect.x = rightAndLeftMargin;imageDespRect.y = offsetY + upImageDespH + 300;imageDespRect.width = contentWidth;imageDespRect.height = imageDespH;[imagesDespF addObject:imageDespRect];upImageDespH += (imageDespH +topAndBottomMargin + 300); 根据集合下载对应的Image并更新Framefor (int i = 0 ; i &lt;attachs.count; i++) &#123; HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i]; [self getClassWeeklyTaskAttachPictureFrame:pictureTopicPost andIndex:i completion:^(NSInteger index, CGFloat imageH)&#123; NSMutableArray *imagesOldF = [NSMutableArray arrayWithArray:_noticeImagesF]; NSMutableArray *imagesDespOldF = [NSMutableArray arrayWithArray:_noticeImagesDespF]; //更新imageHeight ViewFrameModel *pictureF = imagesOldF [index]; pictureF.height = imageH; [imagesOldF replaceObjectAtIndex:index withObject:pictureF]; ViewFrameModel *oldpictureFM = [imagesOldF firstObject]; CGRect oldpictureR = CGRectMake(oldpictureFM.x, oldpictureFM.y, oldpictureFM.width, oldpictureFM.height); ViewFrameModel *oldpictureDespFM = [imagesDespOldF firstObject]; oldpictureDespFM.y = CGRectGetMaxY(oldpictureR) + topAndBottomMargin; [imagesDespOldF replaceObjectAtIndex:0 withObject:oldpictureDespFM]; CGFloat oldOffsetY = offsetY + oldpictureFM.height + topAndBottomMargin + oldpictureDespFM.height + topAndBottomMargin; //遍历集合 重新赋值frame for (int m = 1; m &lt;imagesOldF.count; m++) &#123; oldOffsetY = oldOffsetY; ViewFrameModel *uppictureF = imagesOldF [m]; uppictureF.y = oldOffsetY; [imagesOldF replaceObjectAtIndex:m withObject:uppictureF]; oldOffsetY = oldOffsetY + uppictureF.height + topAndBottomMargin; ViewFrameModel *uppictureDespF = imagesDespOldF [m]; uppictureDespF.y = oldOffsetY; [imagesDespOldF replaceObjectAtIndex:m withObject:uppictureDespF]; oldOffsetY = oldOffsetY + uppictureDespF.height + topAndBottomMargin; &#125; _noticeFooterF = CGRectMake(0, oldOffsetY + topAndBottomMargin*4, Main_Screen_Width, 1); _noticeHeaderHeight = CGRectGetMaxY(_noticeFooterF); _noticeImagesF = imagesOldF; _noticeImagesDespF = imagesDespOldF; if (self.reloadNoticeHeaderFrameBlock) &#123; //更新页面Frame回调Block self.reloadNoticeHeaderFrameBlock(); &#125; &#125;];&#125; 根据设计编写多图文的UIView代码 有多图文对象的个数来绘制页面并保存到数组中 _imageArray = [NSMutableArray arrayWithCapacity:_momentPicturesCount];_imageDespArray = [NSMutableArray arrayWithCapacity:_momentPicturesCount];for (int i = 0;i&lt; _momentPicturesCount;i++) &#123; UIImageView *picView = [[UIImageView alloc]init]; picView.tag = i; picView.image = [UIImage imageNamed: (@&quot;childshow_placeholder&quot;)]; picView.userInteractionEnabled = YES; [picView addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(showPicture:)]]; [_imageArray addObject:picView]; [self addSubview:picView]; AutoLinkLabel *imageDespLabel = [[AutoLinkLabel alloc]init]; imageDespLabel.font = [UIFont systemFontOfSize:WAWA_TEXTFONT_FLOAT_CONTENT_BIG]; imageDespLabel.textColor = WAWA_TEXTCOLOR_DARKGRAY; imageDespLabel.aDelegate = self; imageDespLabel.numberOfLines = 0; [_imageDespArray addObject:imageDespLabel]; [self addSubview:imageDespLabel];&#125; 在UIView的setModel中给页面控件赋值Frame和Content 由计算好的Frame在重新给已保存好的多图文集合赋值并替换 for (int i = 0 ; i &lt; babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs.count; i++) &#123; UIImageView *imageView = self.imageArray[i]; ViewFrameModel *frameModel = babyScheduleTaskHeaderFrame.noticeImagesF[i]; imageView.frame = CGRectMake(frameModel.x, frameModel.y, frameModel.width, frameModel.height); //NSLog(@&quot;image%ld, offsetY:%ld,height :%ld&quot;,i,frameModel.y,frameModel.height); AutoLinkLabel *imageDespL = self.imageDespArray[i]; ViewFrameModel *despframeModel = babyScheduleTaskHeaderFrame.noticeImagesDespF[i]; imageDespL.frame = CGRectMake(despframeModel.x, despframeModel.y, despframeModel.width, despframeModel.height); //NSLog(@&quot;imageDesp%ld, offsetY:%ld,height :%ld&quot;,i,despframeModel.y,despframeModel.height); HedoneAttachDTO *pictureTopicPost = babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs[i]; [imageView setImageWithURLStr:pictureTopicPost.addr placeholder:[UIImage imageNamed:@&quot;childshow_placeholder&quot;]]; imageDespL.autoLinkText = pictureTopicPost.desp?pictureTopicPost.desp:@&quot;&quot;; [self.imageArray replaceObjectAtIndex:i withObject:imageView]; [self.imageDespArray replaceObjectAtIndex:i withObject:imageDespL];&#125; 将UIView赋值给TableViewHeader定义多图文frameModel对象并设置detailModel BabyScheduleTaskHeaderFrame *detailHeaderFrame = [[BabyScheduleTaskHeaderFrame alloc]init];detailHeaderFrame.hedoneClassWeeklyTaskResponse = model;__unsafe_unretained typeof(self) selfVc = self;detailHeaderFrame.reloadNoticeHeaderFrameBlock = ^()&#123; //回调更新Frame selfVc.babyScheduleTaskHeaderView.babyScheduleTaskHeaderFrame = selfVc.babyScheduleTaskHeaderFrame; CGRect oldHeaderF = selfVc.babyScheduleTaskHeaderView.frame; oldHeaderF.size.height = selfVc.babyScheduleTaskHeaderFrame.noticeHeaderHeight; selfVc.babyScheduleTaskHeaderView.frame = oldHeaderF; selfVc.tableView.tableHeaderView = selfVc.babyScheduleTaskHeaderView;&#125;;self.babyScheduleTaskHeaderFrame = detailHeaderFrame;BabyScheduleTaskHeaderView *detailHeaderView = [[BabyScheduleTaskHeaderView alloc]initWithFrame:CGRectMake(0, 0, Main_Screen_Width, detailHeaderFrame.noticeHeaderHeight) andMomentPicturesCount:(int)model.attachs.count];detailHeaderView.babyScheduleTaskHeaderFrame = detailHeaderFrame;self.babyScheduleTaskHeaderView = detailHeaderView;self.tableView.tableHeaderView = self.babyScheduleTaskHeaderView; 更多具体实现请下载源码 下载源码","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS多图文","slug":"iOS多图文","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E5%9B%BE%E6%96%87/"},{"name":"图文混排","slug":"图文混排","permalink":"http://fangliquan.github.io/tags/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/"},{"name":"Frame模型","slug":"Frame模型","permalink":"http://fangliquan.github.io/tags/Frame%E6%A8%A1%E5%9E%8B/"}]},{"title":"iOS新特性学习--泛型","slug":"iOS9-new-feature-generic","date":"2016-07-23T09:06:11.000Z","updated":"2021-03-14T07:55:26.990Z","comments":true,"path":"2016-07-23/iOS9-new-feature-generic/","link":"","permalink":"http://fangliquan.github.io/2016-07-23/iOS9-new-feature-generic/","excerpt":"泛型：限制类型使用场景 在集合（数组，字典，NSSet)中使用泛型比较常见 当声明一个类，类里面的某些书写的类型不确定，这时候我们才使用泛型。z","text":"泛型：限制类型使用场景 在集合（数组，字典，NSSet)中使用泛型比较常见 当声明一个类，类里面的某些书写的类型不确定，这时候我们才使用泛型。z 书写规范 在类型后面定义泛型，1NSMutableArray&lt;UIImage *&gt; *mutableArray 修饰：只能修饰方法的调用 好处： 提高规范，减少交流 通过集合取出来对象，直接当做泛型对象使用，可以直接使用点语法1self.mutableArray[0].temp; 子类想给父类赋值使用协变__covariant(协变）:用于数据强转类型，可以向上强转，子类，可以转成 父类，例: 1@interface Person&lt;__covariant ObjectType&gt; 父类强转成子类 逆变__contravariant（逆变）：用于泛型数据强转类型，可以向下强转，父类可以转成子类 例: 1@interface Person&lt;__contravariant ObjectType&gt; 定义泛型类123@interface Person&lt;__covariant ObjectType&gt; : NSObject@property(nonatomic) ObjectType language;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"http://fangliquan.github.io/tags/runtime/"},{"name":"iOS9新特性","slug":"iOS9新特性","permalink":"http://fangliquan.github.io/tags/iOS9%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-07-22T09:06:11.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-22/hello-world/","link":"","permalink":"http://fangliquan.github.io/2016-07-22/hello-world/","excerpt":"","text":"世界上的第一个程序就是Hello World！！ I am a programmer. I like programming.","categories":[],"tags":[]},{"title":"swift学习笔记","slug":"swift-start","date":"2016-06-28T07:00:04.000Z","updated":"2016-12-16T07:00:04.000Z","comments":true,"path":"2016-06-28/swift-start/","link":"","permalink":"http://fangliquan.github.io/2016-06-28/swift-start/","excerpt":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子","text":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子 一、基础语法 swift语句结束不需要分号（写了也没有问题），有一种情况需要分号，如果一行代码中有多条语句，这时候就必须要分号隔开 swift字符串，数组语法糖，字典语法糖不需要@标示 swift是类型安全的语言，所有的类型都不会自动转换（如：Int和UInt类型不能直接运算），同事swift具有强大的类型推测，所以很多时候我们不需要声明类型 swift的多行注释支持嵌套/* 这是第一个多行注释的开头/* 这是第二个被嵌套的多行注释 */这是第一个多行注释的结尾 */ swift的布尔值使用小写true和false，判断语句只能使用Bool类型 二、数据类型 与objc一样，swift支持以前（objc）使用的所有数据类型，swift的类型名字首字母大写，如Int, Float, NSInteger swift支持可选类型（Optionals）类型，相当于C#中的可空类型，标识变量可能为空，基础数据类型也可为空，可选类型不能直接赋非可选类型var a: Int? = 10var b: Int = a // 报错，不同类型不能赋值 swift的布尔类型使用true/false，而不用YES/NO swift支持使用_来分割数值来增强可读性而不影响值，如一亿可以表示为下面形式let oneMillion = 1_000_000 swift数值类型进行运算符计算的时候不会自动进行类型转换，通常可以通过类型的构造方法进行类型转换var a: Int = 12var b: Float = 23var c = a + b // 报错var d = Float(a) + b // 正确 swift的基础数据类型与对象类型一视同仁，可以混用，不需要装箱和拆箱 TODO：Any, AnyObject,三、常量变量 与C/Obj-C不同，swift的常量更为广义，支持任意类型，常量只能赋值一次 swift的变量和常量在声明的时候类型就已经确定（由编译器自动识别或开发者指定） 使用let声明的集合为可变集合，使用var声明的集合为不可变集合 如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。这样可以尽量数据安全，并且常量是线程安全 // 常量：使用let声明，赋值后就不能再修改let a = NSMutableArray()let b = 12let c: Float = 12 // 类型标注(type annotation)let d = b + 12a.addObject(11) // str == [11]let e = a // str == [11], d == [11]a.addObject(12) // str == [11, 12], d == [11, 12]// 变量：使用var声明var f: Double? = 12var g = &quot;hello world&quot; 类型标注在声明变量和常量的时候可以如果可以由编译器自动识别，可以不用制定类型，如下 let a = 12 //常量a会编译为Int类型var b = 1.3 //变量b会编译为Double类型 我们也可以指定类型 let a: Double = 12let b: Float = 1.3 可以在一行声明多个变量/常量，在最后一个声明类型 var red, green, blue: UInt 四、序列和集合1. 数组Arrayswift的数组可以是有类型的（泛型），存放同类型的数据，如果添加一个错误的类型会报编译错误，默认情况下编译器会自动识别 //1. 数组的写法为：Array&lt;Int&gt;，也可以简写成[Int]//2. 数组初始化与NSArray类似，直接用中括号括起来，里面值用逗号隔开var array0 = [Int]()var array1: [Int] = [1, 3, 5, 7, 9]var array2: Array&lt;Int&gt; = array1array1.append(11) // [1, 3, 5, 7, 9, 11]array1.insert(0, atIndex: 0) // [0, 1, 3, 5, 7, 9, 11]array1.isEmpty // Falsearray1.count // 7// 3. 如果初始化时不指定类型，而编译器也不能识别出类型，这时候，会被当成NSArray处理var array3 = [] // array3 为 NSArray类型的空数组// 4. 如果声明的时候使用不同的类型，编译器会把数组识别为NSObject类型var array4 = [&quot;fdsa&quot;, 121] // array4 为 Array&lt;NSObject&gt; 类型// 5. 集合支持加法运算，相当于NSMutableArray的addObjectsFromArrayarray1 += [2, 4, 6, 8, 10] // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]// 6. 使用let声明的数组不可变，不能修改数组array3let array5: [Int] = [1, 3, 5, 7, 9]//array5.append(2) // 报编译错误// 7. 集合使用下标索引，支持区间索引，区间不可越界var array6: [Int] = [1, 3, 5, 7, 9]array6[1] = 4 // [1, 3, 5, 7, 9]array6[1...3] = [2, 3, 4] // [1, 2, 3, 4, 9]array6[0...2] = array6[1...3] // [2, 3, 4, 4, 9]// 8. 迭代数组的时候，如果需要索引，可以用enumerate方法for (index, value) in array4.enumerated() &#123; //do something&#125; 2. 字典Dictionary与数组类型一样，字典也支持泛型，其键值类型都可以指定或有编译器识别，其中Key的类型，必须是可Hash的，swift中基础数据类型都是可hash的（String、Int、Double和Bool） // 1. 用法与oc类似，初始化不需要@var dict1 = [&quot;key1&quot;: 1, &quot;key2&quot;: 2, &quot;key3&quot;: 3]// 2. 声明方式var dict2: Dictionary&lt;String, Int&gt; = dict1 //dict2与dict1不是一个对象var dict3: [String: Int] = dict1 //通常采用这种方式声明类型// 3. 不声明类型，编译器又无法识别，则为NSDictionaryvar dict4 = [:]var dict5: [Int: String] = [:]// 4. 修改或添加键值对dict1[&quot;key3&quot;] = 4// 5. 删除键dict1[&quot;key3&quot;] = nil// 6. key不存在不报错，返回可空类型nillet value4 = dict1[&quot;key4&quot;]// 7. 字典迭代返回key/value元组，类似pythonfor (key, value) in dict1 &#123; print(&quot;\\(key) = \\(value)&quot;)&#125; 数组（Array）或字典（Dictionary），如果声明为变量（var），则为可变，如果为常量（let），则为不可变常量数组或字典编译器会对其进行优化，所以尽量把不可变的数组定义为常量数组 3. SetSet集合用于存放无序不重复的对象，用法与数组类似，重复的项会被忽略 var s: Set&lt;Int&gt; = [1, 3, 5, 6, 7, 4, 3, 7] // [1, 3, 4, 5, 6, 7]s.counts.isEmptys.insert(3)s.remove(3)s.contains(3) 集合操作 let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]//合操作oddDigits.union(evenDigits).sort() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]//交操作oddDigits.intersection(evenDigits).sorted() // []//减操作oddDigits.subtracting(singleDigitPrimeNumbers).sorted() // [1, 9]//不重叠集合oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted() // [1, 2, 9] 使用“是否相等”运算符( == )来判断两个 合是否包含全部相同的值。 使用 isSubset(of:) 方法来判断一个 合中的值是否也被包含在另外一个 合中。 使用 isSuperset(of:) 方法来判断一个 合中包含另一个 合中所有的值。 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。 使用 isDisjoint(with:) 方法来判断两个 合是否不含有相同的值(是否没有交 ) 4. 元组Tuple与python类似，swift也支持元组，可以很方便的使用元组包装多个值，也使得函数返回多个值变得更加方便，特别是临时组建值得时候 支持任意类型 支持同时赋值 支持自定义key，支持索引 元组不是对象，不是AnyObject类型，由于swift是强类型的，所以元组有时不能当做普通的对象使用，例如不能把元组加到数组里面，元组内的所有类型必须是明确的 // 1. 声明一个元组，元组支持任意类型let httpError1 = (404, &quot;Not Found&quot;)let point = (100, 50)// 2. 可以分别赋值let (x, y) = pointprint(x) // 100print(y) // 50// 3. 使用下标取元组元素，下标从0开始print(httpError1.0) // 404print(httpError1.1) // Not Found// 4. 可以给数组元素取名let httpError2 = (code: 404, errorMessage: &quot;Not Found&quot;)print(httpError2.code) // 404print(httpError2.errorMessage) // Not Found// 5. 可以用下划线表示忽略部分值let (a, _) = point 元组在临时组织值得时候很有用，可以不用重新定义数据结构 5. 字符串Stringswift字符串是由Character字符组成的集合，支持+操作符，可以与NSString无缝桥接，swift的字符串完全兼容unicode字符串与值类型（与Int, Float）一样，是值类型，在传值的时候都会进行拷贝，当然这回带来一定的性能损耗，swift编译器在编译的时候会进行优化，保证只在必要的情况下才进行拷贝 // 1. 与NSString不同，声明不需要@前缀，支持转移字符let name1 = &quot;bomo\\n&quot;// 2. 空串（下面两种方式等价）let name2 = &quot;&quot;let name3 = String()// 3. 字符串由字符Character组成，定义字符let character1: Character = &quot;!&quot;// 4. 常见属性，方法name1.isEmpty // 判空name1.characters.count // 获取字符串的字符数name1.uppercaseStringname1.lowercaseStringname1.hasPrefix(&quot;bo&quot;)name1.hasSuffix(&quot;mo&quot;)// 5. 加法运算let hello = &quot;hello &quot; + name1 // hello bomo\\n// 6. 比较（比较值，而不是地址）let name4 = &quot;b&quot; + &quot;omo\\n&quot;name4 == name1 // True// 7. 字符串插值（使用反斜杠和括号站位）let city = &quot;广州&quot;let hello2 = &quot;I&#x27;m \\(name1) from \\(city)&quot;// 8. 格式化字符串let f = 123.3233var s = String(format: &quot;%.2f&quot;, f) //123.32 6. 集合的赋值和拷贝行为swift的集合通常有Array和Dictionary，他们在赋值或传递的时候，行为上有所不同，字典类型Dictionary或数组类型Array在赋值给变量或常量的时候，只要有做修改，就会进行值拷贝，并且不会作用到原来变量上 var dict1 = [&quot;a&quot;: 1, &quot;b&quot;: 2]var dict2 = dict1print(dict1 == dict2) // truedict2[&quot;a&quot;] = 3 // 修改dict2print(dict1 == dict2) // falsevar arr1 = [&quot;a&quot;, &quot;b&quot;]var arr2 = arr1print(arr1 == arr2) // truearr1[0] = &quot;c&quot; // 修改arr1// arr1.append(&quot;c&quot;)print(arr1 == arr2) // false 当数组或字典作为参数传递给函数的时候，由于在Swift3中不推荐使用变量参数，故所有函数参数不可变，故也不进行拷贝 五、可选类型（可空类型）swift加入了可空类型让我们使用数据的时候更为安全，我们需要在可空的地方使用可选类型声明该变量可为空，不能给非可选类型设值nil值，在使用的时候可以明确的知道对象是否可能为nil，有点像ObjC的对象，对象可以为nil，也可以不为nil，而swift得可选类型范围更广可以作用于任何类型（基础类型，类，结构体，枚举） 1. 声明// 1. 声明可选类型，在类型后面加上?var obj1: NSObject?obj1 = NSObject()obj1 = nil// 2. 不能给一个可选类型赋nil，下面会报错，var obj = NSObject()obj = nil// 3. 如果声明可选变量时没有赋值，则默认为nilvar i: Int?// 4. 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;// 5. 不能把可选类型赋值给非可选类型，下面会报错let cat: String = dog 2. 强制解析可选类型不能直接使用，需要通过取值操作符!取得变量的值，才能使用，如果变量有值，则返回该值，如果变量为空，则会运行时错误 var b: Int?var a: Inta = 12b = 13let c = a + b! // 先对b取值，再运算var b: Bool? = nilif b! &#123; // b为空，编译不报错，运行时报错 print(&quot;true&quot;)&#125; else &#123; print(&quot;false&quot;)&#125; 3. 可选绑定使用可选绑定可以判断一个可选类型是否有值，如果有值，则绑定到变量上，如果没有值，返回false，使用if-let组合实现 var i: Int? = nilif let number = i &#123; print(&quot;\\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持绑定条件 var i: Int? = nilif let number = i where i &gt; 10 &#123; print(&quot;i不为空且大于10 \\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持多个绑定，不许所有的绑定都满足才返回true if let firstNumber = 1, let secondNumber = 2)&#125;// 输出 &quot;4 &lt; 42 &lt; 100&quot; if let firstNumber = Int(&quot;4&quot;) &#123; if let secondNumber = Int(&quot;42&quot;) &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print(&quot;\\(firstNumber) &lt; \\(secondNumber) &lt; 100&quot;)&#125; &#125;&#125; 4. 隐式解析声明类型的时候可以使用隐式解析，即在使用可选变量的时候自动取值，不需要调用!操作符， // 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;//假定我们通过getdog方法返回的值一定不为空var dog: String? = getdog()let cat: String = dog! // 使用前需要通过!强制取值 使用dog的时候都需要取值我们觉得太麻烦了，可以声明成隐式可选类型，使用的时候自动取值 var dog: String! = getdog() // 实际上dog还是可选类型，只是使用的时候回自动取值let cat: String = dog // 在使用dog的时候会自动进行取值，不需要取值操作符 5. 可选类型自判断链接在使用可选类型之前，需要进行判断其是否有值，才能使用，通过!操作符取值后使用（保证有值的情况下），或通过if-let可选绑定的方式，swift提供了一种类似C#语言的语法糖可以让代码更为简洁，可以自动判断值，如果有值，则操作，无值则不操作，并返回nil，在使用前加上? class Person &#123; var favDog: Dog?&#125;class Dog &#123; var name: String?&#125;var p = Person()var d = Dog()// p.favDog = dp.favDog?.name = &quot;tobi&quot; // 如果p.favDog为空，不设置nameif let name = p.favDog?.name &#123; // p.favDog不为空且p.favDog.name不为空&#125; else &#123; // p.favDog为空或p.favDog.name为空&#125; 自判断链接还支持多连接如 let identifier = john.residence?.address?.buildingIdentifier 6. 可选关联运算符可选关联运算符可对可选类型进行拆包，如果可选类型对象为nil，返回第二个操作数，第二个操作数类型必须和第一个操作数同类型（可选或不可选） let defaultColorName = &quot;red&quot;var userDefinedColorName: String? // defaults to nilvar colorNameToUse = userDefinedColorName ?? defaultColorName defaultColorName和userDefinedColorName必须是同类型（String或String?） 如果userDefinedColorName不为空，返回其值，如果userDefinedColorName为空，返回defaultColorName 返回值colorNameToUse的类型同??的第二个操作数的类型，为String 六、运算符swift运算符在原有的基础上做了一些改进，还添加了一下更高级的用法，还有新的运算符 =运算符不返回值 符合运算符+=, -=等不返回值 //下面语句会报错let b = a *= 2 比较运算符可以用于元组的比较（逐个比较，如果遇到不等的元素，则返回，默认最多只能比较7个元素的元组，超过则需要自定义） (1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2 字符串String，字符Character支持+运算符 浮点数支持%求余运算 8 % 2.5 // 等于 0.5 ++/--运算在swift3被抛弃，用+=/-=代替 支持溢出运算符（&amp;+, &amp;-, &amp;*），可以在溢出时进行(高位)截断 支持位运算符（&gt;&gt;, &lt;&lt;） 支持三目运算符（a ? b : c） 支持逻辑运算符（&amp;&amp;, ||, !） 与其他高级语言类似，swift运算符支持重载，可以为类添加自定义的运算符逻辑，后面会讲到 !=, ==, ===, !==（恒等于/不恒等于） `===`：这两个操作符用于引用类型，用于判断两个对象是否指向同一地址 `!===`：与`===`相反，表示两个变量/常量指向的的地址不同 `==`：表示两个对象逻辑相等，可以通过重载运算符实现相等的逻辑，两个值相等的对象可以是不同地址的对象 `!=`：与`==`相反，表示两个对象逻辑不等 区间运算符 可以使用a...b表示一个范围，有点类似于Python的range(a, b) for i in 1...5 &#123; print(i) // 1, 2, 3, 4, 5&#125; a...b: 从a到b并包含a和b a..&lt;b: 包含a不包含b a..b表示半闭区间的用法已经被放弃 范围运算符也可以作用于字符串 let az = &quot;a&quot;...&quot;z&quot; // 返回的是CloseInteval或HalfOpenIntervalaz.contains(&quot;e&quot;) // True 空合运算符??（与C#类似） 对于可选类型取值，如果不为空则返回该值，如果为空则去第二个操作数 let result = a ?? b 七、流程控制swift使用三种语句控制流程：for-in、for、switch-case、while和repeat-while，且判断条件的括号可以省略 let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names &#123; print(&quot;Hello, \\(name)!&quot;)&#125;//如果不需要使用到迭代的值，使用下划线`_`忽略该值for _ in 1...10 print(&quot;hello&quot;) 流程控制语句的条件返回值必须是Bool，下面会报错 var dd: Bool? = trueif dd &#123; print(&quot;fd&quot;)&#125; 条件判断可以与let结合使用，当值为nil时，视为false（即：可选绑定） var dd: Bool? = trueif let ee = dd &#123; print(&quot;fd&quot;)&#125; 在Swift2.0以后，不支持do-while语句，使用repeat-while代替，用法与do-while一样 repeat &#123; print(&quot;repeat while : \\(j)&quot;) j++ &#125; while j &lt; 3 guard-else翻译为保镖模式，在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的if-else模式 func test(i: Int?) &#123; if let i = i where i &gt; 0 &#123; // 符合条件的处理 return &#125; // 不符合条件的处理&#125; 上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部 func test(i: Int?) &#123; guard let i = i where i &gt; 0 else &#123; // 在这里拦截，处理不符合条件的情况 return &#125; // 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用 print(i)&#125; 保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性 保镖模式guard-else内的代码块必须包含break, return等跳出代码块的关键字 switch-case switch语句支持更多数据类型（String，Int, Float, 元组, 枚举），理论上switch支持任意类型的对象（需要实现~=方法或Equatable协议，详情参见这里） case可以带多个值，用逗号隔开 case可以支持区间（a...b），支持元组，区间可以嵌套在元组内使用 case多条语句不需要用大括号包起来 case语句不需要break，除了空语句，如果需要执行下面的case，可以使用fallthrough 如果case不能命中所有的情况，必须要default，如Int，String类型，否则编译会失败 可以用fallthrough关键字声明接着执行下一条case语句，注意，如果case语句有赋值语句（let），则fallthrough无效 // 定义一个枚举enum HttpStatus &#123; case ServerError case NetworkError case Success case Redirect&#125;var status = HttpStatus.Redirectswitch status &#123;// case可以接收多个值case HttpStatus.ServerError, HttpStatus.NetworkError: print(&quot;error&quot;) // case语句结束显式写break，除非是空语句case .Redirect: // 如果编译器可以识别出枚举类型，可以省略枚举名 print (&quot;redirect&quot;) fallthrough // 像C语言一样，继续执行下一条casecase HttpStatus.Success: print(&quot;success&quot;)&#125;//元组，区间let request = (0, &quot;https://baidu.com&quot;)switch request &#123;case (0, let a): // 支持绑定 print(a)case let (a, b) where a == 1: // 绑定可以卸载元组外面，支持where判断 print(&quot;cancel \\(b)&quot;)case (2...10, _): // 支持区间，支持忽略值 print(&quot;error&quot;)default: print(&quot;unknown&quot;)&#125;// case可以与where进行进一步判断let request2 = (0, 10)switch request2 &#123;case (0, let y) where y &lt; 5:&quot;success&quot; //被输出case (0, let y) where y &gt;= 5:&quot;error&quot; //被输出default: &quot;unknown&quot;&#125; case除了和swift一起使用外，还支持与if语句结合使用，用法与switch一样 let bb = (12, &quot;bomo&quot;)if case (1...20, let cc) = bb where cc == &quot;bomo&quot; &#123; print(cc)&#125; else &#123; print(&quot;nil&quot;)&#125; 带标签的语句如果有多层嵌套的情况下，有时候我们需要在某处直接退出多层循环，在objc下并没有比较好的方式实现，需要添加退出标识，然后一层一层退出，而在swift可以很方便的退出多层循环，首先需要使用标签标识不通的循环体，形式如下 labelName : while condition &#123; statements &#125; 看下面例子 outerLoop1 : for i in 1...10 &#123; outerLoop2 : for j in 1...10 &#123; outerLoop3 : for k in 1...10 &#123; if j &gt; 5 &#123; // 1. 跳出一层循环（默认）继续outerLoop2的循环 break // 2. 跳出两层循环，继续outerLoop1的循环 // break outerLoop2 // 3. 跳出三层循环，退出整个循环，继续后面的语句 // break outerLoop1 &#125; &#125; &#125;&#125; 八、函数1. 基本形式//有返回值func 函数名(参数名1:参数类型1, 参数名2:参数类型2) -&gt; 返回值类型 &#123; // 函数体&#125;//多个返回值（元组）func getPoint() -&gt; (x: Int, y: Int) &#123; return (1, 3)&#125;var p = getPoint()p.x//无参数无返回值func sayHello() &#123; // 函数体&#125;//eggfunc add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(12, b: 232) 函数调用除了第一个参数，后面所有的参数必须带上参数名（符合Objc的函数命名规则）如果是调用构造器，第一个参数也需要显示声明 class A &#123; var name: String init(name: String) &#123; self.name = name &#125; func sayHello(msg: String, count: Int) &#123; for _ in 1...count &#123; print (msg) &#125; &#125;&#125;let a = A(name: &quot;bomo&quot;) // 构造器所有参数都必须显示声明参数名a.sayHello(&quot;hello&quot;, count: 2) // 函数参数除了第一个其他都需要显示声明参数名 2. 可变参数可变参数只能作为最后一个参数，一个方法最多只有一个可变参数 func sum(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125; 3. 外部参数名默认情况下，如果不指定外部参数名，swift编译器会自动为函数参数声明与内部参数名同名的外部参数名（格式为：外部参数名 内部参数名: 类型名） //默认情况下，外部参数名与内部参数名一样func add(first a: Int, second b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(first: 10, second: 20) 如果函数在第一个参数定义外部参数名，必须显示指定，当然我们还可以通过下划线_让函数忽略参数名 func add(a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;add(1, 2) 4. 函数默认值函数还支持声明默认值，（格式为：外部参数名 内部参数名: 类型名 = 默认值） func log(msg: String, isDebug: Bool = true) &#123; if isDebug &#123; print(msg) &#125;&#125;log(&quot;fail&quot;)log(&quot;success&quot;, isDebug: false) 如果使用默认值并且默认值不是出现在最后，那调用的时候必须写全所有参数 建议把默认参数放到最后面，这样可以确保非默认参数的赋值顺序，减少参数混乱的情况 5. 闭包 函数作为变量 函数作为函数参数 函数作为函数返回值 闭包函数声明func add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;//函数作为变量，函数hello赋给somefunc，并调用let somefunc: (Int, Int) -&gt; Int = addsomefunc(10, 20) // 30//函数作为参数func logAdd(a:Int, b:Int, function: (Int, Int) -&gt; Int) &#123; // 函数内容 print(&quot;begin&quot;) function(a, b) print(&quot;end&quot;)&#125;logAdd(12, b: 23, function: add)//函数作为返回值（包装一个函数，在执行前后输出信息），函数作为参数又作为返回值func addWrapper(addFunc: (Int, Int) -&gt; Int) -&gt; ((Int, Int) -&gt; Int) &#123; // 函数内容 func wrapper(a: Int, b: Int) -&gt; Int &#123; print(&quot;begin&quot;) let res = addFunc(a, b) print(&quot;end&quot;) return res &#125; return wrapper&#125;var newAdd = addWrapper(add)newAdd(12, 32) 闭包函数声明形式 &#123; (parameters) -&gt; returnType in statements // 可以有多行&#125; 闭包函数 //定义一个函数变量var addfunc: (Int, Int) -&gt; Int//闭包的写法// 1. 完整写法addfunc = &#123;(a: Int, b: Int) -&gt; (Int) in //var c = a + 1 //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号 return a + b&#125;// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略addfunc = &#123;(a, b) in return a + b&#125;// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略addfunc = &#123;a, b in a + b&#125;// 4. 参数和in可以省去，通过$和索引取得参数addfunc = &#123;$0 + $1&#125;// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号addfunc = (+) 6. Trailing(尾行)闭包如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性 func someFunctionThatTakesAClosure(a: Int, closure: () -&gt; ()) &#123; // 函数体部分&#125;// 1. 一般形式someFunctionThatTakesAClosure(10, closure: &#123; // 闭包主体部分&#125;)// 2. Trainling闭包的方式someFunctionThatTakesAClosure(10) &#123; // 闭包主体部分&#125;// 3. 如果没有其他参数时，可以省略括号someFunctionThatTakesAClosure &#123; // 闭包主体部分&#125; 7. Escaping（逃逸）闭包如果一个闭包/函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加@escaping声明，来声明该闭包/函数允许从函数中”逃逸”，如下 var completionHandlers: [() -&gt; Void] = []// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 逃逸闭包只是一个声明，以增强函数的意图 8. 自动闭包对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下 // 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）let sayHello = &#123; print(&quot;hello world&quot;) &#125;//调用闭包函数sayHello() 自动闭包只是闭包的一种简写方式 如果一个函数接受一个不带参数的闭包 func logIfTrue(predicate: () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125; 调用的时候可以使用自动闭包 logIfTrue(predicate: &#123; return 1 &lt; 2 &#125;)// 可以简化returnlogIfTrue(predicate: &#123; 1 &lt; 2 &#125;) 上面代码看起来可读性不是很好，swift引入了一个关键字@autoclosure，简化自动闭包的大括号，在闭包类型前面添加该关键字声明 func logIfTrue(predicate: @autoclosure () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125;// 调用logIfTrue(predicate:1 &lt; 2) @autoclosure 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：@AUTOCLOSURE 和 ?? 9. 常量参数和变量参数默认情况下所有函数参数都是常量，意味着参数是不可变的，我们可以显式的声明参数为变量 func log(msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 会报错，因为msg为常量 print(msg)&#125;func log(var msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 变量参数正常运行 print(msg)&#125; 注：变量参数在swift3被抛弃 10. 输入输出参数在c语言里有指针，可以通过传址直接修改外部变量的值，在swift通过inout关键字声明函数内部可直接修改外部变量，外部通过&amp;操作符取得变量地址 func swap(inout a: Int, inout b: Int) &#123; let temp = a a = b b = temp&#125;var a = 19, b = 3swap(&amp;a, &amp;b) 11. 嵌套函数swift的函数还支持嵌套，默认情况下，嵌套函数对外部不可见，只能在函数内部使用 func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; //定义两个内部函数 func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125; 嵌套函数相当于objc函数内的block 12. defer在swift2.0之后添加了defer关键字，可以定义代码块在函数执行完成之前的完成一些操作，并且在函数抛出错误的时候也可以执行 func test() &#123; print(&quot;begin1&quot;) defer &#123; // 入栈 print(&quot;end1&quot;) &#125; print(&quot;begin2&quot;) defer &#123; // 入栈 print(&quot;end2&quot;) &#125; if true &#123; print(&quot;begin4&quot;) defer &#123; print(&quot;end4&quot;) &#125; print(&quot;begin5&quot;) defer &#123; print(&quot;end5&quot;) &#125; &#125; print(&quot;do balabala&quot;) return&#125; 上面输出结果为 begin1begin2begin4begin5end5end4do balabalaend2end1 通常可以用在需要成对操作的逻辑中（如：open/close） 九、枚举swift的枚举比C语言的枚举更为强大，支持更多特性，swift的枚举更像类和结构体，支持类和结构体的一些特性，与ObjC不同，如果不声明枚举的值，编译器不会给枚举设置默认值 枚举与结构体一样，是值类型 1. 声明和使用// 1. 定义枚举enum CompassPoint &#123; case North case South case East case West&#125;// 2. 可以把枚举值定义在一行，用逗号隔开enum CompassPoint2 &#123; case North, South, East, West&#125;// 3. 像对象一样使用枚举，代码结构更为清晰，枚举更为简短let direction = CompassPoint.East// 4. 如果编译器可以识别出枚举的类型，可以省略枚举名let direction2: CompassPointdirection2 = .East// 5. 如果编译器能确定case命中所有的情况，可以不需要defaultswitch direction &#123;case .East: print(&quot;east&quot;)case .West: print(&quot;west&quot;)case .South: print(&quot;south&quot;)case .North: print(&quot;north&quot;) //所有值都被枚举，则不需要default&#125; 2. 嵌套枚举swift的枚举定义支持嵌套，在使用的时候一层一层引用 enum Character &#123; enum Weapon &#123; case Bow case Sword case Lance case Dagger &#125; enum Helmet &#123; case Wooden case Iron case Diamond &#125; case Thief case Warrior case Knight&#125;let character = Character.Thieflet weapon = Character.Weapon.Bowlet helmet = Character.Helmet.Iron 3. 递归枚举枚举的关联值的类型可以设为枚举自身，这样的枚举称为递归枚举 enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 带递归类型的枚举需要在case前面添加关键字声明indirect，也可以在enum前面加上声明，表示所有的成员是可以递归的 indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 使用递归枚举取值的时候可以使用递归函数 func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)// (5 + 4) * 2let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))print(evaluate(product)) 其实感觉这种嵌套多层的用法可读性并不是特别好，而且在取值的时候还需要递归，通常来说，嵌套一层就够了 4. 原始值与C语言一样，可以为每个枚举指定值，并且可以支持更多类型（Int, Float, Character, String） // 定义枚举，并初始化原始值enum ASCIIControlCharacter: Character &#123; case Tab = &quot;\\t&quot; case LineFeed = &quot;\\n&quot; case CarriageReturn = &quot;\\r&quot;&#125;// 2. 通过两个属性获得原始值var ch = ASCIIControlCharacter.Tabch.hashValue // 获取是否有原始值ch.rawValue // 获得原始值// 3. 通过原始值构造枚举，如果不存在，则返回nilvar tab = ASCIIControlCharacter.init(rawValue: &quot;\\t&quot;)// 4. 如果是原始值是整形值，后面的值默认自增1，如果不指定，则默认为空，而不是从0开始enum Planet: Int &#123; case Mercury = 1, Venus // Venus = 2 case Neptune // Neptune = 3&#125;// 5. 如果没有指定枚举原始值的类型，则默认为空，而不是整型enum CompassPoint &#123; case North case South case East case West&#125;//swift 不会为North, South, East, West设置为0,1,2,3，并且CompassPoint没有原始值（rawValue）// 6. 有原始值的枚举可以通过原始值构造（构造器返回可选类型）let lineFeed = ASCIIControlCharacter(rawValue: &quot;\\n&quot;) 5. 关联值上面我们说到，枚举与类和结构体类似，swift的枚举可以给不同的枚举值绑定关联值，如下 enum Barcode &#123; case UPCA(Int, Int, Int) //条形码，关联一个元组 case QRCode(String) //二维码，关联一个字符串&#125;var productBarcode = Barcode.UPCA(8, 85909_51226, 3)// var productBarcode = .QRCode(&quot;http://www.baidu.com&quot;)switch productBarcode &#123;case .UPCA(let a, let b, let c): //在枚举的时候可以取得关联值 print(&quot;barcode: \\(a)\\(b)\\(c)&quot;)case let .QRCode(value): print(&quot;qrcode: \\(value)&quot;)&#125; 如上面这种轻量的数据，在OC上一般我们可能需要定义两个类实现，而swift的枚举可以轻松的处理这种轻量数据，而减少项目中类的定义和维护 十、类与结构体先来看看结构体和类的一些差异 类是引用类型，结构体为值类型 类使用引用计数管理内存，结构体分配在栈上，有系统管理内存，变量传递的时候，结构体整个拷贝，而类默认只传递引用地址（有些类会进行一些额外的拷贝，详见深拷贝和浅拷贝） 结构体不支持继承，类支持继承 与ObjC不同，swift的结构体可以定义方法 类支持运行时类型检查，而结构体不支持 类有构造器和析构器，结构体只有构造器 常量结构体的成员的值不能改变 实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。 1. 结构体，类定义struct Point &#123; let x: Int let y: Int func printPoint() &#123; print(&quot;x=\\(x), y=\\(y)&quot;) &#125;&#125;class Person &#123; var someObj = NSObject() // 定义属性，并初始化 var name: String // 定义属性，并指定类型 init(name: String) &#123; // 构造函数 self.name = name &#125; func hello() &#123; print(&quot;hello \\(self.name)&quot;) &#125; //析构函数 deinit &#123; print(&quot;dealloc&quot;) &#125;&#125; swift中，许多基本类型如String, Array和Dictionary都是用结构体实现的，意味着在传递的时候都会进行值拷贝，当然swift也对这些类型进行了优化，只有在需要的时候进行拷贝 2. 静态属性，静态方法swift中有两个static和class声明静态变量或方法，其中class只能用在类的方法和计算属性上，其他的都使用static，由于类支持继承，所以使用class声明的静态方法可以被继承，而static声明的静态方法不能被继承 class Person &#123; static var instanceCount: Int = 0 // 声明一个类属性 init () &#123; Person.instanceCount += 1 // 通过类名引用类属性，子类可以访问基类的类属性 &#125; // 使用class声明的静态方法可以被继承 class func overrideableComputedTypeProperty() &#123; print(&quot;\\(Person.instanceCount)&quot;) &#125; // 使用static声明的静态方法不能被继承 static func printInstanceCount() &#123; // 声明一个静态方法 print(&quot;\\(Person.instanceCount)&quot;) &#125;&#125; 类和结构体的声明和用法与类类似，使用static 注意：class只能用来声明计算属性和方法，不能用来声明普通属性 3. 构造器和析构器swift的构造器规则和限制比较多，关于构造器可以参见：这里 析构器相当于objc里面的dealloc方法，做一些需要手动释放资源的操作，析构器与构造器不同，没有参数，定义的时候不需要括号，类在释放的之前会自动调用父类的析构器，不需要主动调用 class Person &#123; deinit &#123; print(&quot;释放额外的资源，如通知&quot;) &#125;&#125; 4. 类型判断在objc中，我们通常使用isKindOfClass, isMemberOfClass, isSubclassOfClass等方法进行类型判断，swift使用is和as判断类型 class Parent &#123;&#125;class Son: Parent &#123;&#125;var s = Son()// isKindOfClassson is Son // trueson is Parent // true// isMemberOfClassson.dynamicType == Son.self // trueson.dynamicType == Parent.self // false// isSubclassOfClass 暂时没找到相关的API //TODO: swift动态性，反射 5. 弱引用与ObjC一样，swift的内存管理也使用引用计数管理，也使用weak声明弱引用变量 class Person &#123; weak var person: Person? = nil&#125; 6. 访问级别在swift中，framework和bundle都被处理成模块 * public：公开，可以被外部访问 * internal：内部，在模块（framework）内部使用，模块外访问不到 * private：只能在当前源文件中使用swift默认的访问级别为Internal，使用的时候只需要在类/变量/函数前面加上访问级别即可 public class Person &#123; class public var peopleCount: Int = 0 // 类变量，通过class声明，类变量使用时使用类名引用 internal var age: Int // 实例变量 var name: String // 不声明，则为internal init() &#123; self.age = 0 self.name = &quot;&quot; Person.peopleCount++ // 使用静态变量 &#125; private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 外层访问级别的必须是比成员更高，下面会报警告 class Person &#123; // 默认为internal public var age: Int = 0 // 为public，比类访问级别高，会有警告 private var gender: Int = 10 private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 函数的访问级别要比参数(或泛型类型)的访问级别低，否则会报警告 private class PrivatePerson &#123; private var age: Int = 0 var gender: Int = 10 // 报警告 private func sayHello() &#123; &#125;&#125;public class Test &#123; public func test(person:PrivatePerson) &#123; //报编译错误：这里参数访问级别为private，所以函数访问级别不能高于private，则只能为private &#125;&#125; 枚举类型的成员访问级别跟随枚举类型，嵌套类型默认最高访问级别为internal（外层为public，内层默认为internal） public enum CompassPoint &#123; case North // 四个枚举成员访问级别都为public case South case East case West&#125; 子类访问级别不能高于父类（包括泛型类型），协议继承也同理，子协议访问级别不能高于父协议 class Parent &#123;&#125;public class Son: Parent &#123; // 报编译错误：Son访问级别必须低于Parent，应该为internal或private&#125; 元组的访问级别为元组内所有类型访问级别中最低级的 class Parent &#123;&#125;private class Son: Parent &#123;&#125;public class SomeClass &#123; internal let sometuple = (Son(), Parent()) // 报编译错误：sometuple的访问级别不能高于成员类型的访问级别，由于Son为private，故sometuple必须为private&#125; 变量的访问级别不能高于类型 private class PrivateClass &#123;&#125;public class SomeClass &#123; public var value: PrivateClass // 报编译错误：变量value的访问级别不能高于其类型，故value必须声明为private&#125; 属性的 Setter 访问级别不能高于 Getter访问级别 public class SomeClass &#123; private(set) var num = 1_000_000 // 声明属性num，getter访问级别没有声明，默认为Internal，setter访问级别为private private internal(set) var name = &quot;bomo&quot; // 报编译错误：属性name的setter访问级别为internal，高于getter访问级别private&#125; 协议与类的访问级别关系 协议中所有必须实现的成员的访问级别和协议本身的访问级别相同 其子协议的访问级别不高于父协议（与类相同） 如果类实现了协议，那类的访问级别必须低于或等于协议的访问级别 类型别名访问级别与类型的关系 类型别名的访问级别不能高于原类型的访问级别； 函数构造函数默认访问级别为internal，如果需要给其他模块使用，需显式声明为public 注意：swift的访问级别是作用于文件（private）和模块的（internal）的，而不只是类，所以只要在同一个文件内，private访问级别在不同类也可以直接访问，例如我们可以通过子类包装父类的方法以改变访问级别 public class A &#123; private func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; // 在同一个文件，改变someMethod的访问级别 super.someMethod() &#125;&#125; 7. 属性 使用关键字lazy声明一个懒加载 变量 属性，当属性被使用的时候（get），才会进行初始化 set方法的访问级别必须必get方法低 声明属性的时候可以使用private(set)和internal(set)改变set方法默认的访问级别 每个实例都有一个self属性，指向实例自身，通常在属性与函数参数有冲突的时候使用 对于常量属性，不许在定义它的类的构造器中赋值，不能再子类赋值 class DataImporter &#123;&#125;class DataManager &#123; // 1. 只有第一次调用importer的get方法的时候才会初始化 lazy var importer = DataImporter() var data = [String]()&#125;class Rectangle &#123; var width: Double = 0.0 var height: Double = 0.0 // 2. 声明get方法和set方法的访问级别 private private(set) var weight: Double = 0 // 3. 自定义get/set方法 var square: Double &#123; get &#123; return (self.width + self.height)/2; &#125; //set &#123; //如果不指定名称，默认通过newValue使用新值 set(newValue) &#123; self.width = newValue/2.0; self.height = newValue/2.0 &#125; &#125; // 4. 只读属性，可以省略get，直接使用一个花括号 var perimeter: Double &#123; return (self.width + self.height) * 2 &#125; // 5. 属性监视器，在初始化的时候不会触发 var someInt: Int = 0 &#123; willSet &#123; //用法与set一样如果不指定名称，默认通过newValue使用旧值 print(&quot;set方法之前触发&quot;) &#125; didSet &#123; //用法与set一样如果不指定名称，默认通过oldValue使用旧值 print(&quot;set方法完成后触发，可以在这里设置obj的值覆盖set方法设置的值&quot;) self.someInt = 0 // someInt的值永远为0，在监视器修改属性的值不会导致观察器被再次调用 &#125; &#125;&#125; 使用lazy声明的属性不是线程安全的，在多线程情况下可能产生多份，需要自己控制 对于结构体，与OC不同，swift的结构体允许直接对属性的子属性直接修改，而不需要取出重新赋值 someVideoMode.resolution.width = 1280 在oc上需要这样做 var resolution = someVideoMode.resolutionresolution.width = 1024someVideoMode.resolution = resolution 8. 继承我们都知道，在oc里所有的类都继承自NSObject/NSProxy，而在swift中的类并不是从一个通用的基类继承的，所有没有继承其他父类的类都称为基类 class Parent &#123; final var gender = &quot;unknown&quot; init(gender: String) &#123; self.gender = gender &#125; private func hello() &#123; print(&quot;parent hello&quot;) &#125;&#125;class Son: Parent &#123; // 重写可以改变父类方法的访问级别 internal override func hello() &#123; // 重写父类方法必须加上override，否则会报编译错误 //super.hello() // 可以通过super访问父类成员，包括附属脚本 print(&quot;son hello&quot;) &#125;&#125; 重写属性的时候，如果属性提供了setter方法，则必须为提供getter方法如果重写了属性的setter方法，则不能重写willSet和didSet方法如果重写了willSet和didSet方法，则不能重写get和set方法 父类的属性，方法，类方法，附属脚本，包括类本身都可以被子类继承和重写，可以通过final约束限制子类的重写（final class, final var, final func, final class func, 以及 final subscript） class Parent &#123; final var gender = &quot;unknown&quot; // 不允许被子类重写 var name: String // 可以被子类重写 init(gender: String) &#123; self.gender = gender self.name = &quot;&quot; &#125; final func hello() &#123; // 不允许被重写 print(&quot;parent hello&quot;) &#125;&#125; swift编译器在识别数组类型的时候，如果数组元素有相同的基类，会被自动识别出来 class Person &#123;&#125;class Teacher: Person &#123;&#125;class Student: Person &#123;&#125;let t1 = Teacher()let t2 = Teacher()let s1 = Student()let s2 = Student()let people = [t1, t2, s1, s2] // people会被识别为[Person]类型 向下类型转换as!, as?，as!返回非可选类型，如果类型不匹配会报错，as?返回可选类型，如果类型不匹配返回nil for person in people &#123; if let teacher = person as? Teacher &#123; println(&quot;teacher&quot;) &#125; else if let student = person as? Student &#123; println(&quot;student&quot;) &#125;&#125; 9. 附属脚本subscript附属脚本可以让类、结构体、枚举对象快捷访问集合或序列，而不需要调用使用对象内的实例变量引用，看下面实例 class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:]&#125;// 如果需要使用DailyMeal的meals对象的，需要这么用var dailyMeal = DailyMeal()dailyMeal.meals[MealTime.Breakfast] = &quot;Toast&quot; 使用附属脚本可以直接通过类对象索引访问meals的值 class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:] // 定义附加脚本，类似属性 subscript(realMealTime: MealTime) -&gt; String &#123; get &#123; if let value = meals[realMealTime] &#123; return value &#125; else &#123; return &quot;unknown&quot; &#125; &#125; set(newValue) &#123; meals[realMealTime] = newValue &#125; &#125;&#125;var dailyMeal = DailyMeal()dailyMeal[.Breakfast] = &quot;sala&quot;print(dailyMeal[.Breakfast]) 附加脚本还支持多个参数 struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: 0.0) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) grid[(row * columns) + column] = newValue &#125; &#125;&#125;var matrix = Matrix(rows: 2, columns: 2)matrix[0, 1] = 1.5matrix[1, 0] = 3.2 附加脚本类似属性，拥有get/set方法，支持只读和读写两种方式，附加脚本也支持多个参数，附属脚本可以屏蔽外部对内部对象的直接访问，隐藏对象内部的细节，提高封装度，使得代码更加健壮和简洁 10. 类型嵌套与枚举一样，结构体和类都支持类型嵌套，可以在类里面再定义类/结构体/枚举 class SomeClass &#123; // 类里面嵌套定义枚举 enum Suit: Character &#123; case Spades = &quot;♠&quot;, Hearts = &quot;♡&quot;, Diamonds = &quot;♢&quot;, Clubs = &quot;♣&quot; // 枚举里面嵌套定义结构体 struct Values &#123; let first: Int, second: Int &#125; &#125; // 类里面嵌套定义结构体 struct Point &#123; let x: Int let y: Int &#125; // 类里面嵌套定义类 class InnerClass &#123; var name: String = &quot;&quot; var id: Int = 0 &#125;&#125;// 使用的时候像属性一样引用let values = SomeClass.Suit.Values(first: 1, second: 2) 11. 类型别名swift类型别名与c语言中取别名有点像，通过关键字typealias声明别名 public typealias MyInt = Intfunc add(a: MyInt, b: MyInt) -&gt; MyInt &#123; return a + b&#125; 通常在容易出现命名冲突的情况下会考虑使用类型别名 十一、扩展Extension与oc一样，扩展就是对已有的类添加新的功能，与oc的category类似，swift的扩展可以： 提供新的构造器（需要符合构造器的基本规则） 添加实例计算型属性和类计算性属性 添加实例方法和类方法 添加附加脚本 添加新的嵌套类型 使一个已有类型符合某个接口 swift扩展不可以： 不可以添加存储属性 不可以向已有属性添加属性观测器(willSet, didSet) class Person &#123; func hello() &#123; print(&quot;hello&quot;) &#125;&#125;// 定义扩展extension Person &#123; func fly() &#123; print(&quot;fly&quot;) &#125;&#125;let p = Person()p.fly() 扩展也可以作用在结构体和枚举上 struct Rectangle &#123; let width: Double let height: Double&#125;extension Rectangle &#123; var perimeter: Double &#123; return 2 * (self.width + self.height) &#125;&#125;let rect = Rectangle(width: 100, height: 200)print(rect.perimeter) 扩展内的成员定义与类类似，这里不再说明 扩展属性由于swift不能扩展新的属性，有时候我们希望给类添加属性，在oc里可以用关联属性新增存储属性，在swift也可以，需要引入ObjectiveC模块 import ObjectiveCclass Point &#123; var x: Int = 0 var y: Int = 1&#125;private var xoTag: UInt = 0extension Point &#123; var z: Int &#123; get &#123; return objc_getAssociatedObject(self, &amp;xoTag) as! Int &#125; set(newValue) &#123; objc_setAssociatedObject(self, &amp;xoTag, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125; 十二、协议Protocalswift的协议在oc的基础上加了更多的支持，可以支持属性，方法，附加脚本，操作符等，协议的属性必须为变量var protocol SomeProtocol &#123; // 属性要求 var mustBeSettable: Int &#123; get set &#125; // 只读属性 var doesNotNeedToBeSettable: Int &#123; get &#125; // 只读静态属性 static var staticProperty: Int &#123; get &#125; // 静态方法 static func hello()&#125; 1. mutating在结构体/枚举中的值类型变量，默认情况下不能对其进行修改，编译不通过，如果需要修改值类型的属性，需要在方法声明前加上mutating struct Point &#123; var x: Int var y: Int func moveToPoint(point: Point) &#123; self.x = point.x // 报错：不能对值类型的属性进行修改 self.y = point.y // 报错：不能对值类型的属性进行修改 &#125; mutating func moveToPoint2(point: Point) &#123; self.x = point.x // 编译通过 self.y = point.y // 编译通过 &#125; //可变方法还可以对self进行修改，这个方法和moveToPoint2效果相同 mutating func moveToPoint3(x deltaX: Int, y deltaY: Int) &#123; self = Point(x:deltaX, y:deltaY) &#125;&#125; 可变方法还可以修改枚举值自身的值 enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125; 特别是在定义Protocal的时候，需要考虑到协议可能作用于枚举或结构体，在定义协议的时候需要在方法前加上mutating protocol SomeProtocol &#123; mutating func moveToPoint(point: Point)&#125; 2. 协议类型协议虽然没有任何实现，但可以当做类型来用，与oc的protocal类似，用协议类型表示实现了该协议的对象，与oc的id&lt;SomeProtocol&gt;一样 3. 协议组合有时候我们需要表示一个对象实现多个协议，可以使用协议组合来表示，如下 protocol SwimProtocal &#123; func fly()&#125;protocol WalkProtocal &#123; func walk()&#125;func through(animal: protocol&lt;WalkProtocal, SwimProtocal&gt;) &#123; animal.walk() animal.fly()&#125; 4. 自身类型有时候我们需要表示实现协议的类型，可以使用Self代替，如下 protocol CompareProtocal &#123; // Self表示实现协议自己的类型本身 func compare(other: Self) -&gt; Bool&#125;class Product: CompareProtocal &#123; var id: Int = 0 func compare(other: Product) -&gt; Bool &#123; return self.id == other.id &#125;&#125; 5. @objc协议swift声明的协议是不能直接被oc的代码桥接调用的，如果需要，需要在声明前加上@objc，使用@objc声明的协议不能被用于结构体和枚举 import Foundation@objc protocol HasArea &#123; // 协议可以被桥接到oc中使用 var area: Double &#123; get &#125;&#125; 6. Optional要求在oc中的protocal可以定义可选方法，在swift默认不支持可选方法，swift只有在添加了@objc声明的协议才能定义可选方法，在定义前添加optional声明 import Foundation@objc protocol HasArea &#123; optional var area: Double &#123; get &#125; // 定义可选属性&#125; 十三、错误与其他高级语言异常处理有点类似，swift引入了错误的机制，可以在出现异常的地方抛出错误，错误对象继承自Error，抛出的错误函数会立即返回，并将错误丢给调用函数的函数处理，如果一个函数可能抛出错误，那么必须在函数定义的时候进行声明，如下 //定义错误类型enum OperationError: Error &#123; case DivideByZero case Other&#125;//定义可能抛出异常的函数，在函数声明的返回值前面加上throwsfunc divide(a: Int, b: Int) throws -&gt; Float &#123; if b == 0 &#123; throw OperationError.DivideByZero &#125; return Float(a) / Float(b)&#125;//调用可能出错的函数（调用出必须加上try）do &#123; let result = try divide(a: 10, b: 0) print(result)&#125; catch OperationError.DivideByZero &#123; print(error)&#125; catch &#123; //其他错误&#125; 如果错误是一个对象，而不是枚举，可以用let绑定到变量上 do &#123; try divide(a: 10, b: 0)&#125; catch let err as SomeErrorType &#123; print(err.message)&#125; catch &#123; print(&quot;other error&quot;)&#125; 如果不处理错误的话可以使用try?，使用try?关键字的方法会被包装到一个可选类型中，如果发生错误，则会返回nil，如下面序列化的例子 func serialize(obj: AnyObject) -&gt; String &#123; guard let jsonString = try? someSerializeFuncMayThrowError(obj) else &#123; print(jsonString) &#125; print(&quot;fail&quot;)&#125; try?配合guard let一起使用效果更好 十四、断言断言可以让我们在调试时候更好的发现问题，排查错误，几乎所有的高级语言都支持断言，swift也如此，断言的代码在release的时候回被忽略，不会影响发布程序的性能，只会在调试的时候生效 // 如果age小于0，程序会停止，并输出错误信息assert(age &gt;= 0, &quot;A person&#x27;s age cannot be less than zero&quot;) 十五、泛型关于泛型的介绍，这里不进行说明，swift的泛型是我认为最酷的特性之一，当然其他语言也有，可以让类或函数更大程度的重用，swift的泛型与其他语言的泛型有点类似 1. 定义在类或函数声明的时候，指定一个泛型类型参数（通常为T）然后使用的时候直接把T当成类型使用 //泛型函数定义func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) &#123; let temporaryA = a a = b b = temporaryA&#125;//泛型类定义class Result&lt;T&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T?&#125;//多个泛型类型参数class Result&lt;T, TK&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T? var subData: TK?&#125; 2. 泛型约束我们还可以对泛型进行约束，泛型类型参数只能是某些类型的子类，或实现了某些协议 func findIndex&lt;T&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 上面函数会报编译错误，因为在swift里，并不是所有的类都能用==操作符比较，只有实现了Equatable协议的类才能用==操作符，修改为 func findIndex&lt;T: Equatable&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 3. 多泛型类型参数有时候我们需要用多个协议进行约束，可以使用下面方式（类与函数的使用方式类似） func someFunc&lt;T : protocol&lt;StudyProtocal, RunProtocal&gt;&gt;(arg: T) &#123; // do stuff&#125; 如果约束既有类又有协议的话可以使用where添加限制条件 func someFunc&lt;T, TK where T:Student, T: StudyProtocal&gt;(t: T, tk: TK) &#123; // do stuff&#125; 4. 泛型是不可变的var dog1 = SomeClass&lt;Parent&gt;()var dog2 = SomeClass&lt;Son&gt;()dog1 = dog2 // 报错 关于可变，不可变，逆变，协变参考这里：http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/ 5. 泛型协议swift的协议不支持泛型，不能像类一样定义泛型，而是通过类型参数定义泛型 protocol GenericProtocol &#123; associatedtype T1 associatedtype T2 func someFunc(t2: T2) -&gt; T1&#125;class SomeClass&lt;T&gt; : GenericProtocol &#123; // 设置泛型类型 typealias T1 = String typealias T2 = T func someFunc(t2: T2) -&gt; T1 &#123; return &quot;&quot; &#125;&#125; 十六、运算符重载与其他高级语言的一样，swift也提供了运算符重载的功能，我们可以自定义运算符的实现，运算符通常分为三种类型 单目运算符：&lt;运算符&gt;&lt;操作数&gt;或&lt;操作数&gt;&lt;运算符&gt;，如!a 双目运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：1 + 1 三元运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：a ? b : c swift的运算符重载 支持自定义运算符/, =, -, +, *, %, &lt;, &gt;, !, &amp;, |, ^, ., ~的任意组合。可以脑洞大开创造颜文字。 不能对默认的赋值运算符=进行重载。组合赋值运算符可以被重载，如==，!==! 无法对三元运算符a ? b : c进行重载 运算符声明和定义只能定义在全局作用域，不能定义在类/结构体/枚举内 1. 前缀，中缀，后缀运算符 前缀prefix：默认的有-，!，~等 中缀infix：默认的有+，*，==等 后缀postfix：默认的有：++，–等 1.1 声明运算符如果实现不存在的运算符需要添加运算符声明（系统的提供的，可以不需要声明），声明必须放在全局作用域 // 前缀运算符prefix operator +++ &#123;&#125;// 中缀运算符（二元运算符）infix operator +++ &#123;&#125;// 后缀运算符postfix operator +++ &#123;&#125; 1.2 实现上面三个运算符// 定义Point结构体struct Point &#123; var x: Int var y: Int&#125;// 重载操作符要放在全局作用域func +++ (left: Point, right: Point) -&gt; Point &#123; return Point(x: left.x + right.x, y: left.y + right.y)&#125;// 如果需要修改操作数，需要添加inout关键字prefix func +++ (inout left: Point) &#123; left.x += 1 left.y += 1&#125;postfix func --- (right: Point) -&gt; Point &#123; return Point(x: right.x - 1, y: right.y - 1)&#125; 1.3 使用var p1 = Point(x: 12, y: 21)var p2 = Point(x: 12, y: 2)let p3 = p1+++p2 // p3.x = 24, p3.y = 23+++p1 // p1.x = 13, p1.y = 3p1--- // p1.x = 12, p1.y = 2 2. 优先级这个很好理解，就是优先级高的运算符先执行，声明运算符的时候可以指明优先级 infix operator ^ &#123; associativity left // 结合性，后面说 precedence 140 // 指定运算符优先级&#125; 这里可以查看默认运算符的优先级 3. 结合性运算符还可以定义结合性，对于双目运算符，当优先级一样的时候，可以定义运算符优先进行左结合还是右结合，运算符的结合性有下面三种 left：左结合 right：右结合 none：无 结合性设置为left // 定义一个双目操作符infix operator ^ &#123; associativity left // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为256// 相当于let aa = ((2 ^ 2) ^ 2) ^ 2 如果我们设置结合性为right // 定义一个双目操作符infix operator ^ &#123; associativity right // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为65536// 相当于let aa = 2 ^ (2 ^ (2 ^ 2)) 如果结合性设置为none，则会报错，无法判断 十七、命名空间在很多语言里面，都有命名空间的概念，可以分离代码，防止命名冲突，而swift也有类似命名空间的概念，通过访问级别实现命名空间//TODO 十八、参考链接 运算符结合性 Swift高级运算符 十九、总结总的来说，swift还是比较装逼的，整个很多新名词，新概念，例如，指定构造器，便利构造器，构造器代理，但其实这些东西在别的语言基本上有，没那么复杂，另外swift的关键字太多了，有些可有可无，是不是苹果看到什么好的就想往swift里面塞还是怎么着，另外感觉苹果还是太装逼了，例如do-while非要偏偏要搞成repeat-while啥的，个人感觉编程语言应该是轻便，简单，当然，并且能满足所有需求的，反正，没什么特别的好感","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://fangliquan.github.io/tags/swift/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"},{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"},{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"},{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/categories/xcode/"},{"name":"blog","slug":"blog","permalink":"http://fangliquan.github.io/categories/blog/"}],"tags":[{"name":"iOS面试","slug":"iOS面试","permalink":"http://fangliquan.github.io/tags/iOS%E9%9D%A2%E8%AF%95/"},{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"},{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"AVAudioSession","slug":"AVAudioSession","permalink":"http://fangliquan.github.io/tags/AVAudioSession/"},{"name":"AudioSessionProperty","slug":"AudioSessionProperty","permalink":"http://fangliquan.github.io/tags/AudioSessionProperty/"},{"name":"支付宝SDK","slug":"支付宝SDK","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9DSDK/"},{"name":"支付宝","slug":"支付宝","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"},{"name":"多线程","slug":"多线程","permalink":"http://fangliquan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/tags/xcode/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"NSThread","slug":"NSThread","permalink":"http://fangliquan.github.io/tags/NSThread/"},{"name":"GCD","slug":"GCD","permalink":"http://fangliquan.github.io/tags/GCD/"},{"name":"iOS视频播放器","slug":"iOS视频播放器","permalink":"http://fangliquan.github.io/tags/iOS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"},{"name":"blogs","slug":"blogs","permalink":"http://fangliquan.github.io/tags/blogs/"},{"name":"hexo","slug":"hexo","permalink":"http://fangliquan.github.io/tags/hexo/"},{"name":"iOS多图文","slug":"iOS多图文","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E5%9B%BE%E6%96%87/"},{"name":"图文混排","slug":"图文混排","permalink":"http://fangliquan.github.io/tags/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/"},{"name":"Frame模型","slug":"Frame模型","permalink":"http://fangliquan.github.io/tags/Frame%E6%A8%A1%E5%9E%8B/"},{"name":"runtime","slug":"runtime","permalink":"http://fangliquan.github.io/tags/runtime/"},{"name":"iOS9新特性","slug":"iOS9新特性","permalink":"http://fangliquan.github.io/tags/iOS9%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"swift","slug":"swift","permalink":"http://fangliquan.github.io/tags/swift/"}]}