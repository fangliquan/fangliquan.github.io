<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fangliquan.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS,Windows开发者">
<meta property="og:type" content="website">
<meta property="og:title" content="microleo的个人博客">
<meta property="og:url" content="http://fangliquan.github.io/index.html">
<meta property="og:site_name" content="microleo的个人博客">
<meta property="og:description" content="iOS,Windows开发者">
<meta property="og:locale">
<meta property="article:author" content="microleo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fangliquan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>microleo的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="microleo的个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">microleo的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工作学习中的学习笔记及技术积累</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-exclamation-circle fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/" class="post-title-link" itemprop="url">2021-03-14-iOS面试整理(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Post created:2021-03-16 11:48:09 / Post modified:11:48:55" itemprop="dateCreated datePublished" datetime="2021-03-16T11:48:09+08:00">2021-03-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>91 组件化<br>1.底基层(放置最基础,最常用的相关库)<br>—MMBaseFoundation<br>—baseCypto<br>2.底层基础层(主要提供各种基础功能(网络库,数据库, im等))<br>—MFDB<br>—SDWebimage<br>3.底层应用层(提供各种通用代理等)<br>—DNS<br>—MDAnalyzeRecord<br>4.业务基础层<br>—momokit<br>—MDWebview<br>5.业务应用层(封装一些通用业务的功能)<br>—大图预览</p>
<p>70 pod库循环引用怎么解决<br>如何检测？  Pod install就会报错，<br>解决方案，分层，通过代理解决</p>
<p>71 防Crash 方案<br>1.UI非主线程刷新<br>setNeedsLayout、setNeedsDisplay、setNeedsDisplayInRect:、setNeedsUpdateConstraints四个方法，判断当前是否是主队列，如果不是主队列，则跳转到dispatch_get_main_queue执行。<br>2.KVO 非对称添加删除<br>hook了NSObject的addObserver:forKeyPath:options:context:、removeObserver:forKeyPath:。为被观察对象增加一个map属性，存储所有的observer和keypath的对应关系。每次添加或者删除观察者的时候，都会先去检查observer的keypath是否已存在或者消失，在执行相当逻辑。避免重复添加或者删除<br>3.unrecognized selector<br>forwardingTargetForSelector<br>4.container类型crash, 数组越界</p>
<p>计算机基础</p>
<p>69 mp3和wav的区别</p>
<p>Wav是无损音乐的一种, 文件较大, 和CD格式一样, 44.1k的取样频率, 最接近无损的音乐格式<br>Mp3文件通过对音频进行编码, 去掉了某些部分, 节省空间<br>Pcm 数据是最原始的音频数据, 完全无损. pcm是没有压缩的编码方式 ,Wav是使用pcm编码的一种音频格式. Wav就是pcm+文件头</p>
<p>68 HTTP2.0 和 HTTP1.1的区别<br>—多路复用, 现在只是并发请求, 相互之间没有影响<br>—首部压缩<br>—流量控制</p>
<p>48 HTTPS</p>
<p>HTTPS是HTTP协议+SSL/TLS协议. 让HTTP先和SSL通信, 再由SSL和服务器通信,  (私钥还是公钥)</p>
<p>HTTPS的采用了混合的加密机制, 使用非对称秘钥加密方式, 传输对称秘钥秘钥加密方式所需要的key, 获取到key后, 在使用对称秘钥加密方式进行通讯, 从而保证效率</p>
<p>如何连接的?, 秘钥怎么交换<br>客户端连接上服务器, 服务器发送CA证书给客户端, 客户端随机生成会话秘钥K, 用CA证书加密, 然后发给服务端, 服务器用自己的私钥解密得到会话秘钥K, 然后用秘钥K进行通信</p>
<p>RSA非对称加密<br>AES对称加密</p>
<p>TCP协议的三次握手和四次挥手<br>客户端和服务器端的通信其实和人与人之间的通信是一样的, 假设两个人相互确认对方<br>三次握手</p>
<p>第一次握手: 客户端给服务发送一个SYN报文, 此时客户处于SYN_SEND状态<br>第二次握手: 服务器收到SYN报文后, 会以自己的SYN报文作为应答, 同时也会以客户端ISN+1作为ACK的值, 表示自己已经收到了客户端的SYN, 此时服务器处于SYN_REVD的状态<br>第三次握手: 客户端收到SYN报文之后, 会发送一个ACK报文, 也是一样把服务器的ISN+1作为ACK的值, 标识已经收到服务器的SYN报文</p>
<p>三次握手可以携带数据吗?<br>第三次可以, 前两次不可以</p>
<p>四次挥手<br>第一次挥手:客户方发送一个FIN报文, FIN=1, 并停止在发送数据,<br>第二次挥手: 服务器收到FIN之后, 会发送ACK报文, 且把客户端的序列号值+1作为ACK报文的序列号<br>第三次挥手:服务器发送FIN报文<br>第四次挥手:客户端收到FIN之后, 一样会发送一个ACK报文作为应答, 且把服务端的序列号值+1. 服务器收到ACK之后, 处于关闭状态, 客户端会在发出确认报文之后, 进入时间等待, 经过2MSL后, 客户端才进入closed状态</p>
<p>为什么连接只用三次握手, 而断开连接却要四次挥手?<br>Tcp 链接是一种全双工传输模式, 既是数据的发送方也是数据的接收方, 所以需要两端都完成数据传输之后在断开, 保证链接释放的可靠性<br>首先, 当客户端数据已发送完毕, 且知道服务器也全部接受到时, 就会去断开连接即向服务器端发送FIN<br>服务器端收到客户端的FIN, 为了标识接收到了, 就会向客户端发送ACK<br>但此时, 服务器可能还在发送数据, 并没有关闭TCP窗口的意思, 所以服务器的FIN和ACK并不是同步发的, 只有当数据发送完, 才会发送FIN</p>
<p>综上所述, 服务器的FIN和ACK需要分开发, 并不是像三次握手那样, SYN可以和ACK同步发, 所以就需要四次挥手</p>
<p>TCP和UDP的区别<br>    0.    基于链接与无连接<br>    0.    对系统资源的要求(TCP较多, UDP较少)<br>    0.    Udp 程序结构较简单<br>    0.    流模式与数据包模式<br>    0.    Tcp保证数据正确性, UDP可能丢包<br>    0.    TCP 保证数据顺序 UDP不保证</p>
<p>HTTP状态码<br>1XX: 请求正在处理<br>2XX: 请求正常处理完毕<br>3XX: 重定向<br>4XX: 客户端错误状态码  404 notFound<br>5XX: 服务器错误  500 Internal server error 服务器正在执行请求时发生错误</p>
<p>对称加密: DES<br>非对称加密 RSA</p>
<p>http请求头和响应头<br>常用的请求头<br>accept: <em>/</em> 可以处理所有类型<br>accept-encoding<br>accept-language<br>connection:keep-alive<br>host:<br>UA<br>cookie:<br>range</p>
<p>响应头<br>Content-type:告诉客户端资源文件的类型<br>connection:keep-alive</p>
<p>七层设计模式, 对应做什么的<br>应用层-HTTP协议 FTP协议<br>表示层-数据的编码解码, 将设备固有的数据格式转换为网络标准传输格式<br>会话层—三次握手,四次挥手在这里完成的<br>传输层—TCP/UDP<br>网络层-根据网络设备地址路由数据包, 地址解析, ip<br>数据链路层—物理地址寻址, 流量控制, 重发<br>物理层:物理设备</p>
<p>5层<br>应用层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
<p>78 多态<br>子类通过覆盖或重载父类的方法, 使得对同一类对象统一方法的调用产生不同的结果</p>
<p>77 设计模式  java里面有23中, 但是不一定能映射到ios上面<br>单例模式,<br>工厂方法模式<br>观察者模式<br>抽象工厂模式</p>
<p>工厂模式<br>在工厂模式中, 可以根据参数的不同返回不同类的实例. 简单工厂模式专门定义一个类来负责创建其他类的实例. 被创建的实例通常都具有共同的父类</p>
<p>抽象工厂模式生产的事多个不同类型的类, 所以必须将公共点抽象出来</p>
<p>普通工厂产出是一个产品（实例），抽象工厂产出是一个抽象（接口）。区别在于，若添加一个新的产品，前者是修改工厂，后者是创建新工厂（符合“闭合原则”）。</p>
<p>设计模式6大原则<br>1.单一责任原则<br>—一个类就干一类事情, 不要耦合<br>2.开放封闭原则<br>—类,函数等应该是可以拓展的, 但是不可修改<br>3.里式替换原则<br>—只要父类能出现的地方, 子类也能出现, 反之, 父类则未必能胜任<br>4.依赖倒置原则<br>—高层模块不应该依赖于底层模块<br>5.接口隔离原则<br>—建立单一接口, 不要建立庞大臃肿的接口<br>6.迪米特法则<br>—迪米特法则又叫做最少知道原则, 就是一个类对自己依赖的类知道的越少越好. 对于被依赖的类来说, 无论逻辑多么复杂, 都尽量地将逻辑封装在类的内部, 对外提供public放阿飞, 不对外泄漏任何信息. 迪米特发着还有个简单的定义, 只与直接的朋友通信<br>解决方案: 尽量降低类与类之间的耦合</p>
<p>31 数据库索引<br>唯一索引和普通索引使用的都是B-Tree, 执行时间复杂度都是O(logn)<br>普通索引: 由关键字Key或INDEX定义的索引, 唯一任务是加快数据的访问速度. 应该为那些经常出现在查询条件或排序条件中的数据列创建索引. 被索引的数据列包含重复的值<br>唯一索引:确定某个数据列将至包含彼此各不相同的值, 那就应该用关键字 UNIQUE把它定义为一个唯一索引. 好处是, 1.简化了对索引的管理工作, 这个索引也因此而变得更有效率. 二是, 数据库会在有新纪录插入数据表是, 自动检查新纪录的这个字段的值是否已经在某个记录的字段里出现过. 唯一索引既可以保证数据的重复出现, 又可以提高访问速度<br>主键索引: 唯一索引的特殊类型</p>
<p>主键和索引的区别<br>    0.    对于主键, oracle, sql, musql都会自动建立唯一索引<br>    0.    主键课作为外键, 唯一索引不可<br>    0.    主键不可为空, 唯一索引可以<br>    0.    主键也可以是多个字段的组合<br>    0.    主键和唯一索引不同的是, A 有not null属性, B,每个表只能有一个</p>
<p>61 git 原理, git 的各种命令</p>
<p>Git 是一种分布式版本控制系统</p>
<p>从本质上讲, git是一套内容寻址的文件系统, 他存储的也是key-value键值对, 然后根据key值来寻找value. git根据指针来寻址的, 这些指针就存储在git对象中.git共有三种对象, commit对象, tree对象, blob对象</p>
<p>Git的核心是它的对象数据库, 其中保存了git的对象, 其中最重要的事blob(数据对象), tree和commit对象. blob对象实现了对文件内容的记录, tree对象实现了对文件名,文件目录结构的记录, commit对象实现了对版本提交时间, 版本作者, 版本序列,版本说明等附加信息的记录. 这三类对象, 完美实现了git的基础功能: 对版本状态的记录</p>
<p>Git所做的实质工作是将被改写的文件保存为数据对象, 更新暂存区, 记录树对象, 最后创建一个指明了顶层树对象和父提交的提交对象</p>
<p>Git引用是指指向git对象hash键值. 通过git引用, 我们可以更加方便的定位到某一个版本的提交, git分支, tags等功能都是基于git引用实现的</p>
<p>merge 和 rebase<br>Rebase会把你当前的分支的commit放到公共分支的最后面, 所以叫变基<br>Merge 会把公共分支和当前的commit合并带一起, 形成新的commit提交</p>
<p>82 动态库与静态库的区别<br>静态库是在程序编译时会被链接到目标代码中, 动态库是在程序编译是并不会被链接到目标, 只在程序启动的时候, 加载完mach-o文件后才会加载动态库<br>静态库, 以.a和.framwork为文件后缀名, 自建的.framword一般都是静态库. 自己也可以修改<br>动态库, 以.tbd和.framwork为后缀名(系统直接提供给我们的framework都是动态库)</p>
<p>App启动后, 动态链接器DYLD, 解析app需要的未定义的外部符号external symbols, 在运行时 dynamic loader也会加载哪些被请求的其他库</p>
<p>动态库分为两种<br>动态链接库:在可执行文件被夹在, 动态库也随着被加载到内存中<br>动态加载库:在需要的时候再使用dlopen等通过代码或者命令的方式来加载</p>
<p>88 LLDB 常用的调试命令<br>Po 打印对象, 会调用对象的description方法<br>Expr 可以在调试的时候动态执行指定表达式<br>P 打印对象<br>Bt 打印调用堆栈, 加all 可打印所有thread的堆栈<br>brl 是breakpoint list 的简写</p>
<p>编译原理</p>
<p>76 ios编译过程<br>OC是编译型语言, 先将代码编译成机器码, 再加以运行. 好处就是运行速度快, 缺点就是开发,调试比较长. c++, OC, swift c java<br>解释型语言开发调试比较短, 运行速度慢, 一遍由相应语言的解释器翻译成目标代码, 一边执行. Js, python, PHP</p>
<p>Ios采用三相设计.<br>clang+LLVM编译过程<br>Clang编译前端负责语法分析语义分析,生成中间代码. 编译器后端会进行机器无关的代码优化, 生成机器语言, 并进行机器相关的代码优化, 不同的cpu生成不同的机器码</p>
<p>在预编译阶段. 会做宏替换,删除注释, 头文件引入. 然后将文件转成语法树, 编译器会根据这可语法树, 做一些额外的操作以找出可能存在的错误<br>1.类型检查.即检查程序中是否有类型错误<br>2.检查变量定义了但是未使用. 就是我们看到的warning<br>3.编译, 将AST转换为更低级的中间码(LLVM IR), 对生成的中间码做优化, 生成特定目标代码, 输出汇编代码<br>4.汇编: 将汇编代码转换成目标对象文件<br>5.链接, 将多个目标对象文件合为一个可执行文件<br>6.生成可执行文件 mach-o</p>
<p>编译原理<br>1.词法分析—对字节流进行扫描和分享, 从而识别出一个个单词(token)序列的过程<br>2.语法分析—将单词序列分解成各类语法短语(语法树AST)<br>3.语义分析—审查程序有无语义错误<br>4.中间代码生成<br>5.代码优化—<br>6.目标代码生成—将中间代码变换成特定机器上的指令代码或汇编指令代码</p>
<p>66 ios在编译的时候做了那些事情</p>
<p>Oc是编译语言. 编译的时候先进行, 语法分析,, 语义分析, 然后对无关的代码优化, 生成机器码.<br>编译语言在执行的时候, 必须先通过编译器生成机器码, 机器码可以直接在cpu上运行, 所以执行效率比较高</p>
<p>词法分析是计算机将字符序列为token序列的过程</p>
<p>84 bitCode 的理解和作用<br>bitCode是LLVM编译器的中间代码的一种编码, 他可以转换为任何被支持的CPU架构, 比如打开bitCode功能提交一个app到应用商店, 以后苹果新出了一款手机并cpu也是全新设计, 一样可以编译转换为新cpu的可执行程序</p>
<p>75 app的启动<br>添加环境变量可以打印出app的启动时间分析<br>App的冷启动可以概括3大阶段<br>—dyld(dynamic link editor) apple的动态连接器, 可以用来装载mach-0文件<br>——启动app时, dyld 所做的事情有<br>———装载app的可执行文件, 同时会递归所有依赖的动态库(如何找到动态库的?)<br>———当dyld把可执行文件, 动态库都装载完毕后, 会通知runtime进行下一步的处理<br>—runtime阶段<br>——启动App, runtime所做的事情有<br>———调用map_images进行可执行文件内容的解析和处理<br>———在load_images中调用call_load_methods,调用所有class和category的+load方法(告诉研发已经加载好了)<br>———进行各种objc结构的初始化(注册objc类,初始化类对象等)<br>———调用c++静态初始化器和<strong>attribute</strong>(constrictor)修饰的函数<br>———到此为止, 可执行文件和动态库中所有的符号(Class,, protocol, selector, IMP)都已经按格式成功加载到内存中, 被runtime所管理<br>—main<br>——调用uoapplicationMain函数, AppDelegate的application:didfinishAltuchingWithOptions方法</p>
<p>优化<br>dyld<br>—减少动态库, 合并一些动态库(定期清理不必要的动态库)<br>—减少Objc类, 分类的数量, 减少selector数量(定期清理不必要的类, 分类)<br>—减少c++虚函数数量<br>—swift进来使用struct</p>
<p>runtime<br>—用+initialize方法和dispatch_once取代所有的<strong>attribute</strong>((constrictor) c++静态构造器, objc的+load)</p>
<p>main<br>—在不影响用户体验的前提下, 尽可能将一些操作延迟, 不要全部都放在finishLaunching方法中<br>—按需加载</p>
<p>72 ios程序的内存布局<br>//运行时分配<br>{<br>栈:局部变量+方法实参<br>堆:通过alloc init创建的对象<br>}<br>//编译时分配<br>{<br>BSS段: 未初始化的全局变量和静态变量<br>数据段:已初始化的全局变量, 静态变量,常量<br>代码段:被编译成二进制的代码<br>}</p>
<p>45 悬挂指针 野指针</p>
<p>悬挂指针: 指针指向的内存已经被释放了, 但指针还存在</p>
<p>野指针: 没有进行初始化的指针</p>
<p>BAD_ACCESS 访问了已经被销毁的内存空间, 就会报这个错误, 根本原因是有悬挂指针没有被释放</p>
<p>iOS基础知识</p>
<p>60 iOS 事件的传递和相应机制<br>Ios只有继承了UIResponder的对象才能接受并处理事件</p>
<p>Uibutton-&gt;uicontrol-&gt;uiview-&gt;uiresponder-&gt;NSObject</p>
<p>uiviewController-&gt;UIResponder-&gt;NSObject</p>
<p>事件的产生和传递<br>    0.    发生触摸事件后, 系统会将该事件加入到一个UIApplicaiton管理的事件队列中<br>    0.    UIApplication会从事件队列中取出最前面的事件, 并将事件分发下去进行处理, 通常先发送事件给应用程序的主窗口<br>    0.    前台App主线程RunLoop收到转发的消息, source0将封装IOHEvent为UIEvent, 然后将UIEvent传递给UIWindow<br>    0.    通过递归调用UIView层级的 hitTest:With 找到对应的view, (hitTest:wtih 底层用有pointInSide 判断是否在点击区域)<br>    0.    找到对应的会调用view 的touchsBegin:withEvent:方法来处理事件. 如果当前第一响应者没有进行出出力, 系统就将事件传递给响应者中的下一个响应者, 看看是否可以进行处理</p>
<p>控件的点击时机和添加在上面的手势谁先相应<br>    0.    如果当前是普通控件, 比如uiview 会先相应手势事件, 不过手势是需要时间的, 时间传递给了响应链的第一个响应对象, 响应链 uiresponder的touchsBegan:withEvent 方法, 之后手势识别成功, 就回去cancel之前传递到的所有响应对象, 于是就会调用他们的touchesCancelled:withEvent 方法.<br>    0.    UIGestureRecognizer 有个属性cancelsTouchesInView 这个属性默认值是yes, 即当手势识别成功后, 会发送touchesCancelled消息给view来结束view的响应. 如果cancelsTouchesInView为no, 那么gestureRecognizer和view都可以响应<br>    0.    如果控件是uibutton, uiswitch, , 未来防止事件重叠, 先响应控制事件, 并且拦截了手势事件</p>
<p>事件的传递是从上到下(父控制到子控制), 事件的相应是从下到上(顺着响应者链条向上传递, 子控件到父控件)</p>
<p>Uiview 不接受触摸事件的三种情况<br>    0.    userinterfaceEnable = NO;<br>    0.    hidden = yes<br>    0.    alpha = 0.0~0.1</p>
<p>87 ios 如何根据uiview获取所在的uiviewController<br>uiview 和UIVIewcontroller 都是直接继承自UIResponder. responder chain 大概的传递规则就是从视图顶层的uiview向下到uiviewcontroller再到rootviewContooler 再到window最后到application<br>id responder = self.nextResponder;<br>while (![responder isKindOfClass: [UIViewController class]] &amp;&amp; ![responder isKindOfClass: [UIWindow class]])<br>     {<br>        responder = [responder nextResponder];<br>    }<br>    if ([responder isKindOfClass: [UIViewController class]])<br>    {<br>        // responder就是view所在的控制器<br>        // do something<br>    }</p>
<p>64 手势的响应, 单击, 双击的判断, 底层实现<br>-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event<br>{<br>    [NSObject cancelPreviousPerformRequestsWithTarget:self];<br>    UITouch *touch = [touches anyObject];<br>    CGPoint touchPoint = [touch locationInView:self];</p>
<pre><code>if (touch.tapCount == 1) &#123;
    [self performSelector:@selector(handleSingleTap:) withObject:[NSValue valueWithCGPoint:touchPoint] afterDelay:0.3];
&#125;else if(touch.tapCount == 2)
&#123;
    [self handleDoubleTap:[NSValue valueWithCGPoint:touchPoint]];
&#125;</code></pre><p>38 iOS 深浅拷贝</p>
<p>不可变对象, copy 是指针复制, mutablecopy是内容复制<br>NSString copy之后还是同一个NSString  mutableCopy之后是NSMutableString</p>
<p>可变对象, copy是内容复制, mutableCopy 也是内容复制<br>NSMutableString copy 之后是NSString, mutableCopy之后还是NSMutableString</p>
<p>集合的单程深复制,可以用initWithArray:copyItems, 将第一个参数设置为YES即可深复制</p>
<p>如果是完全的深拷贝, 归档实现</p>
<p>NSString 为什么要用copy关键词?<br>当源字符串是不可变类型是, copy strong 都一样<br>当源字符串是可变类型, copy是深拷贝, 会生成一个新对象,  strong修饰的属性, 会随着源字符串的改变而改变. 所以一个类型有可变类型, 在声明不可变属性的时候要用copy</p>
<p>67 block和函数指针的理解<br>函数指针和block都可以实现回调的操作, 声明上也很相似, 实现上都可以看成是一个代码片段<br>不同:函数指针只能指向预先定义好的函数代码块, 函数地址是在编译链接时就已经确定好的. block本质是oc对象, NSObject 的子类, 可以接收消息</p>
<p>39 Block的几种形式</p>
<p>block本质上是一个OC对象, 它内部也有个isa指针. block是封装了函数调用以及函数调用环境的OC对象<br>Block: 带有自动变量的匿名函数. 封装了函数调用以及调用环境的OC对象</p>
<p>全局block, 存储在已初始化数据(.data)区—没有访问auto变量<br>栈block 堆区—访问了auto变量<br>堆block 栈区—NSStackBlock__ 调用copy</p>
<p>对栈block 进行copy操作, 就是堆block, 对全局block进行copy, 仍是全局block . 对堆block进行copy, 将会增加引用计数<br>(不copy会怎么样)</p>
<pre><code>0.    __block typeof(self) weakSelf = self 和 __weak typdeof(self) weakSelf = self 的区别</code></pre><p>由于 block 捕获<strong>block 修饰的变量会去持有变量, 那么如果用</strong>block修饰self, 且self持有block, 并且block内部使用到了<strong>block 修饰的self时, 就会造成多循环引用, 即self持有block, block 持有</strong>block变量, <strong>block变量持有self, 造成内存泄漏. 主动断开</strong>block的持有, 就可以解决这种循环引用. 即在block内部使用完weakself后, 将其置为nil, 但这种方式有个问题, 如果block 一直不被调用, 那么循环引用将一直存在. 好处就是在block里面self会一直存在, 所以最好还是用__weak来修饰self</p>
<p>-(void)dealloc{<br>    __weak typdeof(self) weakSelf = self;<br>    NSLog(%@,weakSelf)<br>}<br>会crash. 添加weak的时候, runtime会通过检查引用计数的个数来判断对象是否在deallocationg, 如果是会让程序crash</p>
<pre><code>0.    为什么__block修饰的变量可以在block里面访问</code></pre><p><strong>block 修饰的int, clang下文件就会发现, __block修饰的参数, 其实转换成了 __block_byref_valueInt_0 结构体 ,在构造这个结构体的时候, 里面有个参数传递的事&amp;valueint 地址 . 经过</strong>block后, 编译器会将value拷贝到了堆上. Block修改的其实是堆上的内容</p>
<pre><code>0.    为什么声明block属性要用 copy?</code></pre><p> 使用copy 是从MRC 遗留下来的传统, 在mrc中, 手动管理内存, 方法内部的block 是在栈区, 使用copy可以把它放在堆区. 堆由开发自己管理内存, 在ARC中对block 使用copy还是strong 效果是一样的, 但是建议写copy, 因为这样显示告知调用者编译器会自动进行copy操作, 将block复制到堆上 </p>
<p>20 互斥锁和自旋锁<br>自旋锁 不会引起调用者睡眠, 如果自旋锁已经被别的执行单元持有, 调用者就一直循环在那里等待是否自旋锁的保持住释放了锁.其作用是为了解决某项资源的互斥使用, 因为自旋锁不会引起调用者睡眠, 所以自旋锁的效率远高于互斥锁</p>
<p>互斥锁: 属于sleep-waiting类型的锁, 如果他要访问的的一个锁正在被别的线程只有, 那么他就会sleep, 然后等待被running</p>
<p>互斥锁适合临界区持锁时间比较长的操作, 比如临界区有IO操作, 临界区代码复杂或者循环量大, 临界区竞争非常结论, 单核处理器</p>
<p>自旋锁主要用于在临界区持锁时间非常短且CPU资源不紧张的情况下, 自旋锁一般用户多核的服务器</p>
<p>自旋锁会忙等, 就是被访问的资源被锁是, 调用者线程不会休眠, 而是不停循环在哪里, 直到被锁资源释放锁. 优点在于, 自旋锁不会引起调用者睡眠, 不会进行线程调度, cpu时间陪轮转等耗时操作. 所以如果能在短时间内获得锁, 自旋锁的效率远高于互斥锁. 缺点就是一直占用cpu. 自旋锁不能实现递归调用   例子: atomic, dispatch_semaphore_t<br>互斥锁会休眠, 所谓的休眠, 即在访问被锁资源时, 调用者线程休眠, 此时cpu可以调度其他线程工作, 直到被锁资源释放锁, 此时会唤醒休眠线程. pthread_metex, @synchronized NSLock, 适合 单核处理器, 临界区有IO操作, 执行时间比较长, 竞争比较激烈</p>
<p>OSSpinLock 自旋锁<br>os_unfaire_lock 互斥锁</p>
<p>pthread_mutex  互斥锁, 等待锁的线程会处于休眠状态/递归锁(允许同一个线程对一把锁重复加锁)<br>NSLock 对mutext的封装<br>dispatch_queue dispatch_semaphore 也可以实现锁<br>@synchronized 对mutex 互斥的封装<br>—传nil是无法启动加锁作用<br>—不会持有传入的对象, 所以在sychronized里面销毁了这个对象, 也不会有问题<br>—乡里低, 传入对象必须等待之前的锁执行完之后才能执行, 无法达到异步的效果</p>
<p>41 死锁</p>
<p>死锁的四个必要条件: 互斥, 请求保持, 不可剥夺, 环路<br>死锁的处理: 鸵鸟策略,预防策略,避免策略,检测与解除死锁</p>
<p>19.一个 NSObject 对象占用多少内存空间？</p>
<p>class_getInstanceSize([Person class]) 获取类对象实际占用的大小<br>两个原则,1.内存对齐(提高内存访问速度): 大小必须是最大成员字节的整数倍</p>
<p>malloc_size((__bridge const void*)p) 获取的是实际内存大小<br>系统实际分配内存大小是16的整数倍</p>
<p>sizeof(p) 运算符函数, 计算的事传入的p, 计算的是p指针的大小为8</p>
<p>64位的系统<br>BOOL 1个字节<br>Int float 基础类型占4个字节<br>NSSting NSInterge Block CGFloat long double 8个字节<br>CGRect 32<br>20 OC的本质<br>OC的面向对象都是基于C/C++数据格式(结构体)实现的</p>
<p>一个OC对象在内存中是如何布局的?<br>以NSObjet为例, 在内存中是一个struct, 里面有个 class ias指针</p>
<p>21 OC的类信息存放在哪里<br>对象方法, 属性, 成员变量, 协议信息,存放在class对象中<br>类方法, 存放在meta-class对象中<br>成员变量的具体值, 存放在instance对象</p>
<p>12 weak的实现原理？SideTable的结构是什么样的</p>
<p>Weak 表明该属性定义了一种”非拥有关系”, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值, 性质同assign类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空<br>runTime维护了一个weak_table_t结构的hash表, 用于存储指向某个对象的所有weak指针. key是对象的地址, value是 weak_entry_t 的一个动态数组, 用来存储 weak_entry_t 类型的元素. weak_entry_t的结构体也是hash结构. 存储了弱引用对象指针的指针</p>
<p>Sidetable 主要用于管理对象的引用计数和weak表<br>struct SideTable{<br>    spinlock_t slock;    //保证原子操作的自旋锁<br>    RefcountMap refcnts    //引用计数hash表<br>    weak_table_t weak_table //weak 引用全局 hash表<br>}</p>
<p>13 引用计数<br>当调用allock new copy mutableCopy方法返回了一个对象, 在不需要这个对象是, 需要调用release 或者autorelease来释放它</p>
<p>引用计数存储在isa指针里面, 如果不够存储就存在一个散列表里</p>
<p>10 load、initialize方法的区别什么？在继承关系中他们有什么区别<br>调用时机不一样, load是app一启动就会调用,  Initialize,只有在对象初始化的时候才会调用<br>Load调用时机, 先父类在子类, 主类先于类别<br>Load 函数只要你动态加载了这个类, load方法就会执行</p>
<p>在执行load方法之前, 会调用load_image方法, 用来扫描+load符号, 将需要调用load方法的类添加到一个列表中loadable_classes, 在这个列表, 会先把父类接入到待加载列表, 这样保证父类在子类前调用load方法, 而load方法会在类的load的方法后面加入另外一个待加载列表loadable_categories. 待扫描结束后, 先从loadable_classes调用类的load方法, 然后会调用loadable_categories中分类的方法<br>+(load)方法是根据方法地址直接调用, 并不是经过objc_msgSend函数调用. 而initialize是通过objc_msgSend进行调用</p>
<p>1.分类的load方法和编译有关, 先编译的先调用, 后编译的后调用<br>2.多个category方法冲突, 会找到最后一个编译的category对于的方法<br>3.类的load方法能否调用category中声明的方法? 可以的. 因为附加category到类的工作会先于load方法的执行<br>4.category的方法和类的方法冲突了. 想调用类的方法咋办, 运行时获取当前类的方法列表, 然后遍历, 获取最后一个方法</p>
<p>initalize 会强制父类先调用, 子类和父类同时实现initalize, 父类的先被调用, 然后调用子类, 如果本类和category同时实现了initialize, category会覆盖本类的方法, 只调用category的initialize 只会调用一次一次. 如果子类没实现+initalize, 会调用父类的+initialize(父类的+initalize可能会调用多次)</p>
<p>4 category的实现原理</p>
<p>Category 编译之后的底层结构是struct category_t, 里面存储这分类的对象方法,类方法,属性, 协议信息<br>在程序运行时的时候, runtime会将category的数据, 合并到类信息中(类对象, 元类对象中)</p>
<p>6 category &amp; extension区别，能给NSObject添加Extension吗，结果如何<br>Category 只能添加方法, extension可以为已知类新增方法和属性, 不能为NSObject新增extension, 因为不知道NSObject里面方法的实现<br>Extension在编译的时候, 它的数据就已经包含在类信息中<br>Category是在运行时, 才会将数据合并到类信息中</p>
<p>28 Category 在编译过后，是在什么时机与原有的类合并到一起的</p>
<p>1 程序启动后, 通过编译之后, runtime 会进行初始化, 调用 objc_init<br>2 然后会map_images<br>3 接下来调用map_images_nolock<br>4 然后就是 read_images, 这个方法会读取所有的类的相关信息<br>5 然后调用reMethodizeClass: 这个方法是重新方法化的意思<br>6 在reMethodizeClass, 方法内部会调用attachCategories, 这个方法会传入class和Category, 会将方法列表, 协议列表等与原有的的类合并, 最后加入到class_rw_t结构体中</p>
<p>29 Category 有哪些用途？  Category 的实现原理？</p>
<p>将方法分类, 添加属性和协议<br>比如添加方法, 声明方法和实现, 然后在runtime的时候将声明的方法, 协议, 和主类的方法进行合并, 放在class_rw_t</p>
<p>类别如果设计的不好的话容易出现方法冲突, 至于先调用哪个和编译顺序有关</p>
<p>13 关联对象的应用？系统如何实现关联对象的在category里面添加假属性<br>objc_setAssociatedObject(self,”name”,OBJC_ASSOCIATION_COPY);<br>objc_getAssociatedObject(self,”name”);</p>
<p>associationManager 维护了一个hash表, key是对象地址, value是一张hash表, hash表里又是关联对象的key和ObjcAssocation的映射, objcAssocation是一个C++的类, 表示一个具体的关联对象, 包括两个实例变量, _policy表示关联策略, _value标识关联对象</p>
<p>14 关联对象的如何进行内存管理的？关联对象如何实现weak属性<br>内存管理是通过赋值的时候设置一个policy, 根据这个policy的类型来对设置的对象进行retain/copy操作, 当poliy是asign的时候, 设置的关联值是以weak的方式进行内存管理</p>
<p>19 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗<br>Atomic,确保属性的赋值的原子性, 只保证的getter 和setter存取的线程安全, 并不能保证整个对象的线程安全, 为了保证线程安全可以考虑加锁, 比如最简单的@synchronized NSLock  pthread_mutex (互斥锁) OSSpinLock (自旋锁, 但是ios因为优先级反转的问题, 已经不安全了)</p>
<p>多个线程, 线程A写,线程B写, 线程A读. 这个时候读到的事线层B写的</p>
<p>62 OC和c交换对象内存权限<br>__bridge 只做类型转换, 但是不修改对象的内存管理权<br>__bridge_retained 将OC对象转换成CF对象, 同事将对象内存的管理权交给开发, 后续使用CFRelease来释放对象<br>__bridge_transfer 将CF对象转换成OC对象, 同时将对象内存的管理权交给ARC</p>
<p>59 const extern static</p>
<p>Const 与 宏的区别</p>
<p>宏是预编译, const 是编译阶段<br>宏不做检查, 不会报编译错误, 只是替换,  const会编译检查, 会报编译错误<br>宏能定义一些函数,方法,  const不能<br>使用大量的宏, 容易造成编译时间久, 每次都需要重新替换</p>
<p>Static:<br>用static修饰的变量, 在其所限定的作用域中只会有一份内存.<br>如果在一个函数内部, 说明是一个静态局部变量, 不管这个函数调用多少次, static修饰的变量只会有一份内存<br>如果在一个文件内部, 是一个静态全局变量, 该文件中的函数都可以访问, 并且不同函数在对改变量修改是都是在上一次函数修改的基础上修改的</p>
<p>extern 外部变量<br>用extern修饰的变量, 可以被其他类所访问, 凡是引用了extern所修饰的变量的头文件, 那么就可以使用该变量</p>
<p>Const 一个变量如果用const修饰, 说明该变量不可以被修改</p>
<p>混搭<br>static 和 const 混用 定义一个宏  static NSString *const identifier = @“hello“</p>
<p>extern 和 const混用 .h文件中 extern NSString *const hello.在.m文件中赋值 NSString *const hello = @“hello”; 用来多个文件使用同一个变量</p>
<p>int  const  *p   //  *p只读 ;p变量</p>
<p>int  * const  p  // *p变量 ; p只读</p>
<p>const  int   * const p //p和*p都只读</p>
<p>int  const  * const  p   //p和*p都只读</p>
<p>58 tagged Pointer</p>
<p>为了节省内存和提高执行效率, 苹果首次在64位处理器上面提出了tagged pointer的概念. 对于64位程序, 引入tagged pointer后, 相关逻辑减少一半的内存占用, 以及3倍的访问速度提升, 100倍的创建,销毁速度提升</p>
<p>tagged pointer的特点<br>    0.    专门用来存储小的对象, 比如 NSNumber, NSDate, 个别NSSTring<br>    0.    taggedPointer 指针的值不在是地址了, 而是真正的值<br>    0.    在内存的读取上有着3倍的效率, 创建时比以前快了100倍</p>
<p>NSString 是个类簇<br>_NSCFConstantString 常量字符串<br>NSTaggedPointerString<br>_NSCFString  对象类型的字符串</p>
<p>1 dynamic 告诉系统不用自动生成set get方法</p>
<p>54 pod install 和 pod update </p>
<p>CocoaPods原理是将所有的依赖库都放在另一个名为Pods的项目中, 然后让主项目依赖Pods项目</p>
<p>Pod install 是第一次在工程里使用pods的时候使用, 并且每次编辑podfile (添加, 移除, 更新)的时候使用. 每次运行pod isntall的时候, 在下载, 安装新的库的同时, 也会把你安装的每个库的版本都写在Podfile.lock文件里面. 这个文件记录你每个安装库的版本号, 并且锁定了这些版本</p>
<p>当使用podinstall它只解决了pods里面, 但不在Podfile.lock文件里面的那些库直接的依赖. 对于在Podfile.lock里面所列出的那些库, 会下载在Podfile.lock里面明确的版本, 并不会去检查是否该库有最新的版本</p>
<p>Pod update. 会帮你更新这个库的新版本, 而不需要考虑Podfile.lock里面的限制. 他会更新到这个库尽可能的新版本, 只要符合Podfile里面的版本限制</p>
<p>90 iOS包签名<br>1.从keychain里的从”从证书颁发机构请求证书”, 这里就本地生成了一对公私钥, 保存的certificateSigningRequest 就是公钥, 私钥保存在本地电脑里<br>2.把对应的certificateSigningRequest 传到苹果后台生成证书(用苹果后台的私钥去签名), 并下载到本地. 这时候本地有两个证书, 一个是第一步生成的, 一个是从这里下载的. keychain会把这两个证书关联起来.<br>3.在苹果后台配置AppID/权限/设备等, 最后下载Provisioning profile文件<br>4.Xcode会通过第三步下载回来的证书(存着公钥), 在本地找到对应的私钥, 用本地私钥去签名app, 并将Provisioning profile文件命名为embedded.mobileprovision 一起打包进去.<br>5.安装时, iOS系统取得证书, 通过系统内置的公钥, 验证embedded.mobileprovision, 验证成功后, 取出里面的数据, 做各种验证, 比如公钥L验证app签名, 验证设备ID是否在列表上, 权限是否一样</p>
<p>certificateSigningRequest 本地公钥<br>P12 本地私钥<br>provisioning profile:包含了证书/entitlements等数据, 并由苹果后台私钥签名的数据包</p>
<p>89 为什么不能再子线程刷新ui<br>Uikit 并不是线程安全的类, 如果异步操作会存在读写的问题, 如果加锁的话会消耗大量的资源并拖慢运行速度</p>
<p>如何避免在子线程刷新ui<br>runtime swizzling 解决, 刷新ui的时候, 一定会调用uilayer和uiview的 setNeedsDisplay, SetNeedsLayout, SetNeedsDisplayInRect , 确保这几个方法在main thread中执行就行了</p>
<p>87 沙盒目录结构是怎样的<br>application:存放程序源文件<br>Document:常用目录, iCloud备份目录, 存放数据<br>library<br>—caches:存放体积大又不需要备份的数据<br>—preference: 设置目录, iCloud 会备份设置信息<br>tmp: 存放历史文件</p>
<p>85 APM application performance management ,应用性能管理, 通过对应用的可靠性, 稳定性等方面的监控, 进而达到快速修复问题, 提供用户体验的目的</p>
<p>83 coreAnimation 和 coreGraphics 的区别<br>coreGraphics是核心图形库, 包含Quartz2D绘图API接口<br>CoreAnimation是核心动画库, 用来做iOS相关动画</p>
<p>CoreAnimation 是依赖于openGL ES做GPU渲染, coreGraphincs做cpu渲染</p>
<p>做动画的时候获取frame<br>每个CALayer有个presentationLayer属性, 当CAAniamtion做动画的时候, 其实是看到的事presentationLayer, 开启一个计时器去获取presentationLayer的frame</p>
<p>82 drawRect调用情况</p>
<p>-如果UIView 没有设置frame大小, drawRect不会被自动调用<br>-drawRect在loadview 和viewDidLoad这两个方法之后调用<br>-调用sizeToFit后自动调用drawRect<br>-调用setNeedsDisplay或者setNeedsDisplayinRect会触发调用<br>-设置contentmode属性值为UIViewContentModeRedraw. 每次设置/更改frame的时候自动调用drawRect</p>
<p>81 drawrect空实现 是否会有影响<br>重写drawRect 会导致内存大量上涨. 画板视图的 -drawRect: 方法背后实际上都是底层的 CALayer 进行了重绘和保存中间产生的图片. 每次重绘的时候都需要重新抹掉内存然后重新分配. 空寄宿图的产生消耗了大量内存, 这就是drawRect内存暴增的原因</p>
<p>解决方案<br>使用专有图层 CAShapeLayer. 他是一个通过矢量图形而不是bitmap来绘制图层子类. 用CGPath 来定义要绘制的图形, CAShapeLayer会自动渲染. 它可以完美替代我们之间使用CoreGraphics绘制layer<br>优点<br>    0.    渲染快速<br>    0.    高效使用内存, 不会像普通CALayer一样创建一个寄宿图形<br>    0.    不会被图层编辑剪裁掉<br>    0.    不会出现像素化</p>
<p>63 setNeedsLayout与layoutIfNeeded   和 setNeedsDisplay<br>layoutIfNeeded 方法被调用, 主线程会立即强制重新布局, 他会从当前视图开始, 一直到完成所有字数图的布局.</p>
<p>layoutSubviews 用来自定义视图尺寸, 他是系统调用的, 开发者不能手动调用(手动调用怎么样), 可以重写该方法, 让系统在调整布局时候按照我们希望的方式进行布局. 选择屏幕,滑动/触摸屏幕修改子视图的时候被处罚<br>—addsubview会触发<br>—修改view的frame会触发layoutSubviews<br>—滚动uiscrollview<br>—旋转screen会触发父uiview的layoutSubviews<br>—直接调用setlayouSubviews</p>
<p>setNeedsLayout 触发布局, 他不回立即强制视图重新布局, 而是在下一个布局周期才会被触发. 异步执行..  默认调用layoutSubviews</p>
<p>setNeedsDisplay 标记为需要重绘. 会自动异步调用drawRect 方法, 然后拿到currentContext 就可以画画了<br>-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘</p>
<p>35 利用RunLoop 解释下页面的渲染过程</p>
<p>当我们调用 [uiview setNeedsDisplay] 时, 这时会调用当前的 view.layer 和 [view.layer setNeedsDisplay] 方法. 这等于给当前的 layer 打上一个脏标记, 而此时并没有直接绘制工作, 而是会到当前的 RunLoop 即将休眠, 也就是 beforeWaiting 时才会进行绘制工作.<br>紧接着会调用 [CALayer display], 进入真正绘制的工作. CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理工作 displayer: 这个代理方法是异步绘制的入口. 如果没有实现这个方法, 那么会继续进行系统绘制的流程, 然后绘制结束<br>CALayer 内部会创建一个 Backing Store 用来获取图形上下文, 接下来会判断这个 layer 是否有 delegate. 如果有的话,会调用 [layer.delegate drwaLayer:inContext:] 并且会返回给我们 [UIView DrawRect] 的回调, 让我们在系统绘制的基础上在做一些事情<br>如果没有 delegate,那么会调用 [CALayer drawInContext]<br>以上两个分支, 最终 CALyaer 都会将位图提交到 Backing Store, 最后提交给 GPU, 至此绘制的过程结束</p>
<p>80  OOM机制和监控方式<br>由于iOS的Jetsam 机制造成的另一种另类crash, 他不同于常规的crash, 通过singal 捕获等crash监控方案无法不会oom事件<br>原因<br>1.系统内存使用较高, 系统基于优先级杀死优先级较低的app<br>2.当前使用的App达到了””high water mark, 也就是达到了对单个app的内存限制, 系统会kill你</p>
<p>常见的导致问题<br>    0.    uigraphicsEndImageContext — UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏<br>    0.    uiwebview<br>    0.    autoreleasePool<br>    0.    相互引用<br>    0.    大图片处理, 处理大分辨图片时, 往往容易oom, 因为解码的时候, 生成原始分辨率大小的bitmap, 这很消耗性能<br>    0.    uiview太大时</p>
<p>74 图片解码<br>加载完图片之后, 不能直接展示到屏幕上, 加载完之后需要先进行解码, 解码是在主线程进行的, 如果图片比较多也会导致卡顿<br>解决方案:<br>1.拿到图片后获取CGImage<br>2.将CGImage解码, 创建图形上下文, 然后将图片画在图形上下文, 这样就完成了解码操作, 然后在从上下文获取图片, 这个图片是解码过的, 然后将这个图片包装成uiimage</p>
<p>74 渲染过程<br>Cpu一般用户显示内容的计算， 而GPU的并行计算能力更强， 能够通过计算将图形结果显示在屏幕像素中<br>在渲染过程中， CPU专门用来处理渲染内容的计算， 比如视图创建，布局，图片解码等，内容计算完成后，在传输给GPU进行渲染<br>原生渲染的过程：1.CPU计算要显示的内容，包括视图创建，计算布局，视图布局。 当Runloop在BeforWaiting和Exit时，会通知注册的监听， 然后对图层打包，打包后将打包数据发送给一个独立负责渲染的进程Render Server。2.数据达到Render Server后会被反序列化，得到图层树，然后再次过滤之后得到渲染树，渲染树的信息会转给OpenGL/Metal， 3.Render Server会调用GPU，<br>总结一句话，CPU处理完渲染内容会输入到Render Server中， 经图层树和渲染树的转换，通过OpenGL接口提供给GPU，GPU处理完后在屏幕上显示</p>
<p>73 屏幕成像</p>
<p>Cpu——计算——&gt;GPU—渲染—&gt;帧缓存———读取——&gt;视频缓存器——显示——&gt;屏幕</p>
<p>卡顿产生的原因, vsync(垂直信号)来的时候, 页面没渲染完, 就会等待下一次的再来的时候渲染<br>—cpu—&gt;—GPU—&gt;(VSync)—</p>
<p>卡顿优化—CPU<br>1.尽量用轻量级的对象, 比如用不到事件点击处理的地方, 可以考虑使用CALayer取代uiview<br>2.不要频繁调用uiview的相关属性, 比如 frame bounds<br>3.尽量提前计算好布局, 在需要时一次性调整对应的属性<br>4.autolayout会比直接设置frame消耗更多的cpu资源<br>5.图片的size最好刚好跟uiimageView的size保持一致<br>6.控制一下线程的最大并发数量<br>7.尽量将耗时的操作放在子线程<br>—文字处理(尺寸计算, 绘制)<br>—图片处理(解码,绘制)</p>
<p>卡顿优化—GPU<br>1.降级避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示<br>2.GPU能处理的最大纹理尺寸是4096*4096, 一旦超过这个尺寸, 就会占用cpu资源进行处理<br>3.尽量减少视图数量和层次<br>4.减少透明的视图<br>5.尽量避免出现离屏渲染</p>
<p>耗电优化<br>1.尽可能降低CPU,GPU功耗<br>2.少用定时器<br>3.优化IO操作<br>—尽量不要频繁写入小数据, 最好批量一次性写入<br>—读写大量重要数据时, 考虑用dispatch_io 其提供了基于GCD异步操作文件IO的api, 用dispatch_io系统会优化磁盘<br>—数据量比较大的, 建议使用数据库<br>4.网络优化<br>—减少,压缩网络数据<br>—如果多次请求的结果相同, 尽量使用缓存<br>—断点续传<br>—网络不可用, 不要尝试执行网络请求<br>—网络操作设置超时时间<br>5.定位优化</p>
<p>74 离屏渲染<br>在openGL中, GPU有两种渲染方式<br>——当前屏幕渲染, 在当前用于显示的屏幕缓冲区进行渲染操作<br>——离屏渲染, 在当前屏幕缓冲区外开辟一个缓冲区进行渲染操作(当使用圆角, 阴影,遮罩的时候, 图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制, 所以就需要离屏渲染)</p>
<p>离屏渲染消耗的原因<br>—需要创建新的缓冲区<br>—离屏渲染的整个过程, 需要多多次切换上下文环境, 先从当前屏幕切换到丽萍,<br>哪些操作会触发离屏渲染<br>—光栅化<br>—遮罩<br>—maskstoBounds +cornerRaudius,解决方案:通过coreGraphics 绘制剪裁圆角或者uibezierpath+CAShapeLayer来做<br>—阴影<br>——如果设置了layer.shaowpath 就不会产生离屏渲染</p>
<p>49 离屏渲染</p>
<p>离屏渲染的代价很高, 想要进行离屏渲染, 首先要创建一个新的缓冲区, 屏幕渲染会有一个上下文环境的概念, 离屏渲染的整个过程需要切换上下文环境, 从当前屏幕切换到离屏, 等结束后, 又要讲上下文环境切换回来</p>
<p>离屏渲染触发的场景<br>    0.    圆角<br>    0.    图层蒙版<br>    0.    阴影<br>    0.    光栅化</p>
<p>50 如何提高 tableview 的流畅度</p>
<p>优化cpu<br>    0.    尽量用轻量级的对象, 比如用不到点击时机的地方可以考虑用calayr取代uiview<br>    0.    不要频繁的调用uiview的相关属性, 比如frame, bounds,transform等属性, 尽量减少不必要的修改<br>    0.    尽量提前计算好布局, 在有需要时, 一次性调整对应的属性, 不要多次修改属性<br>    0.    autolayout 会比直接设置 frame 消耗更多的cpu资源<br>    0.    图片的size最好刚好跟uiimageview的size保持一致<br>    0.    控制一下线程的最大并发数量<br>    0.    尽量把耗时的操作放在子线程<br>    0.    文本的处理 尺寸计算, 绘制<br>    0.    图片处理, 解码, 绘制</p>
<p>优化GPU<br>    0.    避免出现离屏渲染<br>    0.    尽量减少视图数量和图层<br>    0.    尽量避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示</p>
<p>65 实现监听卡顿<br>添加Observer到主线程RunLoop中, 通过监听RunLoop状态切换的耗时, 以达到监控卡顿的时间<br>—结束休眠到处理source0,这段时间<br>—监听beforeSource和afterWaiting, 也就是source0回调和接受mach_port 消息两个状态. 一旦发现进入睡眠前的KCFRunloopBeforeSource状态, 或者唤醒后的状态 KCFRunloopAfterWaiting, 在设置的时间阈值内一直没有变化, 即可判定为卡顿<br>—dump 出堆栈的信息, 从而进一步分析出具体哪个方法执行时间过长</p>
<p>62 CALayer 的一些具体属性, 介绍下各个layer<br>contents  id类型, 可以是任何类型的对象, 但是一般都是复制CGimage<br>mask  遮罩, 让父图层部分区域可见</p>
<p>一个渐变色, 如果不创建新的layer, 如果写一个<br>view.layer.mask = CAGradientLayer</p>
<p>CAShapeLayer: 指定CGpath和贝塞尔曲线, 可以画出各种图形<br>CAGradientLayer: 渐变色<br>CATiledLayer:大图绘制</p>
<p>隐式动画: CoreAnimation 在每个runloop周期中自动开始一次新的食物. 任何在一次runloop循环中属性的改变都会被集中起来, 然后做一次0.25s动画<br>关闭<br>    [CATransaction begin];<br>    [CATransaction setDisableActions:YES];<br>    XXX<br>    [CATransaction commit];</p>
<p>76 安装包瘦身<br>资源<br>—采取无损压缩<br>—去除没有用到的资源</p>
<p>可执行文件瘦身<br>—去掉异常支持</p>
<p>检测未使用的代码<br>检测重复代码, 未被调用的代码</p>
<p>55 NSTimer 循环引用</p>
<p>RunLoop强引用了Timer, timer强引用了VC, 所以无法释放<br>为什么用weakSelf也不行? 因为timer传进入的对象, 会重新strong一下</p>
<p>71 CADisplayLink 和 NSTImer 注意点<br>这里俩都会对target产生强引用, 如果target又对他们强引用, 就会引发循环引用<br>使用NSProxy弱引用解决<br>NSPorxy本身是一个抽象类, 他遵守NSObject协议, 提供了消息转发的通用接口<br>VC强引用了Timer, Timer强引用了porxy, 但是porxy弱引用了VC</p>
<p>NSProxy 一个抽象的超类, 通常发给proxy的消息会被转发给实际对象</p>
<p>47 访问 __weak 修饰的变量是否已经被注册在了 @autoreleasePool中<br>__weak修饰的变量属于弱引用, 如果没有被注册到 @autoreleasePool中, 创建之后也就会随之销毁, 为了延长它的生命周期, 必须注册到 @autoreleasePool 中, 亿延缓释放</p>
<p>_unsage_unretained, 和 weak一样, 表示的事对象的一种弱引用关系, 唯一的区别是, __weak 修饰的对象别释放后, 指向对象的指针会置空, 也就是指向nil, 不会产生野指针. 而_unsafe_unretained修饰的对象被释放后, 指针不会置空, 而是变成野指针, 那么此时如果访问这个对象的话, 程序就会crash, 抛出BAD_ACCESS的异常</p>
<p>ARC</p>
<p>16 ARC的实现原理？ARC下对retainrelease做了哪些优化<br>ARC 是LLVM编译器你和runtime系统相互协作的一个结果<br>RAC所做的无非就是在合适的时机帮我们添加retain, release 或者autoRelease, 无需程序员手动写这些代码, 本质上和MRC一样, 但是比MRC手动写更高效, 因为ARC是直接调用C语言的方法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangyanchang21/article/details/79461511">https://blog.csdn.net/wangyanchang21/article/details/79461511</a></p>
<p>Copy 或者strong 会增加引用计数吗?  Strong 会, copy. 分情况, 可变对象, 还是不可变对象</p>
<p>以alloc,copy, mutableCopy new这些方法会被标记位 __attribute(ns_returns_retained). 以这些方法创建的对象, 编译器会在调用方法外网要加上内存管理代码 retain/release, 所以会在作用域结束的时候就会释放. 而不以这些关键字开头的方法, 会被标记为 __attribute(ns_returns_not_retained). 编译器会在方法内部自动加上 autorelease方法, 这些方法会被注册到自动释放池, 同时其释放会延迟, 等到自动释放池销毁的时候才释放</p>
<p>MRC中对一个对象执行autorelease 会发生什么, 引用计数1. ARC中用 autoreleasing 修饰 引用计数为2. 因为他转换成了  id o = [obj retain] autorelease];<br>-(id)autorelease{<br>[NSAutoreleasePool addobject:self]<br>}</p>
<p>15 Autoreleasepool的原理？所使用的的数据结构是什么<br>struct __AtAutoreleasePool{<br>    void  *atAutoreleaseobj = objc_autoreleasePoolPush();<br>    objc_autoRealeasePoolpop(autoreleasepoolobj);<br>}<br>objc_autoreleasePoolPush ==&gt; autoreleasePoolPage:push<br>objc_autpreleasePoolPop  ===&gt;autoreleasePoolPage::pop(ctxt)</p>
<p>autoreleasePoolPage 是一个双向链表<br>class autorealsePoolPage{<br>    magic_t const magic<br>    id *next<br>    pthread_t const thread<br>    AutorealesePoolPage * parent<br>    AutorealeasePoolPage *child<br>    depth<br>    hiwat<br>}</p>
<p>哨兵对象 POOL_SENTINEL, 就是nil, 释放的时候一直释放到哨兵对象为止</p>
<p>16 什么对象会放到autoreleasepool里面什么对象不都会<br>__autoreleasing声明的对象都会放到pool里<br>—静态变量不会放到autoreleasepool<br>—objc_autoreleaseReturnValus()后面跟着objc_retainautoreleaseReturnValue()不会放到autoreleasePool, 比如 NSMutableArray的array方法</p>
<p>17 ARC下哪些情况会造成内存泄漏<br>Block  两个对象循环引用,  错误的delegate属性, nstimer</p>
<p>MRC下重写set方法</p>
<p>(Void)setA:(int)A{<br>    if (_A != A){<br>        _A release;<br>        _A = [A retain]<br>}<br>}</p>
<p>(Void)setA:(int)A{<br>[A retain]<br>_A relase<br>_A = A<br>}</p>
<p>44 MRC 下重写Set 和get</p>
<p>-(Void)SetA:(NSString *)brand{<br>    if (_brand != brand){<br>    _brand release;<br>    _breand = [brand retain]<br>}}</p>
<p>-(NSString *)getBrand{<br>    return [_brand retain] autorelease]<br>}</p>
<p>-(void)dealloc{<br>    _string release];<br>    super dealloc]<br>}</p>
<p>runtime</p>
<p>1 什么是Runtime<br>OC是一门动态性的编程语言, 允许很多操作推迟到程序运行时在进行. OC的动态性就是由Runtime来支撑和实现的, Runtime是一套C语言的API, 封装了很多动态性相关的函数. 平时编写的OC代码, 底层都是转换成了Runtime API进行调用</p>
<p>具体应用<br>    0.    关联对象给分类添加属性<br>    0.    遍历类的所有成员变量<br>    0.    交换方法实现<br>    0.    利用消息转发机制解决方法找不到的异常</p>
<p>1.介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）<br>Struct objc_class{<br>    class isa<br>    class superClass<br>    cache_t cache //方法缓存<br>    class_data_bits_t bits //用于获取具体的类的信息<br>}</p>
<p>Struct class_rw_t{<br>    uint32_t flags;<br>    unit32_t version;<br>    const class_ro_t *ro<br>    method_list_t *methods; //方法列表<br>    property_list_t *perperties //属性列表<br>    const protocol_list_t *protocols //协议列表<br>}</p>
<p>Struct class_ro_t {<br>    unit32_t instanceSize; // instance 对象占用的内存空间<br>    const char *name<br>    method_list_t *baseMethodlist<br>    protocol_list_t *baseProtocols<br>    const ivar_list_t *ivars // 成员变量列表<br>}</p>
<p>2.isa详解</p>
<p>在arm64架构之前, isa就是一个普通的指针, 存储这calss, meta-class对象的内存地址<br>从arm64架构开始, 对isa进行了优化, 变成了一个共用体(union)结构, 还是用位域来存储更多的信息</p>
<p>20.对象的isa指针指向哪里</p>
<p>instance对象的isa指针指向class对象,<br>class对象的isa指针指向meta-class对象,<br>meta-class对象的isa指针指向基类的meta-class对象,<br>基类自己的isa指针也指向自己</p>
<p>runtime面试题</p>
<p>[self class]   //当前类<br>[super class] //当前类  </p>
<p>—objc_msgsendSuper((_rw_objc_super){(id)self, (id)class_getSuperClass(objc_getClass(“当前类”))}, @selector(“class”)), 里面的receiver 依然是self, 后面的class, 决定方法从哪里开始找<br>—从当前类的父类开始寻找class方法, 最后找到了NSObject</p>
<p> [self superclass]  //父类<br>[super superclass] //父类</p>
<p>[super message]的底层实现<br>    0.    消息接受者仍然是子类对象<br>    0.    从父类开始查找方法的实现</p>
<p>-(class) class{<br>    return object_getClass(self);<br>}</p>
<p>-(class)superClass{<br>    return class_getSuperclass(object_getClass(self))<br>}</p>
<p>面试题1<br>    BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];  1<br>    BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; 0<br>    BOOL res3 = [(id)[Person class] isKindOfClass:[Person class]]; 0<br>    BOOL res4 = [(id)[Person class] isMemberOfClass:[Person class]] ; 0<br>    BOOL res5 = [(id)[Person class] isKindOfClass:[NSObject class]]; 1<br>    BOOL res6 = [(id)[Person class] isMemberOfClass:[NSObject class]]; 0</p>
<p>-(BOOL)isMemberOfCLass:(class )cls{<br>return object_getClass(self) == cls<br>}</p>
<p>-(BOOL)isKindOfClass:(class)cls{<br>    for(class cls == object_GetClass(self);tcls = tcls-&gt;SuperClass){<br>        if tcls == cls return yes<br>    }<br>}</p>
<p>面试题2<br>@interface MDPerson: NSObjct<br>@property (nonatomic, copy) NSString *name<br>-(void)print<br>@end</p>
<p>@implementation MJPerson<br>-( void)print{<br>NSLog(@“my name %@”,self.name)<br>}</p>
<p>id cls = [MJPerson class]<br>Void *obj = &amp;cls<br>((__bridge id)objc print)<br>打印输出— my name [uiviewcontroller ]</p>
<p>为什么可以输出?<br>通过objc 找到对应内存, 然后取出前8个字节, 这前八个字节刚好是isa指针, 通过isa可以找到类</p>
<p>为什么输出 uiviewcontroller [super viewdidLoad] 导致的<br>内存布局, 从高到低</p>
<p>21 iOS 中内省的几个方法有哪些？内部实现原理是什么isKindOfClass:<br>isMemberOfClass:<br>respondToSelector:<br>conformToProtocol:      会查父类<br>class_conformToProtocl 只查当前类</p>
<p>23 class、object_getclass ,objc_getClass方法有什么区别?当参数为实例对象的时候, class 和 object_getclass 返回的都是当前的类<br>如果参数是类, class返回的是当前类,  object_getclass获取的是元类</p>
<p>objc_getClass 根据字符串获取类</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d4d8a79fd97">https://www.jianshu.com/p/0d4d8a79fd97</a></p>
<p>2.为什么要设计metaClass<br>功能分离, 各司其职, 符合单一职责设计原则, metaClass是关于类的类, 类方法会存在metaClass里面</p>
<p>3 class_copyIvarList 和 class_copyPropertyList的区别<br>class_copyIvarList 会获取所有属性和成员变量, 属性会有个_<br>class_copyPropertyList 会获取所有的属性</p>
<p>4 子类如何获取父类的属性<br>通过class_copyPropertyList 获取的只有子类的属性, 如果想获取父类的属性就需要调用 [self superclass], 同理, method_list 和 iva_list都是一样的, 只能包含当前类的, 不包含父类的</p>
<p>4 class_rw_t 和 class_ro_t的区别<br>class_rw_t结构体包含class_ro_t, class_ro_t主要是类无法修改, 已经确定的东西,  class_rw_t是可以扩充的, 在runtime新增的东西都放在了class_rw_t里面</p>
<p>14 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？<br>不需要, 因为被关联的对象在生命周期内要比对象本身释放的晚, 他们会在NSObject - dealloc调用objct_dispose()方法中释放<br>对象的内存销毁时间表, 分为四个步骤<br>    1 调用 -release 引用计数变为0<br>    2 父类调用 -dealloc<br>    3 NSObject 调用dealloc, 在这里只做了一件事情,  调用object_dispose()方法<br>    4 调用 object_dispose<br>        1 解除所有使用Runtime Associate方法管理的对象<br>        2 解除所有 _weak引用</p>
<p>24 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？<br>不可以向编译后得到的类添加实例变量, 因为编译后的类已经注册在runtime中, 类结构体重的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定<br>运行时创建的类是可以添加实例变量, 调用class_addIvar函数. 但是得在调用objc_allocateClassPaird之后, objc_registerClassPair之前</p>
<p>25 runtime如何通过selector找到对应的IMP地址？</p>
<p>先介绍下struct method_t{SEL, IMP, chat } SEL 和 IMP是一一对应的<br>在寻找IMP地址时, runtime提供了两种方法A IMP class_getMethodImplementation(Class cls, SEL name)  B IMP method_getImplementation(Method m), </p>
<p>对于方法A, 类方法和实例方法实际上都是通过调用class_getMethodImplementation来寻找IMP地址, 不同之处是传入的第一个参数不同, 类方法传的是 objc_getMetalClass(“A”), 实例方法 [A class], 通过传入不同的参数, 找到不同的方法列表, </p>
<p>对于方法B, 类方法  Method class_getClassMethod(class cls, SEL name)  实例方法 Method class_getInstanceMethod(Class cls, SEL name), 最后调用 IMP method_getImplementation(Method m)获取IMP地址</p>
<p>8在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么<br>1 先看当前方法是不是可以被忽略 2.查看self是不是nil 3. 查找cache 4.从当前类查找methodList, 然后再去父类, 已知找到NSobejct , 如果还没找到开始动态方法解析和重定向,转发</p>
<p>9 IMP、SEL、Method的区别和使用场景<br>Method是一个method_t的结构体, 里面有IMP函数指针, 指向具体的方法实现, SEL是方法名类型<br>使用场景: 实现类的swizzle的时候会用到, 通过class_getInstanceMethod(Class, SEL), 获取类的方法Method, class_addMethod(Class, SEL,IMP)</p>
<p>11 说说消息转发机制的优劣<br>可以预防crash, 实现多继承</p>
<p>22 什么是method swizzling（俗称黑魔法), 为什么可以做到<br>先说下 Method的结构<br>Struct Method{<br>    imp  指向具体的实现<br>    SEL  方法名<br>    char *types<br>}</p>
<p>23 什么时候会报unrecognized selector的异常<br>说下方向寻找的过程,<br>objc_class:objc_object{<br>    cache<br>}</p>
<p>先去cache中寻找, 如果cache没有找到, 就是methodlist中寻找, 先子类在父类, 一直找到NSObject, 如果还没有找到, 就进入消息转发, 这里给了三步</p>
<p>27 objc在向一个对象发送消息时，发生了什么？<br>objc_sendMsg(self,SEL,…);<br>先去判断self是不是nil, 如果是nil, 直接return, 否则进入下一步<br>查找sel, 先去cache中查, 如果没有就去methodList查, 先子类在父类, 最后调用到了Nsobject, 如果还没有就进入动态方法解析和消息转发阶段</p>
<p>//第一步,动态方法解析 给个机会让类添加这个实现的函数—这个方法需要在类的本身上动态添加它本身不存在的方法, 这些方法对于该类来说是冗余的</p>
<ul>
<li>(BOOL)resolveInstanceMethod:(SEL)aSEL{<br>  if (aSEL == @selector(foo:)){<pre><code>class_addMethod([self class], aSEL, (IMP)fooMethod,”V@:”)</code></pre>Return YES<br>}<br>  return [super resolveInstanceMethod]<br>}</li>
</ul>
<p>// 第二步消息转发 让别的对象去执行这个函数——将这个消息转发给一个对象, 开销较小, 并且被重写的概率较低, 适合重写<br>-(id)forwardingTargetForSelector:(SEL)aSelector{<br>    if (aSelector == @selector(foo:)){<br>        return [BackupClass alloc]ini];<br>}<br>Return [super forwardingTragetForSelector:aSelector]<br>}</p>
<p>返回self会咋么样 会继续执行, 先执行methodSignatureForSelector, 在走回resolveInstanceMethod, 在直接执行到forwardInvocation</p>
<p>//第三步 —通过NSInvocation的形式将消息转发给多个对象, 但是其开销较大, 需要创建新的NSInvocation对象, 并且forwardInvocation的函数经常被使用者调用, 来做多层消息转发机制, 不适合多次重写<br>里面的invocation 是从methodsignatureForSelector 获取, 如果返回nil转发流程终止, 抛出无法处理的异常<br>-(void)forwardInvocation:(NSInvocation *)invocation{<br>    SEL sel = invocation.selector<br>    if (newObject invokeWithTarge:sel){<br>        [invocation invokeWithTarget:alternateObjct]<br>}else{<br>    [self doesNotRecognizeSelector:sel];<br>}<br>}</p>
<p>//通过类型编码获取方法签名  如果返回nil直接crash, 如果调用super 方法会走到resolveInstanceMethod 然后crash<br>-(NSMethodSingature *)methodSignatureForSelector:(SEL)aSelector{<br>    NSMethodSignature *methodSignature = [super methodsingatureForSelector:aSelector];<br>    if (!methodSignautre){<br>        methodsignature = [NSMethodSignature signatureWithObjcTypes:””V@:X]<br>}<br>    return methodsignaure</p>
<p>}</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae96e8c6fb9a07ac85a3860">https://juejin.im/post/5ae96e8c6fb9a07ac85a3860</a></p>
<p>26 objc中向一个nil对象发送消息将会发生什么？</p>
<p>不会有任何错误, 也不会崩溃</p>
<p>如果这个方法返回值是一个对象, 那么发送给nil的消息将返回null<br>如果返回值是float, doubel, 返回0<br>如果方法返回值是结构体, 返回的结构体的值都是0</p>
<p>30 _objc_msgForward函数是做什么的</p>
<p>objc_msgForward是IMP类型, 用于消息转发, 当向一个对象发送一条消息, 但它并没有实现的时候, objc_msgForward 会尝试做消息转发<br>涉及到的流程</p>
<p>18 Method Swizzle注意事项</p>
<p>在change之前, 先添加下, 看看当前类有没有这个方法, 防止更换了父类的方法<br>防止多次更换, 两次更换相当于没有更换</p>
<pre><code>Class  = object_getClass([self class]);

Method originalMethod = class_getInstanceMethod(className, ori);
Method swizzleMethod = class_getInstanceMethod(className, swi);

BOOL didAddMethod = class_addMethod(className, ori, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));
if (didAddMethod) &#123;
    class_replaceMethod(className, swi, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
&#125;
else&#123;
    method_exchangeImplementations(originalMethod, swizzleMethod);
&#125;</code></pre><p>RunLoop<br>31 RunLoop</p>
<p>一个RunLoop 是一个事件处理环, 系统利用这个事件处理环来安排事物, 协调输入的各种事件. RunLoop的目的是让你的线程在有工作的时候忙碌, 没有工作的时候休眠, 节省CPU事件</p>
<p>RunLoop 实际上就是一个对象, 这个对象管理了其需要处理的事件和消息, 并提供了入口函数来执行事件. 线程执行了这个函数后, 就会一直处于这个函数内部”接收消息-&gt;等待-&gt;处理”的循环中, 直到这个循环结束, 函数返回</p>
<p>32 AFNetworking 中如何使用了RunLoop</p>
<p>AFURLConnnectionOperation 这个类是基于NSURLConnection构建的, 为了希望能在后台线程接受Delegate回调, 为此AF单独创建了一个线程, 并在线程里启动了RunLoop,</p>
<ul>
<li>(void)networkRequestThreadEntryPointer:{<br>  [NSThread currentThread] setName:@“AFNetworking”];<br>  NSRunLoop *runLoop = [NSRunloop currentRunLoop]<br>  runLoop addPort:[NSMackPort Port] forMode:NSDefaultRunLoopMode]<br>[runloop run]<br>}</li>
</ul>
<p>RunLoop启动前必须有至少一个timer observer source, 所以AFNetworking在[runloop run]之前先创建了一个新的NSMackPort 添加进去, 通常情况下, 调用者持有这个 NSMachPort(mack_port)并在外部线程通过这个Port 发送消息到Loop内,但此处添加Port 只是为了让RunLoop 不至于退出, 并没有用于实际发消息</p>
<p>当需要在这个后台线程执行任务的时候, AF通过[NSobject performSelectr:onThread]将这个任务扔到了后台线程的runLoop中</p>
<p>33 AutoReleasePool 何时释放</p>
<p>App启动后, 苹果在主线程RunLoop注册了两个Observer, 其回调都是 wrapRunLoopWithAutorealeasePoolHandler()</p>
<p>第一个Observer监视的事件是 Entry(即将进入Loop), 其回调内会调用 _objc_AutoRelaasePoolPush() 创建自动释放池, 其Order是-2147483647, 优先级最高, 保证创建释放池在其他回调之前</p>
<p>第二个 Observer 监听了两个事件,1.  BeforeWaiting (准备进入休眠)时调用 _objc_autorealesePoolPop() 和 _objc_autoreleasePoolPush() 释放旧池并创建新池.  2. Exit (即将退出Loop)时调用 _objc_autorealeasePoolPop() 来释放自动释放池, 这个Observer的order 是2147347474, 优先级最低, 保证释放池子发生在其他所有回调之后</p>
<p>34 RunLoop的mode</p>
<p>KCFRunLoopDefaultMode: 默认模式, 主线程是在这个运行模式下运行<br>UITrackingRunLoopMode, 跟踪用户交互事件(用于scrollview追踪触摸滑动, 保证界面滑动时不受其他mode影响)<br>UIInitializationRunLoopMode 在刚启动App的进入的第一个mode, 启动完成后就不再使用<br>GSEventReceiveRunLoopMode 接受系统内部事件, 通常用不到<br>KCFRunLoopCommonModes 伪模式, 不是一种真正的运行模式, 是同步Source/Timer/Observe到多个mode中的一种解决方案</p>
<p>36 RunLoop 的数据结构</p>
<p>NSRunLoop 是 CFRunLoop 的封装, 提供了面向对象的API RunLoop相关的主要涉及五个类<br>CFRunLoop: RunLoop 对象<br>CFRunLoopMode 运行模式<br>CFRunLoopSource 输入源/事件源<br>CFRunLoopTimer: 定时源<br>CFRunLoopObserver 观察者</p>
<p>1 CFRunLoop 由 pthread, currentMode, modes, commonModes, commonModelItems 构成</p>
<p>2 CFRunLoopMode 由name source0  source1 observers timers 构成</p>
<p>3 CFRunLoopSource 分两种 source0 和 source1</p>
<p>source0 即非基于port 的, 也就是用户触发的事件. performSelector:onTHread,需要手动唤醒线程, 将当前线程从内核态切换到用户态<br>Source1 基于port , 包含一个 mach_port 和一个回调, 可监听系统端口和通过内核和其他线程发送的消息, 能主动唤醒RunLoop, 接手分发系统事件, 具备唤醒线程的能力</p>
<p>4基于时间的触发器, 基本上说的就是NSTimer. 在预设的时间点唤醒RunLoop 执行回调. 因为他是基于RunLoop的, 因此他不是实时的<br>5 CFRunLoopObserver</p>
<p>监听以下时间点: CFRunLoopActivity</p>
<p>KCFRunLoopEntry RunLoop 准备启动</p>
<p>KCFRunLoopBeforeSources RunLoop 将要处理一些Source事件</p>
<p>KCFRunLoopBeforeWating  将要进行休眠状态, 即将由用户态切换到内核态</p>
<p>KCFRunLoopAfterWaiting RunLoop 被唤醒, 即从内核态切到用户态</p>
<p>KCFRunLoopExit RunLoop 退出</p>
<p>KCFRunLoopAllActivities 监听所有状态</p>
<p>什么叫内核态和用户态<br>内核态:运行操作系统程序, 操作手机硬件资源, 比如协调CPU资源, 分配内存资源<br>用户态:运行用户程序. 内核提供通用的访问接口, 让用户态调用<br>当一个进程在执行用户自己的代码是处于用户态. 用户态没有能力直接操作硬件, 只能通过操作操作系统内核提供的调用使用硬件资源<br>当一个进程因为系统调用陷入内核代码中执行时处于内核态</p>
<p>37 解释下事件相应的过程</p>
<p>苹果注册了一个 source1 用来接收系统事件, 其回调函数为 IOHIDEventSystemClientQueueCallBack()  当一个硬件事件(触摸/锁屏/摇晃等)发生后, 首先由 IOKit.framework 生成一个 IOHIDEvent 事件, 并由 SpringBoard 接收. SpringBoard 只接收按键(锁屏/静音等) 触摸, 加速, 接近传感器等几种 event, 并调用 UIApplicationHandleEventQueue() 进行应用内部的分发. UIApplicationHandlerEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理分发, 其中包括识别 UIGesture/处理屏幕旋转.发送给 UIWindow 等. 通常事件, 比如 UIButton 点击 touchesBegin/move/end/cancle 事件都是在这个回调中完成的</p>
<p>KVC&amp;KVO</p>
<p>53 KVC<br>setValue:forkey  setObject:forKey<br>setValue 中value可以为nil, 但是setobject不行, 如果setValue中value是nil, 会自动调用removeObjectForKey<br>setValue中的key只能是NSString, 但是setObject中的key可以使任意类型</p>
<p>使用KVC给一个对象赋值时, 会有以下方法和属性的调用顺序<br>    0.    查看setXXX 或者 _setXXX 方法<br>    0.    查看+ (Bool)accessInstanceVariablesDirecty 方法的返回值, 默认返回yes<br>    0.    yes: 可以访问成员变量, 进入下一步<br>    0.    NO 不可以访问成员变量, 同时调用 -(void)setValue:(id)value forUndefinedKey:(nsstring *)key方法, 如果方法不存在会抛出异常<br>    0.    调用成员变量: _key _isKey key isKey<br>    0.    调用顺序, 从左到右, 只要发现存在成员变量, 就不会调用后续变量<br>    0.    如果没有成员变量, 会调用-(void)setValue:(id)value forUndefineKey 方法, 如果方法不存在会抛出异常</p>
<p>KVC取值是, 方法和成员变量的调用顺序<br>    0.    判断是否有这几个方法 getKey key isKey _key, 依次调用<br>    0.    调用+ (Bool)accessInstanceVairablesDirectkly 勘察是否可以访问成员变量 默认yes<br>    0.    Yes, 可以访问成员变量, 进入下一步<br>    0.    No, 不可以访问成员, 判断是否实现 -(id)valueForUndefinedKey:(NSString *)key, 实现是调用, 未实现报错<br>    0.    判断是否有这几个成员变量 _key _iskey key isKey, 一次调用<br>    0.    判断是否实现 -(id)valueForUNdefineKey:(NSSTring *)key方法, 实现时调用, 未实现报错</p>
<p>KVC可以修改只读. (为什么?)</p>
<p>51 KVO 实现原理</p>
<p>KVO 是通过 isa-swizzling 技术实现的, 在运行时根据原类创建一个中间类 NSKVONotifying_XXX, 这个中间类是原类的子类, 并动态修改当前对象的isa指向中间类, 并且将class方法重写返回原类的 class, dealloc. isKVO方法, ,  所以苹果建议在开发中不应该依赖isa指针, 而是通过class实例方法获取对象类型</p>
<p>重写的类<br>class<br>dealloc<br>set方法<br>isKVO</p>
<p>苹果也会重写对于的set方法, 将原来的setXXX方法转换成C语音的foundation框架的 _NSSetXXXValueAndNofity 函数, 子类拥有自己的set方法实现, set方法实现内部会顺序调用 willChangeValueforKey 原来的setter方法实现, didChangeValueforKey方法. didChangeValueforKey 会调用监听器的方法</p>
<p>KVO可以监听category中的属性, 也是重写了set方法</p>
<p>如何手动触发KVO?</p>
<p>通过实例对象调用willChangeValueForKey 和 didChangeValueForKey, 能否不调用willChangeValueForKey 不调用Didchange? 不可以. 因为didChange内部会检查是否执行了willchange, 如果没有被调用是不会触发监听方法的</p>
<p>通过KVC赋值也会触发KVO.  通过KVC修改成员变量也会触发KVO, 可能内部会调用willchangevalueforkey didchangevalueforkey<br>但是 直接修改成员变量不会触发KVO</p>
<p>52 NSNotification 实现原理<br>    [NSNotificationCenter defaultCenter] addObserver:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; name:&lt;#(nullable NSNotificationName)#&gt; object:&lt;#(nullable id)#&gt;<br>通知中心是单例类, 并且通知中心维护了一个包含所有注册的观察者的集合</p>
<p>首先在初始化 NSNotificationCenter会创建一个对象, 这个对象里面保存了 NamedTable ,unNameTable ,wildcard 和一些其他东西<br>根据传入的参数实例化一个obarvation, observation对象保存了观察者对象, 接收到通知观察者所执行的方法, 以及下一个observation对象的地址<br>根据是否传入notificationName, 选择操作NamedTable 还是NameLessTable<br>若传入了NotificationName, 则会以NotificaitonName为key去查找对应的table(这个table key是object, value 是一个链表), 若找到table, 则取出对应的table. 若未找到对应的table, 则新建一个table, 然后将这个table以NotificaitonName为key添加到NamedTable中<br>若在保存Observation 的table找那个, 以object为key取对应的链表. 若找到了则直接在链表尾部插入之前创建的observation. 若未找到则以之前实例好的Observation对象作为头结点插入进入</p>
<p>NSNotification是同步的</p>
<p>多线程</p>
<p>40 线程和进程</p>
<p>多线程的优点 适当提高程序的执行效率, 适当提高资源利用率 (Cpu, 内存利用率)</p>
<p>缺点: 开启线程需要占用一定的内存空间, 默认情况下, 主线程1M, 子线程512kb, 如果开启大量线程, 会占用大量的内存空间, 降低程序的性能<br>线程越多, cpu在调度线程上的开销就越大<br>程序设计更加复杂, 比如线程之间的通信, 多线程的数据共享</p>
<p>42 NSOperation</p>
<p>NSOperation 是苹果对GCD的面向对象的封装, 他使用起来比GCD更加灵活, 功能更加强大, 虽然会增加一点点额外的开销, 但是却换来了非常强大的灵活性和功能, 我们可以给operation直接添加依赖关系, 取消一个正在执行的opreation, 暂停和回复 operation queue等. NSOperation 和 NSOperationQueue 还提供了判断执行状态, 取消任务, 控制线程数量等更多任务管理的api</p>
<p>添加依赖<br>NSoperationQueue *queue = []<br>NSBlockOperation *op1 = []<br>NSBlockOperation *op2 = []<br>op2.completionBlock = ^{}</p>
<p>[Op1 addDependency:op2]<br>Queue addOperation:op1]</p>
<p>63 GCD</p>
<p>GCD 是基于XNU内核实现的</p>
<p>自动利用CPU的高性能多线程解决方案. 能自动管理分配线程池<br>GCD 有三种队列<br>    0.    主线程队列<br>    0.    全局队列<br>    0.    自定义队列</p>
<p>同步: 只能在当前线程中执行任务, 不具备开启新线程的能力, 任务立刻马上执行, 会堵塞当前线程并等待block中的任务执行完毕, 然后当前线程才会继续往下执行<br>异步: 可以在新的线程中执行任务, 具备开启新线程的能力, 但不一定会开新线程, 当前线程会直接往下执行, 不会堵塞当前线程</p>
<p>线程和队列<br>队列是保存以及管理任务的, 线程负责去队列中取得任务进行执行</p>
<pre><code>0.    dispatch_async</code></pre><p>用来异步执行任务, 可以分成三个阶段, 第一阶段是更新队列链表, 第二部分是从队列取任务, 第三部分是执行任务<br>如果是async到主队列, 则会向主线程的RunLoop发送消息并唤醒Runloop, 接着会在回调函数中取出block并执行<br>如果是async到其他线程, 会检测线程池中可用的线程, 从队列中依次取出任务执行</p>
<pre><code>0.    dispatch_sync</code></pre><p>—向串行队列提交同步任务, 执行的是dispatch_barrier_sync_f函数<br>——如果当前队列没有任务执行, 则调用_dispatch_barrier_sync_f_invoke 执行任务<br>——如果当前队列有任务执行, 等待该队列的任务执行完之后用信号量通知队列继续执行任务<br>—向并发队列提交同步任务<br>——如果队列存在其他任务, 使用信号量等待<br>——没有任务, 直接调用_dispatch_sync_f_invoke执行任务</p>
<pre><code>0.    dispatch_barrier_async</code></pre><p>—如果是全局队列, 和dispath_async一样<br>—如果是串行队列,同dispatch_sync 一样<br>—自定义并行队列<br>——等待前面任务执行完<br>——修改suspend_count保证其他任务不会同步执行<br>——barrier block执行完之后重置suspend_count<br>实现多读单写的功能<br>-(id)objectForKey:(NSString*)key{<br>    dispatch_sync(concurrent_queue),^{}<br>}<br>-(void)setobject:(id)obj{<br>    dispatch_barrier_async(concurrent_queue,^{})<br>}</p>
<p>dispath_barrier_sync 和 dispatch_barrier_async 都会隔离队列中栅栏前后的任务, 不同的是会不会阻塞当前队列</p>
<pre><code>0.    dispatch_group</code></pre><p>dispatch_group本质是初始化一个LONG_MAX的信号量, 等到group中的任务完成其实是等待value回复初始值<br>—dispatch_group_enter 和 _leave必须成对出现, 如果enter比leave多一次, 则wait函数等待的线程不会被唤醒和注册的notify回调block不会执行<br>—如果leave比enter多一次, 则会引起崩溃</p>
<pre><code>0.    dispatch_once </code></pre><p>—用原子性操作block执行完成标记位, 同时用信号量确保只有一个线程执行block, 等block执行完在唤醒所有等待中的线程</p>
<pre><code>0.    Dispatch source 使用最多的就是用来实现定时器, source创建后默认是暂停状态, 需要手动调用 resume 启动定时器. dispatch_after 只是封装调用了dispatch_source定时器, 然后在回调中执行定义的block</code></pre><p>—resume和suspend调用次数需要平衡, 如果重复调用resume则会崩溃<br>—source在suspend状态下, 如果直接设置source=nil或者重新创建source都会造成crash. 正确的方式是在resume状态下调用dispatch_source_cancle(source)后重新创建</p>
<pre><code>0.    dispatch_after 延迟提交,不是延迟执行, 函数依赖于 dipatch_source 定时器, 他注册了一个定时器, 然后在回调函数中执行block

0.    dispatch_apply 类似一种for循环, apply是同步调用,block任务执行N次后才会返回, 用并行队列才能发挥最大的作用, 效率一般快于for循环的串行机制

0.    判断是否是执行线程</code></pre><p>使用dispath_queue_set_specific &amp; dispatch_get_speific 标记并获取指定队列<br>dispatch_queue_t queueA = dispatch_queue_create(“com.lyk.queueA”, NULL);</p>
<pre><code>static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;);
dispatch_queue_set_specific(queueA, &amp;kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease);
dispatch_sync(queueA, ^&#123;
    dispatch_block_t block = ^&#123;
        NSLog(@&quot;NO deadlock!&quot;);
    &#125;;

    CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);

    if (retrievedValue) &#123;
        block();
    &#125; else &#123;
        dispatch_sync(queueA, block);
    &#125;
&#125;);
0.    死锁</code></pre><p>-(void)viewDidload{<br>    [super viewDidLoad];<br>    dispatch_sync(dispatch_get_main_queue(), ^{<br>        NSLog(@“”deallock)<br>    })<br>}<br>同步对于任务是立即执行, 那么当把任务放进主队列是, 他就会立即执行, 只有执行完这个任务, viewDidLoad才会继续往下执行. 由于队列是先进先出原则, 任务有需要等待viewDidLoad执行完毕后才能继续执行. viewDidLoad和这个任务就形成了相互循环等待, 就造成了死锁</p>
<p>GCD面试题1<br>dispatch_queue_t queue = dispatch_Get_global_queue(0,0)<br>dispatch_async(queue, ^{<br>nslog(@“1”)<br>[self performSelector:@selector(test) withObject:nil afterDelay:0.0]<br>NSLog(@“3”)})</p>
<p>只会输出1,3 , test方法不执行, 因为没有runloop</p>
<p>面试题2<br>NSThread *thread = [NSThread alloc]initWithBlock:^{ NSLog(@“1”)}];<br>[thread start]<br>[self perforemSelector:@selector(test) onTheard:thread withObject:nil waitUntilNode:yes]</p>
<p>只输出1, 因为start之后, 线程就结束了, 解决方法, 新增runloop</p>
<p>面试题3<br>63  同步线程<br>Aaa;<br>dispatch_semaphore_t sema = dispatch_semaphore_create(0);<br>AsyncNetRequest^(id response){<br>   // use response<br>dispatch_semaphore_signal(sema, DISPATCH_TIME_FOREVER);<br>Bbb;<br>}<br>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);<br>ccc;</p>
<p>方案2<br>dispatch_group_t disGroup = dispatch_group_create()<br>dispatch_group_enter(group);<br>Aaa;<br>AsyncNetRequest^(id response){<br>   // use response<br>Bbb;<br>dispatch_group_leave(group);<br>}</p>
<p>dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^{<br>    ccc<br>    });</p>
<p>单例</p>
<p>+(id *)shared{<br>Static manager *m = nil<br>Static dispathc_once_t onceToken;<br>dispathc_once(&amp;onceToken, ^{<br>    m = [manager alloc]init];<br>});<br>Return manager<br>}</p>
<pre><code>0.    线程和RunLoop的关系</code></pre><p>—Runloop和线程是一一对应的, 他们的关系保存在一个全局的字典里<br>—对于主线程, runloop在程序一启动就默认创建好了, 但是子线程默认没有创建runloop. 需要使用懒加载的方式去获取</p>
<p>熟悉的第三方库</p>
<p>—Aspects<br>实现原理<br>—通过将目标函数的方法实现改写为转发函数的实现(objc_msgForward), 从而使对目标方法的调用可以走入主流程-方法改写中被改写的转发函数实现中, 从而相当于调用了改写后的方法</p>
<p>—-为什么在forwardInvocation?<br>——因为消息转发的几个阶段的特性不太一样, resolveInstanceMethod:适合给类/对象动态添加一个相应的实现, forwardingTargetForSelector:适合将消息转发给其他对象处理  forwardInvocation: 是里面最灵活, 最能符合需求的<br>——当执行objc_msgForward 会直接触发消息转发机制, 即 forwardInvocation</p>
<p>替换流程<br>—动态创建子类<br>—将子类的forwardInvocation的实现替换成<strong>ASPECTS_ARE_BEING_CALLED</strong><br>—将子类的元类的isa指向原生的类<br>—注册子类<br>—把self对象的isa指针指向子类<br>—添加别名方法<br>—替换原始方法为转发方法 _objc_msgForward</p>
<p>无法hook类方法<br>因为在获取的方法的时候用的是[object class] instanceMethodsignatureForSelector:selector], 如果是类方法, 会返回nil</p>
<p>—SDWebImage<br>—先使用占位图<br>—在缓存里找图片<br>—硬盘里找图片<br>—开始下载图片, 图片下载用NSURLConnection来做<br>—下载成功后, 在NSOperationqueue完成解码<br>—通知主线程宣告解码完成,然后回调展示图片<br>—保存图片到内存和硬盘里<br>源码再看看</p>
<p>如何加载高分辨率的图片<br>—未来避免内存暴增, 将原图剪裁成多个小图, 然后依次绘制到目标位图context中<br>—或者用苹果提供的异步绘制内容的图层CATiedLayer , 不需要加载全部图片, 可以将大图分解成小图片, 然后在载入显示</p>
<p>如何加载一个内存很大的图片: 降低采样率</p>
<p>AsyncDisplayKit<br>将消耗时间的渲染,图片解码, 布局以及其他ui操作等等全部移除主工程, 这样主工程对用户的操作及时作出反应, 达到流畅运行的目的<br>ASDisplayNode用UIView-CALayer 实现了ASNode-&gt;UIView的一种关系. 当不需要相应触摸事件时, ASDisplayNode 可以被设置为layer backed, node刚创建的时候, 并不会在内部创建uiview和calyer, 只有第一次在主线程访问uiview和calyer属性是, 他才会在内部生成相应对象. 当frame改变后, 等待runloop设置内部的uiviiew和layer<br>ASDK的图层预合成. 把一个大的层级绘制到一张图上, 性能会获得很大提升. cpu也避免了创建uikit对象的资源消耗</p>
<p>86 如将一张内存极大的图片可以像地图一样的加载出来<br>使用CATiledLayer加载大图, tilelayer 设置一个缩放区间的集合和重绘阈值, 让让scrollView 在缩放时, 绘制层根据这些区域和缩放阈值去重新绘制当前显示的区域</p>
<p>图片内存大小, 字节数 = 宽高<em>高度</em>4(颜色RGBA占用的4个字节)<br>1.之所有图片的大小与硬盘的占用大小无关是因为硬盘中的图片都是以不同的容器格式被编码了的, 如png, jpeg 等格式, 这些不能被用来直接显示;<br>2.能够被用来直接显示的只有一种格式就是 bitmap 位图的方式. 要从硬盘中的容器格式变成位图,就会经历 图片解码的过程. 而解码后的位图大小计算方式如上</p>
<p>64 实现内存泄漏的检测<br>为nsobject 新增一个属性willDealloc, 然后hook VC的dismiss或者pop方法, 在页面消失之后遍历页面的subviews, 访问新增的属性是否是nil</p>
<p>68 RN的声明周期<br>getDefaultProps<br>getInitalState:创建的时候调用的第一个函数. 对组件的一些状态进行初始化<br>componentWillMount: 控件渲染前触发<br>Render:渲染控件的方法<br>componentDidMount:控件渲染后触发</p>
<p>66<br>请画出一条开始和结束比较慢, 中间比较快的贝塞尔曲线<br>1.创建CAShapeLayer 和 贝塞尔曲线</p>
<p>yellowLayer = [shapeLayer [alloc init]<br>UIBezierPath *path = [UIBezierPath alloc]init]<br>path moveToPoint<br>path addLineToPoint<br>yellowLayer.path = path.cgpath<br>self.view.layer addsubLayer:yellowLayer]<br>2.动画<br>CALayer *car<br>car.frame  = CGRectMake<br>car.contents = (__bridge id _Nullable)([UIImage imageName:@“”].CGImage)<br>CAKeyframeAnimation *ani = [CAkeyframeAnimation animationWithKeyPath:@“position”]<br>Ani.path = yellowLayer.path<br>Ani.duration = 1<br>Ani.atuoreverses = NO<br>Ani.repeatCount = 1<br>Ani.timingFunction = [CAMediaTimingFunction funcitonWithName:kCAMediaTimingFunctionEaseInEaseOut]<br>yellowLayer addSubLayer:car<br>Car addAnimation:ani forKey:@“carAni”</p>
<p>67<br>递归搜索指定目录下指定类型文件的函数</p>
<ul>
<li><p>(NSMutableArray *)filePathArray:(NSString *)directoryPath<br>{<br>  NSMutableArray *mFilePathArray = [NSMutableArray array];<br>  NSFileManager *fileManager = [NSFileManager defaultManager];<br>  //获取当前路径的文件<br>  NSArray *array = [fileManager contentsOfDirectoryAtPath:directoryPath error:nil];<br>  __block BOOL isDir = YES;<br>  [array enumerateObjectsUsingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) {</p>
<pre><code>NSString *path = [directoryPath stringByAppendingPathComponent:obj];
if ([fileManager fileExistsAtPath:path isDirectory:&amp;isDir])&#123;
    if ([path hasSuffix:@&quot;.png&quot;]) &#123;
        [mFilePathArray addObject:path];
    &#125;
    if (isDir) &#123;
        NSLog(@&quot;继续遍历&quot;);
        [mFilePathArray addObjectsFromArray:[self filePathArray:path]];
    &#125;
&#125;</code></pre><p>  }];<br>  return mFilePathArray;<br>}</p>
</li>
</ul>
<p>57 wkwebview 的优点<br>    0.    单独的进程加载url, app进程内存消耗不大, 但是ohter process的内存占比会增加<br>    0.    在uiwebvew上内存占比太大的时候, app process 会crash, 但在wkwebview上当总体的内存占用比较大的时候, webContentProcess 会crash, 从而出现白屏现象<br>    0.    Ios9 有 customUserAgent, 单独页面定制ua<br>    0.    代理回调很多, 比如https权限认证代理方法回调<br>    0.    有一些坑没解决, 比如拦截post请求丢参数<br>    0.    Uiwebview 执行一段简单的js代码, 也会占用app大量内存, 而wkwebview, 不仅有出色的渲染性能, 而且他还有独立进程, 一些网页相关的内存消耗移到自身进程中, 最适合取代uiwebview</p>
<pre><code>0.    39 打通前端与原生的桥梁: JSScore能干那些事情
0.    JavaScriptCore, 原本是WebKit中用来解释执行JavaScript代码的核心引擎
0.    JSCore框架主要由JSVirtualMachine JSContext JSValue类组成
0.    JSVirtualMachine的作用是为JavaScript代码的运行提供一个虚拟机环境
0.    JSContext是JavaScript运行环境的上下文, 负责原生和JavaScript的数据传递
0.    JSValue是JavaScript的值对象, 用来记录JavaScript的原始值, 并提供进行原生值对象转换的接口方法
0.    JavaScriptCore内部是由Parser InterPreter Compiler GC等部分组成
0.    Js调用原生除了Block外, 我们还可以通过JSExport协议来实现在JavaScript中调用原生代码, 也就是原生代码中让遵循JSExport协议的类, 能够供JavaScript使用, 比如Weex
0.    原生调用js全局函数, 需要使用jsvalue的invokeMethod:WithArguments方法</code></pre><p>bridge调用, 拦截 decidePolicyForNavigationAction<br>mk注入js,  [mkwebview.configuration.userContentController addUserScript:<br>时机  WKUserScriptInjectionTimeAtDocumentStart 注入时机为document的元素生成之后,其他内容load之前..  WKUserScriptInjectionTimeAtDocumentEnd 注入时机为document全部load完成,任意子资源load完成之前.</p>
<p>UIWebView 支持全局的cookie可以共享 NSHTTPCookieStorage单利中的cookie而WKWebView不能共享（ WKWebView存储cookie的路径和NSHTTPCookieStorage存储cookie的路径目前是不同的</p>
<p>iOS 11.0后增加了【WKHTTPCookieStore】类，专门用来管理与之关联的WKWebView的Cookie</p>
<p>应用<br>1.获取ios内存</p>
<p>#import &lt;sys/sysctl.h&gt;<br>#import &lt;mach/mach.h&gt;<br>获取当前设备的可用内存 获取到的是字节, 转换成M需要处于1024/1024</p>
<ul>
<li>(double)availableMemory<br>{<br>vm_statistics_data_t vmStats;<br>mach_msg_type_number_t infoCount =HOST_VM_INFO_COUNT;<br>kern_return_t kernReturn = host_statistics(mach_host_self(), <pre><code>HOST_VM_INFO, 
(host_info_t)&amp;vmStats, 
&amp;infoCount);</code></pre>if (kernReturn != KERN_SUCCESS) {<br>  return NSNotFound;<br>}<br>return ((vm_page_size *vmStats.free_count) /1024.0) / 1024.0;<br>}<br>获取当前任务所占的内存</li>
<li>(double)usedMemory<br>{<br>task_basic_info_data_t taskInfo;<br>mach_msg_type_number_t infoCount =TASK_BASIC_INFO_COUNT;<br>kern_return_t kernReturn =task_info(mach_task_self(), <pre><code>TASK_BASIC_INFO, 
(task_info_t)&amp;taskInfo, 
&amp;infoCount);</code></pre>if (kernReturn != KERN_SUCCESS<pre><code>) &#123;</code></pre>  return NSNotFound;<br>}<br>return taskInfo.resident_size / 1024.0 / 1024.0;<br>}</li>
</ul>
<p>2.ios启动周期<br>1.didfinishLaunchingWithOption<br>2.applicationDidBecomeActive</p>
<p>//进入后台<br>2.applicationWillResignActive<br>3.applicationDidEnterBackground</p>
<p>//进入前台<br>4.applicationWillEnterForeground<br>5.applicationDidBecomeActive</p>
<p>App的声明周期<br>1.loadview—不应该被直接调用, 如果self.view 为nil 会调用self.loadview 创建uiview<br>2.viewDidLoad<br>3.viewWillAppear<br>4.viewwillLayoutsubviews<br>5.viewDidLayoutSubviews<br>6.viewDidAppear<br>7.viewWillDisapper<br>8.viewDidDisappear<br>9.viewWillUnload<br>10.viewDidUnload<br>dealloc</p>
<p>3.strlen和sizeof的区别<br>sizeof是求数据类型所占的空间大小,而strlen是求字符串的长度</p>
<p>4.宏最大值<br>#define MAX(x,y) (((x)&gt;(y))?(x):(y))</p>
<p>5 隐式动画和显示动画<br>隐式动画一直存在, 如需隐藏需设置<br>显示动画不存在, 如果显示要创建</p>
<p>6.NSInvocation与PerformSelector区别<br>作用一样, 都可以实现直接调用某个对象的消息<br>在参数个数&lt;= 2的时候performSelector：的使用要简单一些，但是在参数个数 &gt; 2的时候NSInvocation就简单一些</p>
<p>7.autolayout<br>Autolayout基于布局算法CAssowary. autoLayout的核心是一个layout Engine 的布局引擎系统. 每个视图在得到自己的布局之前, layout Engine 会将视图, 约束, 优先级, 固定大小通过计算转换成最终的代销和位置. 在layout engine里, 每当约束发生变化, 都会触发layout, 完成后进入监听约束变化的状态.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/" class="post-title-link" itemprop="url">iOS面试整理(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2021-03-14 15:53:58" itemprop="dateCreated datePublished" datetime="2021-03-14T15:53:58+08:00">2021-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2021-03-16 11:24:54" itemprop="dateModified" datetime="2021-03-16T11:24:54+08:00">2021-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h3><h4 id="1-谈谈对内存管理的理解"><a href="#1-谈谈对内存管理的理解" class="headerlink" title="1.谈谈对内存管理的理解"></a>1.谈谈对内存管理的理解</h4><p>MRC (手动引用计数) 和ARC (自动引用计数)</p>
<ol>
<li><h5 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h5><ul>
<li><p><strong>核心思想：引用计数式内存管理</strong></p>
<ul>
<li><p>四个法则</p>
<ul>
<li><p>自己生成的对象自己持有 (使用 alloc/new/copy/mutableCopy 开头的方法生成对象后持有对象)</p>
</li>
<li><p>非自己生成的对象自己也能持有 (retain)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">&#x2F;&#x2F; 通过autorelease使对象的持有权在AutoreleasePool</span><br><span class="line">[obj retain]; &#x2F;&#x2F; 自己持有对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>不再需要自己持有的对象时释放 (release)</p>
</li>
<li><p>非自己持有的对象不能释放</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象操作对应的方法</p>
<table>
<thead>
<tr>
<th align="center">对象操作</th>
<th align="center">OC中方法</th>
<th align="center">retainCount变化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生成并持有对象</td>
<td align="center">alloc/new/copy/mutableCopy</td>
<td align="center">+1</td>
</tr>
<tr>
<td align="center">持有对象</td>
<td align="center">retain</td>
<td align="center">+1</td>
</tr>
<tr>
<td align="center">释放对象</td>
<td align="center">release</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">废弃对象</td>
<td align="center">dealloc</td>
<td align="center">无</td>
</tr>
</tbody></table>
<ul>
<li>alloc/new方法通过调用 allocWithZone: 类方法分配存储空间并初始化，同时使得retainCount = 1。</li>
<li>调用 retain 方法后引用计数值+1。</li>
<li>调用release方法后引用计数-1。</li>
<li>当retainCount = 0 时，调用 dealloc 方法废弃对象。</li>
</ul>
</li>
<li><p>苹果将引用计数保存在引用计数表中（是一个散列表）</p>
<p>优点：</p>
<ul>
<li>对象内存块的分配无需考虑内存块头部</li>
<li>引用计数表各记录中有内存块地址，可从各个记录追溯到各对象的内存块。（即使对象占用内存块损坏，能够根据引用计数表找到各内存块的位置）</li>
</ul>
</li>
<li><p>autorelease</p>
<ul>
<li>autorelease使得对象在超出其作用作用域（生命周期）后，在废弃autoreleasepool时，其中所有对象的release方法会被调用一次，可以指定变量的作用域。</li>
<li>步骤：<ol>
<li>生成并持有 NSAutoreleasePool 对象</li>
<li>调用已分配对象的 autorelease 对象方法</li>
<li>废弃NSAutoreleasePool对象。（调用 <code>- drain</code> 对象方法）</li>
</ol>
</li>
<li>release 和 autorelease 区别：<ul>
<li>调用 release 方法，对象会立即被释放</li>
<li>调用 autorelease 方法，对象不会立即被释放，而是被注册的 autoreleasepool 中，当autoreleasepool 对象被废弃时（drain），对其中的对象都做一次 release 操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><ul>
<li><p><strong>本质还是引用计数式内存管理</strong></p>
</li>
<li><p><strong>由编译器进行内存管理</strong>。实际上是 编译器 + 运行时库。在编译时，系统自动在合适的位置添加 retain/ release/ dealloc/ autorelease 方法。</p>
</li>
<li><p><strong>所有权修饰符</strong></p>
<p>ARC中通过变量所有权修饰符，不需要使用 retain/release 就能完美满足引用计数式的思考方式：</p>
<p><strong>从手写 release 语句变为通过控制对象的作用域控制对象的释放。</strong></p>
<p>“自己生成的对象自己持有” 和 “非自己生成的对象自己也能持有” 通过对带 <code>__strong</code> 修饰符的变量赋值即可达到，“不再需要自己持有的对象时释放”通过废弃带 <code>__strong</code> 修饰符的变量（变量作用域结束或成员变量所属对象被废弃）或变量赋值（nil）（block中打破循环引用）做到。</p>
<p><code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code> 修饰的自动变量会自动初始化为nil</p>
<p>对象没有被变量强引用着时，该对象被释放。</p>
<ul>
<li><p><code>__strong</code> : id 类型和对象类型默认的所有权修饰符。表示对对象的强引用。</p>
<p>在被 <code>__strong</code> 修饰的变量超出其作用域时，即在该变量被废弃时，会释放其被赋予的对象（随强引用的失效，引用的对象随之释放）。当要废弃被强引用的对象时，要保证所有指向该对象的强引用变量都置为nil。</p>
</li>
<li><p><code>__weak</code> 提供弱引用，弱引用不能持有对象。当持有对象的弱引用时，若该对象被废弃，则此弱引用自动失效，且被置为nil。</p>
<p>使用 <code>__weak</code> 修饰符的变量，就是使用注册到 autoreleasepool中的对象。</p>
</li>
<li><p><code>__unsafe_unretained</code> 声明这个引用不会保持对象的存活，如果对象被废弃，不会被置nil，该变量会变成野指针。使用被其修饰的变量时，先判断是否存在。被其修饰的变量不属于编译器的内存管理对象。</p>
</li>
<li><p><code>__autorelease</code> 在ARC中替代 <code>- autorelease</code> 方法。如果方法名<strong>不以</strong> alloc/new/copy/mutableCopy 开头，编译器自动将返回值的对象注册到 autoreleasepool 中（ init 开头的方法返回的对象不会被注册到 autoreleasepool 中，只是对 alloc 方法返回值的对象）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存泄漏：应当被废弃的对象在超出其生存周期后依然继续存在。</p>
</li>
</ol>
<h4 id="2-ARC如何实现？"><a href="#2-ARC如何实现？" class="headerlink" title="2.ARC如何实现？"></a>2.ARC如何实现？</h4><p>通过变量所有权修饰符，满足引用计数式内存管理。</p>
<p>编译器+运行时。</p>
<p>==通过运行时发送消息，通过编译器自动插入release==。</p>
<ul>
<li><p><code>__strong</code> 修饰符</p>
<ul>
<li><p>使用 alloc/new/copy/mutableCopy 产生对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	id __strong obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; obj_msgSend(NSObject, @selector(alloc));</span><br><span class="line">obj_msgSend(obj, @selector(init));</span><br><span class="line">obj_release(obj); &#x2F;&#x2F; 编译器插入</span><br></pre></td></tr></table></figure>

<p>两次调用 <code>obj_msgSend()</code> 方法，在作用域结束调用 <code>obj_release</code> 释放对象。编译器自动插入了release。</p>
</li>
<li><p>非 alloc/new/copy/mutableCopy 产生对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong obj &#x3D; [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; objc_magSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleaseReturnValue(obj); &#x2F;&#x2F; 编译器插入</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>

<p><code>objc_retainAutoreleaseReturnValue()</code> 函数用于持有对象，但持有的对象应为函数的返回值或者注册在 autoreleasepool 中的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    id obj &#x3D; objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">  	objc_msgSend(obj, @selector(init));</span><br><span class="line">  	return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>obj_autoreleaseReturnValue()</code> 时，如果方法或函数的调用方在调用了方法或函数后紧接着调用了 <code>objc_retainAutoreleaseReturnValue()</code> 函数，那么就不将返回的对象注册到 autoreleasepool 中-而是直接传递给方法或函数的调用方。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-对MRC的理解"><a href="#3-对MRC的理解" class="headerlink" title="3.对MRC的理解"></a>3.对MRC的理解</h4><h4 id="4-GC（垃圾回收）和ARC的区别？"><a href="#4-GC（垃圾回收）和ARC的区别？" class="headerlink" title="4.GC（垃圾回收）和ARC的区别？"></a>4.GC（垃圾回收）和ARC的区别？</h4><ul>
<li><p>ARC 相比 GC 优点：</p>
<ul>
<li><p>ARC 工作在编译期，在运行时没有额外的开销。</p>
</li>
<li><p>ARC 的内存回收是平稳进行的，当对象不被持有时会立即被回收。</p>
<p>GC 的内存回收时需要暂停程序，会有一定的卡顿。</p>
</li>
</ul>
</li>
<li><p>ARC 相比 GC 缺点：</p>
<ul>
<li>==ARC 需要手动处理循环引用等内存管理问题，GC 不需要。==</li>
</ul>
</li>
</ul>
<h4 id="5-内存关键字（assign-weak-strong-copy-retain-介绍"><a href="#5-内存关键字（assign-weak-strong-copy-retain-介绍" class="headerlink" title="5.内存关键字（assign, weak, strong, copy, retain)介绍"></a>5.内存关键字（assign, weak, strong, copy, retain)介绍</h4><ul>
<li><p>assign：用于非对象类型。其 setter 方法只是执行简单的赋值操作。</p>
</li>
<li><p>weak：用于对象类型，表示弱引用。其 setter 方法中既不保留新值，也不释放旧值，同assign类似。</p>
<p>但是在属性所指对象遭到废弃时，属性值会被置nil。</p>
</li>
<li><p>strong：用于<strong>除</strong> NSString/block 之外的对象类型，表示一种“拥有关系”，表示对对象的持有和强引用。其 setter 方法中，先 relsease 旧值，再 retain 新值。</p>
</li>
<li><p>copy：所表达的所述关系与 strong 类似。在其 setter 方法中，不保留新值，而是将其 copy。当属性类型为 NSString 类型时，通过 copy 关键字保护器封装性，防止指向 MutableString 类型。</p>
</li>
<li><p>retain：MRC中使用，作用同 strong 相同。</p>
</li>
</ul>
<h4 id="6-weak和strong关键字内部做了什么？"><a href="#6-weak和strong关键字内部做了什么？" class="headerlink" title="6.weak和strong关键字内部做了什么？"></a>6.weak和strong关键字内部做了什么？</h4><h4 id="7-除了NSString什么情况下用copy？block为什么要复制到堆中？"><a href="#7-除了NSString什么情况下用copy？block为什么要复制到堆中？" class="headerlink" title="7.除了NSString什么情况下用copy？block为什么要复制到堆中？"></a>7.除了NSString什么情况下用copy？block为什么要复制到堆中？</h4><ol>
<li><p>带有可变类型的对象，比如 NSArray、NSDictionary等。</p>
<ul>
<li>因为父类指针能够指向子类对象，使用 copy 的目的是让本对象的属性不受外界影响，使用 copy 后无论传入的是可变还是不可变的对象，==本身持有的就是一个不可变对象==。</li>
<li>当用 strong 时，该属性可能指向一个可变对象，如果这个对象在外部被修改了，那么就会修改该属性。</li>
</ul>
</li>
<li><p>用作 block 的关键字。</p>
<p>在 ARC中，对 block 使用 strong 和 copy 效果一样，ARC 中会自动将栈上的 block 拷贝到堆中。这里使用 copy 关键字是为了提醒我们这里的 block 被复制到了堆中。</p>
<p><strong>扩展：block 为什么要复制到堆中？</strong></p>
<p>将栈中的 block 复制到堆上，这样即使 block 语法记述的变量作用域结束，堆上的 block 还可以继续存在。</p>
<p>当 block 从栈复制到堆时，block 中使用的 <code>__block</code> 变量也全部从栈复制到堆中，此时 blcok <strong>持有</strong> <code>__block</code> 变量。如果堆上的 block 被废弃，那么它使用的 <code>__block</code> 变量也就被释放。</p>
</li>
</ol>
<h4 id="8-调用静态方法（类方法）时需要release么？"><a href="#8-调用静态方法（类方法）时需要release么？" class="headerlink" title="8.调用静态方法（类方法）时需要release么？"></a>8.调用静态方法（类方法）时需要release么？</h4><p>静态方法（类方法）创建的对象自动加入了自动释放池中，所以不需要release。</p>
<h4 id="9-autorelease，AutoreleasePool的原理是什么？"><a href="#9-autorelease，AutoreleasePool的原理是什么？" class="headerlink" title="9. autorelease，AutoreleasePool的原理是什么？"></a>9. autorelease，AutoreleasePool的原理是什么？</h4><p>autoreleasepool 以==队列数组的形式==实现，主要通过3个函数完成：</p>
<p>1.<code>objc_autoreleasePoolPush</code> </p>
<p>创建 autoreleasepool，相当于NSAutoreleasePool  *pool = [[NSAutoreleasePool alloc] init]。</p>
<p>2.<code>objc_autoreleasePoolPop</code> </p>
<p>倾倒 autoreleasepool，相当于 [pool drain]。</p>
<p>3.<code>objc_autorelease</code></p>
<p>将对象加入 pool 中。</p>
<p><strong>扩展</strong>：如果 autorelease NSAutoreleasePool对象会如何？</p>
<p>答：<strong>发生异常</strong>。无论调用哪一个对象的 autorelease 实例方法，实际上是调用 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已经被重载，因此运行时会出错。</p>
<h4 id="10-autoreleasepool的drain时机"><a href="#10-autoreleasepool的drain时机" class="headerlink" title="10.autoreleasepool的drain时机"></a>10.autoreleasepool的drain时机</h4><ul>
<li><p>手动创建的 autoreleasepool（指定的autoreleasepool）：当作用域大括号结束时释放。</p>
</li>
<li><p>系统创建的 autoreleasepool（不指定autoreleasepool）：autorelease 对象出作用域后，被添加到==最近一次创建的== autoreleasepool 中，==在当前 runloop 结束时释放==。</p>
<ul>
<li><p>当 runloop 检测到事件并启动后，会自动创建一个 autoreleasepool 。</p>
</li>
<li><p>所有延迟释放的对象都被添加到这个 autoreleasepool 中。</p>
<p>所有 autorelease 的对象，在<strong>出了作用域之后</strong>，会被自动添加到<strong>最近创建的自动释放池中</strong>。</p>
</li>
<li><p>当 runloop 即将结束时，倾倒 autoreleasepool ，向其中所有的对象发送 release 消息后，autoreleasepool 被销毁。</p>
</li>
</ul>
</li>
</ul>
<h4 id="11-autoreleasepool的作用"><a href="#11-autoreleasepool的作用" class="headerlink" title="11.autoreleasepool的作用"></a>11.autoreleasepool的作用</h4><p>ARC中，不允许使用 autorelease 方法，每个 runloop 循环中系统都自动加入了autoreleasepool 的创建和释放</p>
<p>但是，==在需要创建和销毁大量对象时（大数的 for 循环中创建和销毁对象），使用手动创建的 autoreleasepool 可以避免内存峰值的出现==。如果不手动创建，被加入系统创建的 autoreleasepool 中的对象在 runloop 结束时才会被统一执行 release 操作，如果在 for 循环内部创建 autoreleasepool，那么每循环一次都会执行 release 操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        NSString* string &#x3D; @&quot;ab c&quot;;</span><br><span class="line">        NSArray* array &#x3D; [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-iOS中堆栈的理解？"><a href="#12-iOS中堆栈的理解？" class="headerlink" title="12.iOS中堆栈的理解？"></a>12.iOS中堆栈的理解？</h4><ul>
<li>堆栈的区别<ul>
<li>堆空间的内存是动态分配的，一般存放对象，需要手动释放。</li>
<li>栈空间的内存是系统自动分配的，一般存放局部变量等，系统自动回收。</li>
</ul>
</li>
</ul>
<h4 id="13-weak在对象销毁时使指向对象的指针置nil的原理？"><a href="#13-weak在对象销毁时使指向对象的指针置nil的原理？" class="headerlink" title="13.weak在对象销毁时使指向对象的指针置nil的原理？"></a>13.weak在对象销毁时使指向对象的指针置nil的原理？</h4><ul>
<li>使用<strong>哈希表（散列表实现</strong>）<ul>
<li>key：对象的内存地址。</li>
<li>value：被__weak修饰的变量的地址。</li>
</ul>
</li>
<li>当对象被废弃时发生：<ul>
<li>从weak表中获取被废弃对象的地址为key的记录。（<strong>获取记录</strong>）</li>
<li>将包含在记录中所有被<code>__weak</code>修饰的变量的地址，赋值为nil。(<strong>赋值为nil</strong>)</li>
<li>从weak表中删除记录。(<strong>删除记录</strong>)</li>
<li>从引用技术表中删除被废弃对象的地址为键值的记录。</li>
</ul>
</li>
</ul>
<h4 id="14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？"><a href="#14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？" class="headerlink" title="14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？"></a>14.block作为viewControler属性时，如果block块中使用了<code>self.view</code>会发生循环引用么？</h4><p>会发生。</p>
<p>在block代码块之前使用<code>__weak typeof(self) weakSelf = self;</code>，打破闭环。</p>
<h3 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h3><h4 id="1-对多线程的理解？"><a href="#1-对多线程的理解？" class="headerlink" title="1.对多线程的理解？"></a>1.对多线程的理解？</h4><p>进程：CPU分配资源和调度的最小单位</p>
<p>线程：CPU执行任务的最小单位</p>
<h4 id="2-iOS中实现多线程的方式有哪些？"><a href="#2-iOS中实现多线程的方式有哪些？" class="headerlink" title="2.iOS中实现多线程的方式有哪些？"></a>2.iOS中实现多线程的方式有哪些？</h4><h4 id="3-GCD和NSOperation优缺点？"><a href="#3-GCD和NSOperation优缺点？" class="headerlink" title="3.GCD和NSOperation优缺点？"></a>3.GCD和NSOperation优缺点？</h4><ul>
<li>GCD是纯C语言的 API，NSOperation 是基于 GCD 的面向对象的封装。</li>
<li>NSOperation 可以轻松在 operation 间设置依赖，设置它们的优先级，任务能够被方便地暂停、恢复，可以自定义子类。可以将 KVO 应用在 NSOperation 中，监听一个 operation 是否完成、取消、正在执行。可以设置最大并发数。</li>
<li>GCD 以 block 为单位，代码简洁，更为轻量化。对于一次性运算，或是仅仅为了加快现有方法的运算速度，选择轻量化的 GCD 更为方便。</li>
</ul>
<h4 id="4-死锁发生的原因是什么？如何避免？"><a href="#4-死锁发生的原因是什么？如何避免？" class="headerlink" title="4.死锁发生的原因是什么？如何避免？"></a>4.死锁发生的原因是什么？如何避免？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autorelease &#123;</span><br><span class="line">	dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;发生死锁&quot;)；</span><br><span class="line">    &#125;)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步函数，会把 block 加入指定队列中，<strong>会一直等待 block 执行完成才返回。</strong>因此在 block 执行完之前，调用同步函数的线程是<strong>阻塞的</strong>。</p>
<p>异步函数，会把 block 加入指定队列中，<strong>不会等待 block 执行，会立即返回。</strong>只负责向队列中添加任务。</p>
<p>串行队列：按照任务的添加顺序执行任务。并且保证在执行某个任务时，它前面进入队列的任务都执行完了。</p>
<p>并发队列：按照任务的添加顺序 <strong><em>开始</em></strong> 执行任务。任务执行的结束时间不确定，取决于每个任务的耗时。</p>
<p><strong>原因：主线程是串行的，在执行同步函数时被阻塞，同步函数要求 block 块执行完毕后才返回，这样主线程才能继续向下执行；由于在主线程中，执行 block 块要求同步函数执行完毕才进行，这样就造成了双方的</strong><em>互相等待</em><strong>，导致了死锁的发生。</strong></p>
<blockquote>
<p><strong><em>导致死锁的原因一定是：在某个串行队列中，同步地向这个队列添加任务。(在串行队列中，同步函数向相同串行队列中添加任务)</em></strong></p>
</blockquote>
<p><strong>注意：</strong>发生死锁要具体分析同步函数所在的队列是并发队列还是串行队列，并且 block 要添加到哪种队列。</p>
<ul>
<li>如果使用异步函数添加任务，无论任务是否添加到串行队列都不会发生死锁，因为异步函数不会阻塞线程。</li>
<li>只在解决数据竞争问题时使用串行队列。</li>
</ul>
<p>使用同步函数 + 串行队列的组合<strong>不一定</strong>会发生死锁。同步函数所在的串行队列和要添加任务的队列不同时，不会发生死锁。</p>
<h4 id="5-iOS中有哪些锁？"><a href="#5-iOS中有哪些锁？" class="headerlink" title="5.iOS中有哪些锁？"></a>5.iOS中有哪些锁？</h4><p>锁：一段代码在一段时间内只能被一个线程访问。</p>
<p>NSLock </p>
<p>NSCondition 条件锁</p>
<p>NSConditionLock 条件锁</p>
<p>NSRecursiveLock 递归锁</p>
<h4 id="6-iOS中线程安全有哪些情况？"><a href="#6-iOS中线程安全有哪些情况？" class="headerlink" title="6.iOS中线程安全有哪些情况？"></a>6.iOS中线程安全有哪些情况？</h4><p>死锁，数据竞争，优先级反转</p>
<h4 id="7-多线程操作对同一块资源发生数据竞争时能怎样做？"><a href="#7-多线程操作对同一块资源发生数据竞争时能怎样做？" class="headerlink" title="7.多线程操作对同一块资源发生数据竞争时能怎样做？"></a>7.多线程操作对同一块资源发生数据竞争时能怎样做？</h4><ul>
<li><p>互斥锁 <code>@synchronized</code></p>
<ul>
<li>优点：不需要在代码中显式地创建锁对象，就能实现锁的机制。</li>
<li>缺点：消耗大量CPU资源。</li>
</ul>
</li>
<li><p>串行队列：一个串行队列就会开一条子线程，多个串行队列并发执行，可以用<code>dispath_set_target_queue</code>设置执行阶层。将不同的串行队列设置到新的串行队列中串行执行。</p>
</li>
<li><p>栅栏函数：使用并发队列和栅栏函数能实现高效的数据库访问和文件访问。</p>
</li>
<li><p>信号量：当信号量为1时可以当做锁使用。控制同时访问特定资源的线程数量。优势在于等待时不会消耗CPU资源。</p>
<ul>
<li><p><code>dispatch_semaphore_create(long value)</code> 创建信号量，括号中的数字表示能允许同时操作的线程数量。</p>
</li>
<li><p><code>dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)</code></p>
<p>第一个参数：信号量</p>
<p>第二个参数：阻塞时间。表示如果信号量为0时阻塞线程的时间。DISPATCH_TIME_FOREVER 表示永久阻塞。</p>
<p>当信号量 = 0 时，函数返回1，表示需要等待，不允许操作。</p>
<p>当信号量 &gt;= 1是，函数返回0，表示不需要等待，继续执行操作。<strong>并把信号量 - 1</strong></p>
</li>
<li><p><code>dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)</code></p>
<p>执行完操作后调用，将信号量 + 1。</p>
</li>
<li><pre><code class="objective-c">NSMutableArray *array = [[NSMutableArray alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
for (int i = 0; i &lt; 100; i++) &#123;
    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 信号量是0时等待，非0时，经过dispatch_semaphore_wait函数后信号量-1，其他线程等待
        [array addObject:[NSNumber numberWithInteger:i]];
        NSLog(@&quot;%d---%ld---%@&quot;, i, array.count, [NSThread currentThread]);
        dispatch_semaphore_signal(semaphore); // 信号量+1
    &#125;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NSLock</span><br><span class="line"></span><br><span class="line">  - 通过 &#96;- (void)lock &#96;和 &#96;- (void)unlock &#96;配对使用实现代码的锁定，只能执行被锁定的代码。需要使用相同的锁对象才能实现互斥。</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;objective-c</span><br><span class="line">    &#x2F;&#x2F; 实例类person</span><br><span class="line">    Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 创建锁</span><br><span class="line">    NSLock *myLock &#x3D; [[NSLock alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 线程A</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];	&#x2F;&#x2F; 锁定</span><br><span class="line">        [person personA];</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 线程B</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];  &#x2F;&#x2F; 锁定</span><br><span class="line">        [person personB];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><code>- (BOOL)tryLock</code>：尝试锁定，如果加锁失败（已经被锁定）返回NO，不会阻塞线程。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p>
<p><code>- (BOOL)lockBeforeDate:(NSDate *)limit</code>：在date时间之前尝试锁定，如果在date时间内都不能完成锁定，返回NO。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p>
</li>
</ul>
</li>
<li><p>NSCondition：最基本的条件锁，手动控制线程 wait（等待）和 signal （继续）</p>
<ul>
<li><p><code>[condition lock]</code> 锁定代码，其他线程的命令需要在lock 外等待，只到unlock ，才可访问。</p>
</li>
<li><p><code>[condition unlock</code> 与lock 同时使用。</p>
</li>
<li><p><code>[condition wait]</code> 让当前线程处于等待状态。</p>
</li>
<li><p><code>[condition signal]</code> CPU发信号告诉线程不用在等待，可以继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *condition &#x3D; [[NSCondition alloc] init];</span><br><span class="line"></span><br><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        if ([products count] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            NSLog(@&quot;wait for product&quot;);</span><br><span class="line">            [condition wait];  &#x2F;&#x2F; 线程等待</span><br><span class="line">        &#125;</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [condition signal];  &#x2F;&#x2F; 恢复线程</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>NSConditionLock：条件锁，可以设置加锁/解锁条件，只有满足条件时才能加锁/解锁。</p>
<ul>
<li><p><code>- (void)lockWhenCondition:(NSInteger)condition</code> 满足条件时才能加锁。</p>
</li>
<li><p><code>- (void)unlockWithCondition:(NSInteger)condition</code> 满足条件时才能解锁。</p>
</li>
<li><p><code>- (BOOL)tryLockWhenCondition:(NSInteger)condition</code> 满足条件尝试加锁。</p>
</li>
<li><p><code>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit</code> 满足条件在limit时间内尝试加锁。</p>
</li>
<li><p>同时 NSLock 的相关方法依旧能够使用，可以使用 <code>- lock</code>  和 <code>- unlock</code> 方法加锁或解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line">NSInteger HAS_DATA &#x3D; 1;</span><br><span class="line">NSInteger NO_DATA &#x3D; 0;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [lock lockWhenCondition:NO_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [lock unlockWithCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        NSLog(@&quot;wait for product&quot;);</span><br><span class="line">        [lock lockWhenCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [lock unlockWithCondition:NO_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>NSRecursiveLock：递归锁，这个锁可以被同一线程多次使用，而不会引起死锁。主要用在循环及递归操作中。递归锁会跟踪它被 lock 的次数。每次成功的 lock 都必须平衡调用 unlock 操作。只有这样锁才会被最终释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NSLock *lock &#x3D; [[NSLock alloc] init];</span><br><span class="line">NSRecursiveLock *lock &#x3D; [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line"></span><br><span class="line">    RecursiveMethod &#x3D; ^(int value) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;value &#x3D; %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);	&#x2F;&#x2F; 递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里如果把锁对象换为 NSLock 类型的话，从第二次递归调用开始会发生死锁。因为每次进入 block 都会加一把锁，从第二次开始因为已经加了锁并且没有解锁， 所以要等待解锁，造成了死锁，造成线程阻塞而 crash。如果换成 NSRecursiveLock 类就不会造成死锁。</p>
</li>
</ul>
<h4 id="8-atomic实现原理"><a href="#8-atomic实现原理" class="headerlink" title="8.atomic实现原理"></a>8.atomic实现原理</h4><p>atomic为原子属性，为setter方法加互斥锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic, assign)int age;</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">	@synchronized(self)&#123;</span><br><span class="line">        _age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>atomic 和 nonatomic 比较</p>
<ul>
<li><p>atomic：线程安全（并非真正安全），需要消耗大量CPU资源。</p>
<p>例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>
</li>
<li><p>nonatomic: 非线程安全，适合移动设备。</p>
</li>
</ul>
</li>
</ul>
<h4 id="9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？"><a href="#9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？" class="headerlink" title="9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？"></a>9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？</h4><p><code>dispatch_sync()</code> 向<strong>当前线程</strong>中添加一个任务到指定队列</p>
<ul>
<li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列是同一个串行队列。串行队列中的任务是上一个任务执行完毕才会执行下一个任务。<code>dispatch_sync()</code>会将Block任务添加到队列尾部，等队列中所有任务执行完毕后才会执行；<code>dispatch_sync()</code> 需要Block任务执行完毕才会返回，造成互相等待。</p>
<p><strong>在追加Block执行结束之前，<code>dispach_sync</code> 会一直等待，等待意味着线程停止。</strong></p>
</li>
<li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列不是同一个队列。系统会在当前线程中新开一条指定队列，并加入Block任务到新开队列中，Block任务被执行并返回，然后<code>dispatch_sync()</code> 返回。指定队列无论是串行和并行的，在<code>dispatch_sync()</code> 所在队列中串行执行任务，因为<code>dispatch_sync()</code>  是阻塞的。</p>
</li>
<li><p><code>dispatch_async()</code> 新开线程执行任务，不等Block执行完毕就返回。</p>
</li>
</ul>
<h4 id="10-为什么使用atomic关键字的对象不一定是线程安全的？"><a href="#10-为什么使用atomic关键字的对象不一定是线程安全的？" class="headerlink" title="10.为什么使用atomic关键字的对象不一定是线程安全的？"></a>10.为什么使用atomic关键字的对象不一定是线程安全的？</h4><p>使用atomic只能保证 setter 方法和 getter 方法是线程安全的。但是仍然可能出现线程不安全的情况：</p>
<p><code>@property(atomic, strong)NSMutableArray *array</code>一个线程循环读数据，另一个线程循环存数据，这时就不是线程安全的，因为跟 setter 和 getter 方法没有关系。比如使用<code>[array addObject:object]</code>向数组中添加对象，因为不涉及到 setter 和 getter 方法，故不是线程安全的。</p>
<ul>
<li><p>多线程数据为什么不安全？</p>
<p>每条线程都有自己独立的栈空间，但是它们公用堆空间，所以可能同时访问同一块内存空间，因此造成数据竞争。</p>
</li>
</ul>
<h3 id="三、UI"><a href="#三、UI" class="headerlink" title="三、UI"></a>三、UI</h3><h4 id="1-UITableView优化"><a href="#1-UITableView优化" class="headerlink" title="1.UITableView优化"></a>1.UITableView优化</h4><ol>
<li><p>使用 UITableViewCell 重用机制。</p>
</li>
<li><p>利用 RunLoop 空闲时间执行预缓存任务。</p>
<p>利用 RunLoopObserver 观察当前 RunLoop 的运行状态，并在状态切换时收到通知。</p>
<p>在 RunLoop 即将进入睡眠时使用。</p>
</li>
<li><p>将预缓存任务分解到多个 RunLoop 中执行。</p>
</li>
</ol>
<h4 id="2-UITableViewCell重用机制的原因和原理是什么？"><a href="#2-UITableViewCell重用机制的原因和原理是什么？" class="headerlink" title="2.UITableViewCell重用机制的原因和原理是什么？"></a>2.UITableViewCell重用机制的原因和原理是什么？</h4><ul>
<li><p>关键：</p>
<ul>
<li>==可变数组<code>NSMutableArray *visiableCells</code>  保存屏幕正在显示的cell。==</li>
<li>==可变字典<code>NSMutableDictionary *reusableTableCells</code> 保存可重复利用的cell, key是重用标识identifier。==</li>
<li>==<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 从<code>reusableTableCells</code>中根据identifier取可被重用的cell。==</li>
</ul>
</li>
<li><p>原因：设备内存有限，TableView中有许多cell，而屏幕只能显示有限个cell，如果根据数据将cell全部创建完毕，会造成很大的内存负担。屏幕外的cell不需要立即创建，当滑动屏幕浏览cell时再加载。</p>
</li>
<li><p>作用：<strong>只创建了屏幕可显示的最大cell数+1个cell</strong>，然后循环使用这些cell，同时改变cell显示的数据，达到节省空间的目的。</p>
</li>
<li><p>原理：</p>
<ul>
<li><p>第一次执行<code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code> 方式时，<code>reusableTableCells</code>为空，<code>[tableView dequeueReusableCellWithIdentifier:idertifier forIdentifiter:identifiter]</code> 方法的返回值为nil。</p>
<p>此时通过<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifier:identifier]</code> 创建新的cell。</p>
</li>
<li><p>当数据很多，整个屏幕的cell显示不完全时</p>
<ol>
<li>调用<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifiter:identifier]</code> <strong>创建整个屏幕能显示的cell个数+1个cell</strong>（滑动屏幕时，第一个cell还没移出，最后一个cell已经出现），并且制定标识符identifier。</li>
<li>将创建并显示除最后一个外的cell加入<code>visiableCells</code> 数组，此时<code>reusableTableCells</code>字典为空。</li>
<li>滑动屏幕时，顶端的cell移出屏幕，该cell从<code>visiableCells</code> 数组中移除，并加入到<code>reusableTableCells</code> 字典中，key为该cell的identifier。将最后一个cell加入到<code>visiableCells</code> 数组中。</li>
<li>继续滑动时，<code>reusableTableCells</code> 中已经有值。需要显示新的cell时，<code>cellForRowAtIndexPath</code> 再次被调用，执行<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 方法，返回一个标识为identifier的cell。该cell从<code>reusableTableCells</code> 中移除，添加到<code>visableCells</code> 中，如果<code>resuableTableCells</code> 中没有identifier类型的cell，就会创建一个；同时，移出屏幕的cell从<code>visiableCells</code> 中移除，添加到<code>resuableTableCells</code> 中。</li>
</ol>
</li>
<li><p>iOS6中新方法</p>
<p><code>[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier]</code></p>
<p>当从<code>reusableTableCells</code> 中取cell时，如果没有，系统会自动创建给定类型的cell；如果有，直接重用。</p>
<p>在<code>cellForRowAtIndexPath</code> 中只需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)table:(UITableView *)tableView cellForRowAtIdexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">  &#x2F;&#x2F; 系统会自动判断cell是否存在，不需要手动判断。</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifiter:identifiter forIndexPath:indexPath];</span><br><span class="line">  return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="3-怎样裁剪圆头像"><a href="#3-怎样裁剪圆头像" class="headerlink" title="3.怎样裁剪圆头像"></a>3.怎样裁剪圆头像</h4><h4 id="4-自定义控件的封装"><a href="#4-自定义控件的封装" class="headerlink" title="4.自定义控件的封装"></a>4.自定义控件的封装</h4><h4 id="5-viewController生命周期"><a href="#5-viewController生命周期" class="headerlink" title="5.viewController生命周期"></a>5.viewController生命周期</h4><p><img src="http://img.blog.csdn.net/20130614155652265" alt="viewController声明周期"></p>
<ol>
<li><code>viewWillAppear</code> 之后，<code>viewDidAppear</code> 之前会调用 <code>viewWillLayoutSubviews</code> 和<code>viewDidLayoutSubviews</code> ，可以修改subviews。</li>
<li><code>-loadView</code> 中初始化view, 由系统调用，==在 viewController 的 view 被访问并且为nil时调用==（<code>self.view = …</code>），可能被调用多次。</li>
</ol>
<h4 id="6-改变UIButton的点击面积"><a href="#6-改变UIButton的点击面积" class="headerlink" title="6.改变UIButton的点击面积"></a>6.改变UIButton的点击面积</h4><p>重写<code>UIButton</code>的<code>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code>方法。</p>
<p>该方法返回<code>BOOL</code>值表示判断当前的点击或触摸事件是否在当前的UIView中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@inplementation NewButton</span><br><span class="line"></span><br><span class="line">-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">	CGRect bounds &#x3D; self.bounds;</span><br><span class="line">	bounds &#x3D; CGRectInset(bounds, -50, -50);  &#x2F;&#x2F; 该按钮上下左右范围各扩大了50.</span><br><span class="line">	return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>bounds = CGRectInset(bounds, -50, -50)</code> 后两个参数是在左右方向和上下方向扩大或缩小的长度，正值表示缩小，负值表示扩大。该行代码表示在水平和竖直方向各扩大了100。</p>
<p>苹果要求：点击的热点区域不小于44*44 pt。</p>
<h4 id="7-UIView、UIButton-、UITableView的继承关系"><a href="#7-UIView、UIButton-、UITableView的继承关系" class="headerlink" title="7.UIView、UIButton 、UITableView的继承关系?"></a>7.UIView、UIButton 、UITableView的继承关系?</h4><p>UIView -&gt; UIResponder -&gt; NSObject</p>
<p>UIButton -&gt; UIControl -&gt; UIView - &gt; UIResponder -&gt; NSObject</p>
<p>UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject</p>
<h3 id="四、设计模式"><a href="#四、设计模式" class="headerlink" title="四、设计模式"></a>四、设计模式</h3><h4 id="1-KVO的原理？"><a href="#1-KVO的原理？" class="headerlink" title="1.KVO的原理？"></a>1.KVO的原理？</h4><p>KVO的实现依赖于Runtime，使用isa混写（isa-swizzling）实现。当观察对象A时，KVO机制动态的创建对象A当前类的子类，并为这个新类重写了被观察属性的setter方法，在setter方法中通知观察对象属性的改变情况。将对象A的isa指针的指向修改为创建的新类。</p>
<ul>
<li><p>具体实现</p>
<ul>
<li><p>当观察对象A时，KVO机制<strong>动态地创建一个名为<code>NSKVONotifying_A</code>的新类</strong>，该类继承自对象A原来的类，并<strong>重写了被观察属性值的setter方法</strong>。重写的setter方法负责在调用原setter方法<strong>之前</strong>和<strong>之后</strong>，通知所有观察对象：属性值得更改。最后通过<strong>isa混写（isa-swizzling）</strong>把这个对象的isa指针指向新创建的子类，对象变成了新创建子类的实例。</p>
</li>
<li><p>setter方法剖析：</p>
<p>KVO依赖于两个方法<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code>，在原setter方法之前和之后分别调用。重写setter方法的注入是在<strong>运行时</strong>而不是在编译时。</p>
<ul>
<li><code>-willChangeValueForKey:</code>在<strong>属性值发生改变之前</strong>即原setter方法之前调用，通知keyPath属性值即将发生改变。</li>
<li><code>-didChangeValueForKey:</code>在<strong>属性值发生改变之后</strong>即原setter方法之后调用，通知keyPath属性值已经发生改变。</li>
<li>之后<code>-observerValueForKeyPath:ofObject:change:context</code>也会被调用</li>
</ul>
</li>
<li><pre><code class="objective-c">- (void)setName:(NSString *)newName &#123;
    [self willChangeValueForKey:@&quot;name&quot;];
      [super setValue:newName forKey:@&quot;name&quot;];    // 调用父类的存取方法,KVC实现
      [self didChangeValueForKey:@&quot;name&quot;];
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用前提</span><br><span class="line"></span><br><span class="line">  KVO被观察的是对象属性，只有__通过setter方法__或__KVC方法__修改对象属性时KVO才能被触发，使用KVO机制的__*前提是遵循KVO的属性设置方式来变更属性值*__。</span><br><span class="line"></span><br><span class="line">#### 2.手写KVO观察对象过程：</span><br><span class="line"></span><br><span class="line">1. 为__观察的对象__注册观察者</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;objective-c</span><br><span class="line">   &#x2F;* 第一个参数：观察者，负责处理监听事件的对象</span><br><span class="line">      第二个参数：被观察的属性</span><br><span class="line">      第三个参数：被观察属性新旧值得一些配置</span><br><span class="line">      第四个参数：上下文，可以为KVO回调方法传值 *&#x2F;</span><br><span class="line">   [self.person addObserver:self </span><br><span class="line">    			  forKeyPath:@&quot;name&quot; </span><br><span class="line">                    options:NSKeyValueObservingOptionNew |</span><br><span class="line">                            NSKeyValueObservingOptionOld </span><br><span class="line">                    context:nil];</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>被观察的属性发生变化时，收到通知，调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 第一个参数：被观察的属性</span><br><span class="line">   第二个参数：被观察的对象</span><br><span class="line">   第三个参数：改变的属性值，前后的变化都存在字典中</span><br><span class="line">   第四个参数：上下文，context传递的值 *&#x2F;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath object:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if([keyPath isEqualToString:@&quot;name&quot;] &amp;&amp; object &#x3D;&#x3D; self.person) &#123;</span><br><span class="line">        &#x2F;&#x2F; 响应变化处理</span><br><span class="line">      	NSLog(@&quot;new:%@, old:%@&quot;, [change valueForkey:@&quot;old&quot;], [change valueForKey:@&quot;new&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>-dealloc</code>方法中注销观察者 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-怎样手动触发KVO？"><a href="#3-怎样手动触发KVO？" class="headerlink" title="3. 怎样手动触发KVO？"></a>3. 怎样手动触发KVO？</h4><p>​    手动调用<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code></p>
<p>​    场景：希望能控制”回调的调用时机时“（控制<code>-didiChangeValueForKey</code>调用）</p>
<h4 id="4-KVC中setValue-forKeyPath-复制过程？"><a href="#4-KVC中setValue-forKeyPath-复制过程？" class="headerlink" title="4.KVC中setValue: forKeyPath: 复制过程？"></a>4.KVC中<code>setValue: forKeyPath:</code> 复制过程？</h4><ol>
<li>调用 setter 方法。</li>
<li>如果没有对应的 setter 方法，判断是否有与 key 值同名的成员属性，如果有，直接赋值。</li>
<li>如果没有与 key 值同名的成员属性，判断是否有与 key 值同名带下划线的成员属性，如果有，直接赋值。</li>
<li>报错：找不到对应的成员属性。</li>
</ol>
<h4 id="5-对MVC的理解？"><a href="#5-对MVC的理解？" class="headerlink" title="5.对MVC的理解？"></a>5.对MVC的理解？</h4><h4 id="6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"><a href="#6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）" class="headerlink" title="6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"></a>6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）</h4><ul>
<li><p>delegate：一对一</p>
<ul>
<li>优点：<ol>
<li>语法严谨，所有收听到的事件都必须有清楚的定义。</li>
<li>delegate协议中的方法如果没有实现编译器会报错。</li>
<li>每个controller可以遵守多个协议，每个协议有不同的delegate。</li>
<li>能够接收调用协议的协议方法的返回值。delegate可以返回信息给controller。</li>
<li>没有第三方对象要求保持/监视通信过程。</li>
</ol>
</li>
<li>缺点：<ol>
<li>需要定义的代码多：协议的定义，controller的delegate属性，在delegate本身中实现delegate方法的定义。</li>
<li>释放代理对象的时候，需要将delegate改为nil，否则调用对象的方法会crash。</li>
</ol>
</li>
</ul>
</li>
<li><p>block：</p>
<ul>
<li><p>优点</p>
<p>代码量比delegate少，更轻型，使用方便。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>需要注意循环引用的问题。</li>
<li>有多个方法时，假如每个方法设置一个block会更麻烦。</li>
</ol>
</li>
</ul>
</li>
<li><p>Notifaction：一对多</p>
<ul>
<li>优点：<ol>
<li>需要写的代码少。</li>
<li>一对多实现简单。</li>
<li>controller能传递context对象（NSDictionary），context对象携带了发送通知的自定义信息。</li>
</ol>
</li>
<li>缺点：<ol>
<li>编译期不会检查通知是否能被被观察者正确的处理。</li>
<li>释放注册的对象时，需要在通知中心取消注册。</li>
<li>需要第三方管理controller和观察者的关系。</li>
<li>通知发出后，发出通知的对象不能从观察者获得任何反馈。</li>
</ol>
</li>
</ul>
</li>
<li><p>KVO：可以一对多</p>
<ul>
<li>优点：<ol>
<li>能够提供观察的属性的新值和旧值。</li>
<li>通过keyPath观察属性，因此也可以嵌套对象。</li>
<li>能够对非我们创建的对象，即内部对象的状态改变做出相应，而且不需要改变内部对象的实现。</li>
<li>不需要额外的代码允许观察值能够被观察。</li>
</ol>
</li>
<li>缺点：<ol>
<li>被观察的属性必须用string定义，编译器不会对其进行检查，可能写错。</li>
<li>对属性的重构导致代码不可用。</li>
<li>所有的观察代码通过一个方法来指向，导致方法中复杂的if语句。</li>
<li>释放观察者时需要移除观察者。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="五、网络请求"><a href="#五、网络请求" class="headerlink" title="五、网络请求"></a>五、网络请求</h3><h4 id="1-NSURLSession和NSURLConnection区别？"><a href="#1-NSURLSession和NSURLConnection区别？" class="headerlink" title="1.NSURLSession和NSURLConnection区别？"></a>1.NSURLSession和NSURLConnection区别？</h4><p>NSURLConnection从iOS 9废弃，NSURLSession在WWDC2013发布。</p>
<ul>
<li><p>普通任务和上传</p>
<p>NSURLSession 针对普通会话、上传、下载有三种不同的任务<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownnloadTask</code>。创建的会话都是挂起状态，需要<code>resume</code>才能启动。</p>
<ul>
<li>当服务器返回的数据较小时，<code>NSURLSession</code>和<code>NSURLConnection</code>执行普通任务的操作没有区别。</li>
<li>执行上传任务时，<code>NSURLSession</code>和<code>NSURLConnection</code>一样需要设置POST请求的<strong>请求体</strong>进行上传。</li>
</ul>
</li>
<li><p>请求方法的不同</p>
<ul>
<li><code>NSURLConnection</code>实例化对象，<ul>
<li>通过<code>-initWithRequest: delegate:</code>创建的请求被自动发送</li>
<li>通过<code>-initWithRequest: delegate: startImmediately:NO</code>创建的请求通过<code>[connect start]</code>发送请求，方法内部把connect对象作为一个source添加到当前线程的runloop的默认模式下执行。(如果runloop不存在会自动创建当前线程对应的runloop)</li>
</ul>
</li>
<li><code>NSURLSession</code>可以<code>cancel</code>(取消)、<code>suspend</code>(暂停)、<code>resume</code>(恢复)会话，暂停以后可以恢复继续请求。</li>
</ul>
</li>
<li><p>下载任务的方式不同</p>
<ul>
<li><code>NSURLConnection</code>下载文件时，<strong>先将文件下载到内存，再写入沙盒</strong>，如果文件比较大，会<strong>出现内存暴涨</strong>的情况。</li>
<li><code>NSURLSessionDownloadTask</code><ol>
<li>下载文件，<strong>默认下载到沙盒中的tem文件中</strong>，不会出现内存暴涨的情况。但是下载完成后会把tem中的临时文件删除，需要在<code>completionHandler</code>回调方法中将下载的文件移动到别的文件夹。</li>
<li>在代理方法中，能够方便地监听文件的下载进度。</li>
</ol>
</li>
</ul>
</li>
<li><p>断点续传方式不同（<code>NSURLSession</code>更加方便）</p>
<ul>
<li><code>NSURLConnection</code>实现断点续传需要通过设置请求头的<code>HTTPHeaderField</code>的range属性进行。</li>
<li><code>NSURLSessionDownloadTask</code>进行断点续传<ol>
<li>当Task暂停时，如果<code>downloadTask</code>非空，调用<code>-cancelByProducingResumeData:(void(^)(NSData *resumeData))completionHandler</code>接收<code>resumeData</code>参数，保存已下载文件。(注意block中的循环引用，定义self的属性_resumeData, <code>weakSelf.resumeData = resumeData</code>)</li>
<li>再次下载是，如果<code>self.resumeData != nil</code>那么调用<code>[[self.session downloadTaskWithResumeData:self.resumeData] rusume]</code>继续下载，否则创建会话和下载任务。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>NSURLSession</code>可以设置配置信息Configuration。</p>
<ul>
<li><code>+(NSURLSession *)sessionWithConfiguration: delegate: delegateQueue:</code></li>
<li>可以设置缓存策略，是否在后台进行请求，最大主机连接数，网络超时等。</li>
</ul>
</li>
</ul>
<h4 id="2-AFN框架为什么封装NSURLSession？"><a href="#2-AFN框架为什么封装NSURLSession？" class="headerlink" title="2.AFN框架为什么封装NSURLSession？"></a>2.AFN框架为什么封装NSURLSession？</h4><h3 id="六、底层相关"><a href="#六、底层相关" class="headerlink" title="六、底层相关"></a>六、底层相关</h3><h4 id="1-iOS程序的加载过程是什么？"><a href="#1-iOS程序的加载过程是什么？" class="headerlink" title="1.iOS程序的加载过程是什么？"></a>1.iOS程序的加载过程是什么？</h4><ol>
<li>执行 <code>main</code> 函数。</li>
<li>执行 <code>UIApplicationMain</code> 函数。</li>
<li>创建 <code>UIApplication</code> 对象（是单例的）。</li>
<li>创建 <code>UIApplication</code> 的代理，并且设置 application 的代理。</li>
<li>开启 主<code>RunLoop</code>。</li>
<li>加载完毕后调用 <code>- application: didFinishLaunchingWithOptions:</code>。</li>
</ol>
<h4 id="2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？"><a href="#2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？" class="headerlink" title="2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？"></a>2.<code>&lt;UIApplicationDelegate&gt;</code> 中有哪些方法？有什么作用？</h4><ul>
<li><code>- application: didFinishLaunchingWithOptions:</code> 应用被加载完毕后被调用</li>
<li><code>- applicationWillResignActive:</code> 当应用即将变为不活动状态时调用，比如电话进入、退出应用程序或开始进入后台状态。</li>
<li><code>- applicationDidEnterBackground:</code> 当应用进入后台状态后调用。在后台状态中应用工作，但是不派发新的事件到响应器。</li>
<li><code>- applicationWillEnterForeground</code> 应用将要回到前台时调用。</li>
<li><code>- applicationDidBecomeActive:</code> 应用已经变为活动状态时调用。</li>
<li><code>- applicationWillTerminate:</code> 应用即将结束时调用。</li>
<li><code>- applicationDidReceiveMemoryWarning:</code> 收到内存警告时调用。</li>
</ul>
<h4 id="3-load-方法和-initialize-方法异同"><a href="#3-load-方法和-initialize-方法异同" class="headerlink" title="3.+load 方法和 +initialize 方法异同"></a>3.<code>+load</code> 方法和 <code>+initialize</code> 方法异同</h4><ul>
<li>相同：<ul>
<li>都在实例化对象==之前==调用。</li>
<li>内部都使用了锁，应该避免线程阻塞在方法中。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>+load</code> 方法</p>
<ul>
<li><p><code>+load</code> 方法在这个==文件被程序加载时==调用，程序启动时会调用<strong>所有</strong>类的<code>+load</code> 方法。与类的使用与否<strong>无关</strong>。</p>
</li>
<li><p><code>+load</code> 方法在<code>main</code>函数之==前==调用。</p>
</li>
<li><p>先调用父类的 <code>+load</code> 方法，再调用子类的 <code>+load</code> 方法。自动完成。</p>
<p>如果一个子类没有实现 <code>+load</code> 方法，那么也就<strong>不会</strong>调用父类的<code>+load</code> 方法。</p>
</li>
<li><p>使用场景：在<code>+load</code>方法中实现 Method swizzle。</p>
</li>
</ul>
</li>
<li><p><code>+initialize</code> 方法</p>
<ul>
<li><p>当第一次给一个类发送消息时，它的<code>+initiallze</code>方法会被调用。<strong><em>只会调用一次</em></strong>。</p>
<p>如果一个类一直没有被使用，它的<code>+initialize</code>方法不会被调用。</p>
</li>
<li><p>在<code>main</code>函数之==后==被调用。</p>
</li>
<li><p>先调用父类的<code>+initialize</code>方法，再调用子类的<code>+initialize</code>方法。</p>
<p>如果子类没有实现<code>+initialize</code>方法没有被实现，父类的<code>+initialize</code>方法也会被调用。</p>
</li>
<li><p>使用场景：初始化全局变量或静态变量。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？"><a href="#4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？" class="headerlink" title="4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？"></a>4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？</h4><blockquote>
<ul>
<li><code>_objc_msgForward</code>是 IMP 类型(一个函数指针)，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</li>
</ul>
</blockquote>
<p>IMP: 指向方法实现开头的指针。</p>
<ul>
<li>我们可以这样创建一个<code>_objc_msgForward</code>对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>objc_msgSend</code>在“消息传递”中的作用：</p>
<p>在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>
</li>
<li><p>消息转发过程：</p>
<ol>
<li>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</li>
<li>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</li>
<li>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</li>
<li>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</li>
<li>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</li>
</ol>
<ul>
<li>最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</li>
</ul>
</li>
</ul>
<ul>
<li><code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：<ol>
<li><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</li>
<li><code>forwardingTargetForSelector:</code>方法</li>
<li><code>methodSignatureForSelector:</code>方法</li>
<li><code>forwardInvocation:</code>方法</li>
<li><code>doesNotRecognizeSelector:</code> 方法</li>
</ol>
</li>
</ul>
<ul>
<li><p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>
<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>
<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>
<blockquote>
<p>“我没有在这个对象里找到这个方法的实现”</p>
</blockquote>
<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。</p>
</li>
</ul>
<h4 id="5-block为什么能够-block-在内部修改-blcok-外部变量？"><a href="#5-block为什么能够-block-在内部修改-blcok-外部变量？" class="headerlink" title="5.__block为什么能够 block 在内部修改 blcok 外部变量？"></a>5.<code>__block</code>为什么能够 block 在内部修改 blcok 外部变量？</h4><blockquote>
<p>我们都知道：<strong>Block不允许修改外部变量的值</strong>，这里所说的==<strong>外部变量的值，指的是栈中指针的内存地址</strong>。==<code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就<strong>将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</strong></p>
</blockquote>
<p>block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址</p>
<p> 变量在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="1-访问域名和访问IP地址的区别？"><a href="#1-访问域名和访问IP地址的区别？" class="headerlink" title="1.访问域名和访问IP地址的区别？"></a>1.访问域名和访问IP地址的区别？</h4><ul>
<li>IP地址是服务器的物理地址，一台服务器可能对应多个网站，访问IP地址可能不知道要访问哪个。</li>
<li>一个域名可能对应多个IP地址，通过域名访问自动选择速度最快的建立连接。</li>
</ul>
<h4 id="2-访问www-xxx-com的过程？"><a href="#2-访问www-xxx-com的过程？" class="headerlink" title="2.访问www.xxx.com的过程？"></a>2.访问<a href="http://www.xxx.com的过程？">www.xxx.com的过程？</a></h4><ol>
<li><p>首先找本机的HOSTS文件，映射为IP地址或客户端向 DNS 服务器请求解析该 URL 中域名对应的 IP 地址。<strong>(域名解析)</strong></p>
</li>
<li><p>根据 IP 地址和端口，客户端同服务器建立连接。<strong>(建立连接)</strong></p>
</li>
<li><p>客户端向服务器发送请求。<strong>(发送请求)</strong></p>
<p>该请求报文作为 TCP 三次握手第三个报文的数据发送给服务器。</p>
</li>
<li><p>服务器对请求做出响应，并把对应的数据发送给客户端。<strong>(作出相应)</strong></p>
</li>
<li><p>释放 TCP 连接。<strong>(释放连接)</strong></p>
</li>
<li><p>客户端对响应数据进行解析、处理。<strong>(解析数据)</strong></p>
</li>
</ol>
<h4 id="3-GET和POST请求的区别？POST一定安全么？"><a href="#3-GET和POST请求的区别？POST一定安全么？" class="headerlink" title="3.GET和POST请求的区别？POST一定安全么？"></a>3.GET和POST请求的区别？POST一定安全么？</h4><ul>
<li>请求形式<ul>
<li>GET 请求：请求的数据附在 URL 之后（数据在请求头中）。以？分割URL和传输数据，多个参数用&amp;相连。</li>
<li>POST 请求：请求的数据封装在请求体中。</li>
</ul>
</li>
<li>安全性<ul>
<li>GET 请求：请求的数据在地址栏中显示。</li>
<li>POST 请求：请求的数据虽然在请求体中，但也不安全，需要加密。</li>
</ul>
</li>
<li>传输数据的大小<ul>
<li>GET 请求：传输数据受URL长度限制，特定浏览器和服务器对URL的长度有限制。</li>
<li>POST 请求：理论上不受限制，实际服务器会对 POST 请求提交的数据大小进行限制。</li>
</ul>
</li>
<li>获取变量值的方式<ul>
<li>GET 请求：Request QueryString</li>
<li>POST 请求：Request Form</li>
</ul>
</li>
</ul>
<h4 id="4-HTTPS安全协议请求过程-HTTPS握手-是什么？"><a href="#4-HTTPS安全协议请求过程-HTTPS握手-是什么？" class="headerlink" title="4.HTTPS安全协议请求过程(HTTPS握手)是什么？"></a>4.HTTPS安全协议请求过程(HTTPS握手)是什么？</h4><p><img src="http://upload-images.jianshu.io/upload_images/449687-4e2ec739a1487779?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信过程"></p>
<ul>
<li><p><strong>涉及密钥：</strong></p>
<p>对称加密密钥A 。</p>
<p>用于加密密钥A的非对称密钥B。公钥发送给客户端，私钥服务器持有。</p>
<p>用于加密密钥B公钥的CA证书密钥C。公钥保存在浏览器或系统中，私钥服务器持有。</p>
</li>
<li><p>请求过程(HTTPS握手)：</p>
<ol>
<li><p>客户端发送HTTPS请求，请求对称加密公钥B。</p>
</li>
<li><p>服务器响应客户端请求，发送CA数字证书。</p>
<p>证书中包括：密钥B的公钥，域名，服务器信息，数字签名，数字摘要算法等信息。</p>
</li>
<li><p>客户端验证CA数字证书的正确性。</p>
<ul>
<li>验证域名的正确性，比较CA证书中的域名和请求域名，可以验证证书是否是服务器发送的。</li>
<li>验证CA证书中数字签名，可以验证CA证书是否被第三方篡改。</li>
</ul>
</li>
<li><p>客户端用CA证书的公钥对密文解密，得到密钥B的公钥。</p>
</li>
<li><p>客户端生成密钥A，用密钥B的公钥进行加密，发送给服务器。</p>
</li>
<li><p>服务器用密钥B的私钥对密文进行解密，得到密钥A。</p>
</li>
<li><p>安全连接建立完成，双方用密钥A对信息进行对称加密传输。</p>
</li>
</ol>
</li>
<li><p>HTTPS加密在传输层</p>
<p>HTTPS报文在包装成TCP报文的时候完成加密过程，报文的header和body都会被加密。</p>
</li>
</ul>
<h4 id="5-HTTPS作用？"><a href="#5-HTTPS作用？" class="headerlink" title="5.HTTPS作用？"></a>5.HTTPS作用？</h4><ul>
<li>内容加密：建立一个信息安全通道，来保证数据传输的安全。</li>
<li>身份认证：认证用户或服务器，确保数据发送到正确的客户或服务器。</li>
<li>数据完整性：防止内容被第三方冒充或篡改。（原因：数字摘要）</li>
</ul>
<h4 id="6-HTTP和HTTPS区别？"><a href="#6-HTTP和HTTPS区别？" class="headerlink" title="6.HTTP和HTTPS区别？"></a>6.HTTP和HTTPS区别？</h4><ul>
<li><p>HTTPS需要到CA申请证书或自制证书。</p>
</li>
<li><p>HTTP直接进行明文传输。</p>
<p>HTTPS先经过具有安全性的SSL/TSL（表示层）加密，再传输密文。</p>
</li>
<li><p>HTTP端口：80。</p>
<p>HTTPS端口：443。</p>
</li>
</ul>
<h4 id="7-数字证书作用？"><a href="#7-数字证书作用？" class="headerlink" title="7.数字证书作用？"></a>7.数字证书作用？</h4><ul>
<li><p>确定得到公钥的正确性</p>
</li>
<li><p>确定目标主机的正确性</p>
<p>​</p>
</li>
<li><p>数字证书包括：</p>
<ul>
<li>用户个人信息、公钥信息、颁发机构名称、证书本身的数字签名、证书数字签名用的HASH算法。</li>
</ul>
</li>
</ul>
<h4 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h4><ul>
<li>数字签名 = 非对称加密 + 数字摘要</li>
<li>数字签名验证数据完整性过程：<ul>
<li>将摘要信息用发送者私钥加密后，与原文一起传送给接受者。<strong>(摘要+原文)</strong></li>
<li>接受者用发送者的公钥将被加密的摘要解密。<strong>(解密)</strong></li>
<li>接受者用与发送者相同的HASH算法对接收到的明文产生一个摘要信息。<strong>(产生摘要)</strong></li>
<li>将产生的摘要与解密得到的摘要进行对比，如果相同，则数据没有被修改。<strong>(比较摘要)</strong></li>
</ul>
</li>
</ul>
<h4 id="9-请求报文包括哪些？请求体和请求报文的关系？"><a href="#9-请求报文包括哪些？请求体和请求报文的关系？" class="headerlink" title="9.请求报文包括哪些？请求体和请求报文的关系？"></a>9.请求报文包括哪些？请求体和请求报文的关系？</h4><p>请求报文包括：请求行、请求头、空行、请求体。</p>
<p>请求报文包括请求体。</p>
<p>响应报文包括：状态行、响应头、空行，响应体。</p>
<h4 id="10-UDP和TCP的区别？"><a href="#10-UDP和TCP的区别？" class="headerlink" title="10.UDP和TCP的区别？"></a>10.UDP和TCP的区别？</h4><ul>
<li><p>TCP：面向连接，三次握手最低限度保证连接可靠性</p>
<p>UDP：无连接，传送数据前无需建立连接，数据到达后也无需确认。（发送端不知道数据是否到达接收端，也不知道数据是否被正确接受）</p>
</li>
<li><p>TCP：可靠交付。</p>
<p>UDP：不可靠交付。</p>
</li>
<li><p>TCP：报文头部长，传输开销大</p>
<p>UDP：报文头部短，传输开销小，时延较短，实用性更好。</p>
</li>
</ul>
<h4 id="11-TCP三次握手和四次挥手过程"><a href="#11-TCP三次握手和四次挥手过程" class="headerlink" title="11.TCP三次握手和四次挥手过程"></a>11.TCP三次握手和四次挥手过程</h4><ul>
<li><p>三次握手</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1641067-8d52ca990ffbee0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p>
</li>
<li><p>四次挥手</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="四次挥手"></p>
</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h4 id="1-strstr函数是什么？"><a href="#1-strstr函数是什么？" class="headerlink" title="1.strstr函数是什么？"></a>1.strstr函数是什么？</h4><h4 id="2-free-函数做了什么？"><a href="#2-free-函数做了什么？" class="headerlink" title="2.free() 函数做了什么？"></a>2.free() 函数做了什么？</h4><h4 id="3-strcpy和strnpy函数的区别？"><a href="#3-strcpy和strnpy函数的区别？" class="headerlink" title="3.strcpy和strnpy函数的区别？"></a>3.strcpy和strnpy函数的区别？</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2017-03-20/swift3-0-Protocol-And-Eextension/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-03-20/swift3-0-Protocol-And-Eextension/" class="post-title-link" itemprop="url">swift3.0_协议(Protocal)和扩展(Extension)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Post created:2017-03-20 18:13:44 / Post modified:18:28:58" itemprop="dateCreated datePublished" datetime="2017-03-20T18:13:44+08:00">2017-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift3-0/" itemprop="url" rel="index"><span itemprop="name">swift3.0</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="协议-Protocal"><a href="#协议-Protocal" class="headerlink" title="协议(Protocal"></a>协议(Protocal</h2><h4 id="使用protocol-来声明一个协议。"><a href="#使用protocol-来声明一个协议。" class="headerlink" title="使用protocol 来声明一个协议。"></a>使用protocol 来声明一个协议。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ExampleProtocal&#123;</span><br><span class="line">    var simpleDesp:String&#123;get&#125;</span><br><span class="line">    mutating func adjust()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017-03-20/swift3-0-Protocol-And-Eextension/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2017-03-19/swift3-0-Class-And-Object-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-03-19/swift3-0-Class-And-Object-study/" class="post-title-link" itemprop="url">swift3.0_类和对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2017-03-19 19:15:13" itemprop="dateCreated datePublished" datetime="2017-03-19T19:15:13+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift3-0/" itemprop="url" rel="index"><span itemprop="name">swift3.0</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h3 id="和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。"><a href="#和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。" class="headerlink" title="和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。"></a>和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017-03-19/swift3-0-Class-And-Object-study/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2017-03-19/swift3-0-Struct-and-Enum/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-03-19/swift3-0-Struct-and-Enum/" class="post-title-link" itemprop="url">swift3.0_枚举(Enum)和结构体(struct)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2017-03-19 17:15:13" itemprop="dateCreated datePublished" datetime="2017-03-19T17:15:13+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift3-0/" itemprop="url" rel="index"><span itemprop="name">swift3.0</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h1><h3 id="使用enum-来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。"><a href="#使用enum-来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。" class="headerlink" title="使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。"></a>使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。</h3>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017-03-19/swift3-0-Struct-and-Enum/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2017-03-19/swift3-0-func-study/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017-03-19/swift3-0-func-study/" class="post-title-link" itemprop="url">swift3.0_函数和闭包</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2017-03-19 17:15:13" itemprop="dateCreated datePublished" datetime="2017-03-19T17:15:13+08:00">2017-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift3-0/" itemprop="url" rel="index"><span itemprop="name">swift3.0</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h1><h3 id="使用func-来声明一个函数，使用名字和参数来调用函数。使用-gt-来指定函数返回值的类型"><a href="#使用func-来声明一个函数，使用名字和参数来调用函数。使用-gt-来指定函数返回值的类型" class="headerlink" title="使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型"></a>使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func great( person:String,day :String) -&gt;String&#123;</span><br><span class="line">    return &quot;Hello \(person),today is \(day)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017-03-19/swift3-0-func-study/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2016-09-16/IPhone-Bluetooth-speaker-output-audio/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016-09-16/IPhone-Bluetooth-speaker-output-audio/" class="post-title-link" itemprop="url">iOS 解决蓝牙音箱输出App播放的音频问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2016-09-16 11:31:13" itemprop="dateCreated datePublished" datetime="2016-09-16T11:31:13+08:00">2016-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-Project-Practice/" itemprop="url" rel="index"><span itemprop="name">iOS Project Practice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。<br>添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016-09-16/IPhone-Bluetooth-speaker-output-audio/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/" class="post-title-link" itemprop="url">iOS 解决支付宝SDK在没有安装支付宝时不能启动网页支付</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2016-08-28 11:31:13" itemprop="dateCreated datePublished" datetime="2016-08-28T11:31:13+08:00">2016-08-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS-Project-Practice/" itemprop="url" rel="index"><span itemprop="name">iOS Project Practice</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2016-08-13/was_mutated_while_being_enumerated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016-08-13/was_mutated_while_being_enumerated/" class="post-title-link" itemprop="url">iOS 多线程同时访问数组出现was mutated while being enumerated</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2016-08-13 10:41:15" itemprop="dateCreated datePublished" datetime="2016-08-13T10:41:15+08:00">2016-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>错误：iOS 多线程同时访问数组出现was mutated while being enumerated<br>__NSArrayM: 0x96be3e0 was mutated while being enumerated.<br>意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。<br>原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2016-08-13/was_mutated_while_being_enumerated/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2016-07-30/solve-Xcode-development-component-failure-of-the-command/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2016-07-30/solve-Xcode-development-component-failure-of-the-command/" class="post-title-link" itemprop="url">解决Xcode开发组件失效的命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2016-07-30 23:26:17" itemprop="dateCreated datePublished" datetime="2016-07-30T23:26:17+08:00">2016-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Post modified:2017-03-20 18:28:58" itemprop="dateModified" datetime="2017-03-20T18:28:58+08:00">2017-03-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xcode/" itemprop="url" rel="index"><span itemprop="name">xcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add <code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS,Windows开发者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengbomo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengbomo@hotmail.com" title="Email → mailto:zhengbomo@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/intent/user?user_id=371531868" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;intent&#x2F;user?user_id&#x3D;371531868" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://facebook.com/zhengbomo" title="Facebook → http:&#x2F;&#x2F;facebook.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://message/?uin=449179249&Site=&Menu=yes" title="QQ → tencent:&#x2F;&#x2F;message&#x2F;?uin&#x3D;449179249&amp;Site&#x3D;&amp;Menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/1891587992" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;1891587992" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bomo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
