<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fangliquan.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS一、内存管理1.谈谈对内存管理的理解MRC (手动引用计数) 和ARC (自动引用计数)  MRC 核心思想：引用计数式内存管理  四个法则  自己生成的对象自己持有 (使用 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 开头的方法生成对象后持有对象)  非自己生成的对象自己也能持有 (retain) 123id obj &#x3D; [NSArray array]; &#x2F;&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="iOSiOS面试整理(一)">
<meta property="og:url" content="http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/index.html">
<meta property="og:site_name" content="microleo的个人博客">
<meta property="og:description" content="iOS一、内存管理1.谈谈对内存管理的理解MRC (手动引用计数) 和ARC (自动引用计数)  MRC 核心思想：引用计数式内存管理  四个法则  自己生成的对象自己持有 (使用 alloc&#x2F;new&#x2F;copy&#x2F;mutableCopy 开头的方法生成对象后持有对象)  非自己生成的对象自己也能持有 (retain) 123id obj &#x3D; [NSArray array]; &#x2F;&amp;">
<meta property="og:locale">
<meta property="og:image" content="http://img.blog.csdn.net/20130614155652265">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/449687-4e2ec739a1487779?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1641067-8d52ca990ffbee0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2">
<meta property="article:published_time" content="2021-03-14T07:53:58.000Z">
<meta property="article:modified_time" content="2021-03-16T03:21:38.142Z">
<meta property="article:author" content="microleo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.blog.csdn.net/20130614155652265">

<link rel="canonical" href="http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>iOSiOS面试整理(一) | microleo的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="microleo的个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">microleo的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工作学习中的学习笔记及技术积累</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-exclamation-circle fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOSiOS面试整理(一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Post created:2021-03-14 15:53:58" itemprop="dateCreated datePublished" datetime="2021-03-14T15:53:58+08:00">2021-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="Post modified:2021-03-16 11:21:38" itemprop="dateModified" datetime="2021-03-16T11:21:38+08:00">2021-03-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h3><h4 id="1-谈谈对内存管理的理解"><a href="#1-谈谈对内存管理的理解" class="headerlink" title="1.谈谈对内存管理的理解"></a>1.谈谈对内存管理的理解</h4><p>MRC (手动引用计数) 和ARC (自动引用计数)</p>
<ol>
<li><h5 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h5><ul>
<li><p><strong>核心思想：引用计数式内存管理</strong></p>
<ul>
<li><p>四个法则</p>
<ul>
<li><p>自己生成的对象自己持有 (使用 alloc/new/copy/mutableCopy 开头的方法生成对象后持有对象)</p>
</li>
<li><p>非自己生成的对象自己也能持有 (retain)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">&#x2F;&#x2F; 通过autorelease使对象的持有权在AutoreleasePool</span><br><span class="line">[obj retain]; &#x2F;&#x2F; 自己持有对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>不再需要自己持有的对象时释放 (release)</p>
</li>
<li><p>非自己持有的对象不能释放</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象操作对应的方法</p>
<table>
<thead>
<tr>
<th align="center">对象操作</th>
<th align="center">OC中方法</th>
<th align="center">retainCount变化</th>
</tr>
</thead>
<tbody><tr>
<td align="center">生成并持有对象</td>
<td align="center">alloc/new/copy/mutableCopy</td>
<td align="center">+1</td>
</tr>
<tr>
<td align="center">持有对象</td>
<td align="center">retain</td>
<td align="center">+1</td>
</tr>
<tr>
<td align="center">释放对象</td>
<td align="center">release</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">废弃对象</td>
<td align="center">dealloc</td>
<td align="center">无</td>
</tr>
</tbody></table>
<ul>
<li>alloc/new方法通过调用 allocWithZone: 类方法分配存储空间并初始化，同时使得retainCount = 1。</li>
<li>调用 retain 方法后引用计数值+1。</li>
<li>调用release方法后引用计数-1。</li>
<li>当retainCount = 0 时，调用 dealloc 方法废弃对象。</li>
</ul>
</li>
<li><p>苹果将引用计数保存在引用计数表中（是一个散列表）</p>
<p>优点：</p>
<ul>
<li>对象内存块的分配无需考虑内存块头部</li>
<li>引用计数表各记录中有内存块地址，可从各个记录追溯到各对象的内存块。（即使对象占用内存块损坏，能够根据引用计数表找到各内存块的位置）</li>
</ul>
</li>
<li><p>autorelease</p>
<ul>
<li>autorelease使得对象在超出其作用作用域（生命周期）后，在废弃autoreleasepool时，其中所有对象的release方法会被调用一次，可以指定变量的作用域。</li>
<li>步骤：<ol>
<li>生成并持有 NSAutoreleasePool 对象</li>
<li>调用已分配对象的 autorelease 对象方法</li>
<li>废弃NSAutoreleasePool对象。（调用 <code>- drain</code> 对象方法）</li>
</ol>
</li>
<li>release 和 autorelease 区别：<ul>
<li>调用 release 方法，对象会立即被释放</li>
<li>调用 autorelease 方法，对象不会立即被释放，而是被注册的 autoreleasepool 中，当autoreleasepool 对象被废弃时（drain），对其中的对象都做一次 release 操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><ul>
<li><p><strong>本质还是引用计数式内存管理</strong></p>
</li>
<li><p><strong>由编译器进行内存管理</strong>。实际上是 编译器 + 运行时库。在编译时，系统自动在合适的位置添加 retain/ release/ dealloc/ autorelease 方法。</p>
</li>
<li><p><strong>所有权修饰符</strong></p>
<p>ARC中通过变量所有权修饰符，不需要使用 retain/release 就能完美满足引用计数式的思考方式：</p>
<p><strong>从手写 release 语句变为通过控制对象的作用域控制对象的释放。</strong></p>
<p>“自己生成的对象自己持有” 和 “非自己生成的对象自己也能持有” 通过对带 <code>__strong</code> 修饰符的变量赋值即可达到，“不再需要自己持有的对象时释放”通过废弃带 <code>__strong</code> 修饰符的变量（变量作用域结束或成员变量所属对象被废弃）或变量赋值（nil）（block中打破循环引用）做到。</p>
<p><code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code> 修饰的自动变量会自动初始化为nil</p>
<p>对象没有被变量强引用着时，该对象被释放。</p>
<ul>
<li><p><code>__strong</code> : id 类型和对象类型默认的所有权修饰符。表示对对象的强引用。</p>
<p>在被 <code>__strong</code> 修饰的变量超出其作用域时，即在该变量被废弃时，会释放其被赋予的对象（随强引用的失效，引用的对象随之释放）。当要废弃被强引用的对象时，要保证所有指向该对象的强引用变量都置为nil。</p>
</li>
<li><p><code>__weak</code> 提供弱引用，弱引用不能持有对象。当持有对象的弱引用时，若该对象被废弃，则此弱引用自动失效，且被置为nil。</p>
<p>使用 <code>__weak</code> 修饰符的变量，就是使用注册到 autoreleasepool中的对象。</p>
</li>
<li><p><code>__unsafe_unretained</code> 声明这个引用不会保持对象的存活，如果对象被废弃，不会被置nil，该变量会变成野指针。使用被其修饰的变量时，先判断是否存在。被其修饰的变量不属于编译器的内存管理对象。</p>
</li>
<li><p><code>__autorelease</code> 在ARC中替代 <code>- autorelease</code> 方法。如果方法名<strong>不以</strong> alloc/new/copy/mutableCopy 开头，编译器自动将返回值的对象注册到 autoreleasepool 中（ init 开头的方法返回的对象不会被注册到 autoreleasepool 中，只是对 alloc 方法返回值的对象）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>内存泄漏：应当被废弃的对象在超出其生存周期后依然继续存在。</p>
</li>
</ol>
<h4 id="2-ARC如何实现？"><a href="#2-ARC如何实现？" class="headerlink" title="2.ARC如何实现？"></a>2.ARC如何实现？</h4><p>通过变量所有权修饰符，满足引用计数式内存管理。</p>
<p>编译器+运行时。</p>
<p>==通过运行时发送消息，通过编译器自动插入release==。</p>
<ul>
<li><p><code>__strong</code> 修饰符</p>
<ul>
<li><p>使用 alloc/new/copy/mutableCopy 产生对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	id __strong obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; obj_msgSend(NSObject, @selector(alloc));</span><br><span class="line">obj_msgSend(obj, @selector(init));</span><br><span class="line">obj_release(obj); &#x2F;&#x2F; 编译器插入</span><br></pre></td></tr></table></figure>

<p>两次调用 <code>obj_msgSend()</code> 方法，在作用域结束调用 <code>obj_release</code> 释放对象。编译器自动插入了release。</p>
</li>
<li><p>非 alloc/new/copy/mutableCopy 产生对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong obj &#x3D; [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; objc_magSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleaseReturnValue(obj); &#x2F;&#x2F; 编译器插入</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure>

<p><code>objc_retainAutoreleaseReturnValue()</code> 函数用于持有对象，但持有的对象应为函数的返回值或者注册在 autoreleasepool 中的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    id obj &#x3D; objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">  	objc_msgSend(obj, @selector(init));</span><br><span class="line">  	return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>obj_autoreleaseReturnValue()</code> 时，如果方法或函数的调用方在调用了方法或函数后紧接着调用了 <code>objc_retainAutoreleaseReturnValue()</code> 函数，那么就不将返回的对象注册到 autoreleasepool 中-而是直接传递给方法或函数的调用方。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-对MRC的理解"><a href="#3-对MRC的理解" class="headerlink" title="3.对MRC的理解"></a>3.对MRC的理解</h4><h4 id="4-GC（垃圾回收）和ARC的区别？"><a href="#4-GC（垃圾回收）和ARC的区别？" class="headerlink" title="4.GC（垃圾回收）和ARC的区别？"></a>4.GC（垃圾回收）和ARC的区别？</h4><ul>
<li><p>ARC 相比 GC 优点：</p>
<ul>
<li><p>ARC 工作在编译期，在运行时没有额外的开销。</p>
</li>
<li><p>ARC 的内存回收是平稳进行的，当对象不被持有时会立即被回收。</p>
<p>GC 的内存回收时需要暂停程序，会有一定的卡顿。</p>
</li>
</ul>
</li>
<li><p>ARC 相比 GC 缺点：</p>
<ul>
<li>==ARC 需要手动处理循环引用等内存管理问题，GC 不需要。==</li>
</ul>
</li>
</ul>
<h4 id="5-内存关键字（assign-weak-strong-copy-retain-介绍"><a href="#5-内存关键字（assign-weak-strong-copy-retain-介绍" class="headerlink" title="5.内存关键字（assign, weak, strong, copy, retain)介绍"></a>5.内存关键字（assign, weak, strong, copy, retain)介绍</h4><ul>
<li><p>assign：用于非对象类型。其 setter 方法只是执行简单的赋值操作。</p>
</li>
<li><p>weak：用于对象类型，表示弱引用。其 setter 方法中既不保留新值，也不释放旧值，同assign类似。</p>
<p>但是在属性所指对象遭到废弃时，属性值会被置nil。</p>
</li>
<li><p>strong：用于<strong>除</strong> NSString/block 之外的对象类型，表示一种“拥有关系”，表示对对象的持有和强引用。其 setter 方法中，先 relsease 旧值，再 retain 新值。</p>
</li>
<li><p>copy：所表达的所述关系与 strong 类似。在其 setter 方法中，不保留新值，而是将其 copy。当属性类型为 NSString 类型时，通过 copy 关键字保护器封装性，防止指向 MutableString 类型。</p>
</li>
<li><p>retain：MRC中使用，作用同 strong 相同。</p>
</li>
</ul>
<h4 id="6-weak和strong关键字内部做了什么？"><a href="#6-weak和strong关键字内部做了什么？" class="headerlink" title="6.weak和strong关键字内部做了什么？"></a>6.weak和strong关键字内部做了什么？</h4><h4 id="7-除了NSString什么情况下用copy？block为什么要复制到堆中？"><a href="#7-除了NSString什么情况下用copy？block为什么要复制到堆中？" class="headerlink" title="7.除了NSString什么情况下用copy？block为什么要复制到堆中？"></a>7.除了NSString什么情况下用copy？block为什么要复制到堆中？</h4><ol>
<li><p>带有可变类型的对象，比如 NSArray、NSDictionary等。</p>
<ul>
<li>因为父类指针能够指向子类对象，使用 copy 的目的是让本对象的属性不受外界影响，使用 copy 后无论传入的是可变还是不可变的对象，==本身持有的就是一个不可变对象==。</li>
<li>当用 strong 时，该属性可能指向一个可变对象，如果这个对象在外部被修改了，那么就会修改该属性。</li>
</ul>
</li>
<li><p>用作 block 的关键字。</p>
<p>在 ARC中，对 block 使用 strong 和 copy 效果一样，ARC 中会自动将栈上的 block 拷贝到堆中。这里使用 copy 关键字是为了提醒我们这里的 block 被复制到了堆中。</p>
<p><strong>扩展：block 为什么要复制到堆中？</strong></p>
<p>将栈中的 block 复制到堆上，这样即使 block 语法记述的变量作用域结束，堆上的 block 还可以继续存在。</p>
<p>当 block 从栈复制到堆时，block 中使用的 <code>__block</code> 变量也全部从栈复制到堆中，此时 blcok <strong>持有</strong> <code>__block</code> 变量。如果堆上的 block 被废弃，那么它使用的 <code>__block</code> 变量也就被释放。</p>
</li>
</ol>
<h4 id="8-调用静态方法（类方法）时需要release么？"><a href="#8-调用静态方法（类方法）时需要release么？" class="headerlink" title="8.调用静态方法（类方法）时需要release么？"></a>8.调用静态方法（类方法）时需要release么？</h4><p>静态方法（类方法）创建的对象自动加入了自动释放池中，所以不需要release。</p>
<h4 id="9-autorelease，AutoreleasePool的原理是什么？"><a href="#9-autorelease，AutoreleasePool的原理是什么？" class="headerlink" title="9. autorelease，AutoreleasePool的原理是什么？"></a>9. autorelease，AutoreleasePool的原理是什么？</h4><p>autoreleasepool 以==队列数组的形式==实现，主要通过3个函数完成：</p>
<p>1.<code>objc_autoreleasePoolPush</code> </p>
<p>创建 autoreleasepool，相当于NSAutoreleasePool  *pool = [[NSAutoreleasePool alloc] init]。</p>
<p>2.<code>objc_autoreleasePoolPop</code> </p>
<p>倾倒 autoreleasepool，相当于 [pool drain]。</p>
<p>3.<code>objc_autorelease</code></p>
<p>将对象加入 pool 中。</p>
<p><strong>扩展</strong>：如果 autorelease NSAutoreleasePool对象会如何？</p>
<p>答：<strong>发生异常</strong>。无论调用哪一个对象的 autorelease 实例方法，实际上是调用 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已经被重载，因此运行时会出错。</p>
<h4 id="10-autoreleasepool的drain时机"><a href="#10-autoreleasepool的drain时机" class="headerlink" title="10.autoreleasepool的drain时机"></a>10.autoreleasepool的drain时机</h4><ul>
<li><p>手动创建的 autoreleasepool（指定的autoreleasepool）：当作用域大括号结束时释放。</p>
</li>
<li><p>系统创建的 autoreleasepool（不指定autoreleasepool）：autorelease 对象出作用域后，被添加到==最近一次创建的== autoreleasepool 中，==在当前 runloop 结束时释放==。</p>
<ul>
<li><p>当 runloop 检测到事件并启动后，会自动创建一个 autoreleasepool 。</p>
</li>
<li><p>所有延迟释放的对象都被添加到这个 autoreleasepool 中。</p>
<p>所有 autorelease 的对象，在<strong>出了作用域之后</strong>，会被自动添加到<strong>最近创建的自动释放池中</strong>。</p>
</li>
<li><p>当 runloop 即将结束时，倾倒 autoreleasepool ，向其中所有的对象发送 release 消息后，autoreleasepool 被销毁。</p>
</li>
</ul>
</li>
</ul>
<h4 id="11-autoreleasepool的作用"><a href="#11-autoreleasepool的作用" class="headerlink" title="11.autoreleasepool的作用"></a>11.autoreleasepool的作用</h4><p>ARC中，不允许使用 autorelease 方法，每个 runloop 循环中系统都自动加入了autoreleasepool 的创建和释放</p>
<p>但是，==在需要创建和销毁大量对象时（大数的 for 循环中创建和销毁对象），使用手动创建的 autoreleasepool 可以避免内存峰值的出现==。如果不手动创建，被加入系统创建的 autoreleasepool 中的对象在 runloop 结束时才会被统一执行 release 操作，如果在 for 循环内部创建 autoreleasepool，那么每循环一次都会执行 release 操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        NSString* string &#x3D; @&quot;ab c&quot;;</span><br><span class="line">        NSArray* array &#x3D; [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-iOS中堆栈的理解？"><a href="#12-iOS中堆栈的理解？" class="headerlink" title="12.iOS中堆栈的理解？"></a>12.iOS中堆栈的理解？</h4><ul>
<li>堆栈的区别<ul>
<li>堆空间的内存是动态分配的，一般存放对象，需要手动释放。</li>
<li>栈空间的内存是系统自动分配的，一般存放局部变量等，系统自动回收。</li>
</ul>
</li>
</ul>
<h4 id="13-weak在对象销毁时使指向对象的指针置nil的原理？"><a href="#13-weak在对象销毁时使指向对象的指针置nil的原理？" class="headerlink" title="13.weak在对象销毁时使指向对象的指针置nil的原理？"></a>13.weak在对象销毁时使指向对象的指针置nil的原理？</h4><ul>
<li>使用<strong>哈希表（散列表实现</strong>）<ul>
<li>key：对象的内存地址。</li>
<li>value：被__weak修饰的变量的地址。</li>
</ul>
</li>
<li>当对象被废弃时发生：<ul>
<li>从weak表中获取被废弃对象的地址为key的记录。（<strong>获取记录</strong>）</li>
<li>将包含在记录中所有被<code>__weak</code>修饰的变量的地址，赋值为nil。(<strong>赋值为nil</strong>)</li>
<li>从weak表中删除记录。(<strong>删除记录</strong>)</li>
<li>从引用技术表中删除被废弃对象的地址为键值的记录。</li>
</ul>
</li>
</ul>
<h4 id="14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？"><a href="#14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？" class="headerlink" title="14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？"></a>14.block作为viewControler属性时，如果block块中使用了<code>self.view</code>会发生循环引用么？</h4><p>会发生。</p>
<p>在block代码块之前使用<code>__weak typeof(self) weakSelf = self;</code>，打破闭环。</p>
<h3 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h3><h4 id="1-对多线程的理解？"><a href="#1-对多线程的理解？" class="headerlink" title="1.对多线程的理解？"></a>1.对多线程的理解？</h4><p>进程：CPU分配资源和调度的最小单位</p>
<p>线程：CPU执行任务的最小单位</p>
<h4 id="2-iOS中实现多线程的方式有哪些？"><a href="#2-iOS中实现多线程的方式有哪些？" class="headerlink" title="2.iOS中实现多线程的方式有哪些？"></a>2.iOS中实现多线程的方式有哪些？</h4><h4 id="3-GCD和NSOperation优缺点？"><a href="#3-GCD和NSOperation优缺点？" class="headerlink" title="3.GCD和NSOperation优缺点？"></a>3.GCD和NSOperation优缺点？</h4><ul>
<li>GCD是纯C语言的 API，NSOperation 是基于 GCD 的面向对象的封装。</li>
<li>NSOperation 可以轻松在 operation 间设置依赖，设置它们的优先级，任务能够被方便地暂停、恢复，可以自定义子类。可以将 KVO 应用在 NSOperation 中，监听一个 operation 是否完成、取消、正在执行。可以设置最大并发数。</li>
<li>GCD 以 block 为单位，代码简洁，更为轻量化。对于一次性运算，或是仅仅为了加快现有方法的运算速度，选择轻量化的 GCD 更为方便。</li>
</ul>
<h4 id="4-死锁发生的原因是什么？如何避免？"><a href="#4-死锁发生的原因是什么？如何避免？" class="headerlink" title="4.死锁发生的原因是什么？如何避免？"></a>4.死锁发生的原因是什么？如何避免？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autorelease &#123;</span><br><span class="line">	dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;发生死锁&quot;)；</span><br><span class="line">    &#125;)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步函数，会把 block 加入指定队列中，<strong>会一直等待 block 执行完成才返回。</strong>因此在 block 执行完之前，调用同步函数的线程是<strong>阻塞的</strong>。</p>
<p>异步函数，会把 block 加入指定队列中，<strong>不会等待 block 执行，会立即返回。</strong>只负责向队列中添加任务。</p>
<p>串行队列：按照任务的添加顺序执行任务。并且保证在执行某个任务时，它前面进入队列的任务都执行完了。</p>
<p>并发队列：按照任务的添加顺序 <strong><em>开始</em></strong> 执行任务。任务执行的结束时间不确定，取决于每个任务的耗时。</p>
<p><strong>原因：主线程是串行的，在执行同步函数时被阻塞，同步函数要求 block 块执行完毕后才返回，这样主线程才能继续向下执行；由于在主线程中，执行 block 块要求同步函数执行完毕才进行，这样就造成了双方的</strong><em>互相等待</em><strong>，导致了死锁的发生。</strong></p>
<blockquote>
<p><strong><em>导致死锁的原因一定是：在某个串行队列中，同步地向这个队列添加任务。(在串行队列中，同步函数向相同串行队列中添加任务)</em></strong></p>
</blockquote>
<p><strong>注意：</strong>发生死锁要具体分析同步函数所在的队列是并发队列还是串行队列，并且 block 要添加到哪种队列。</p>
<ul>
<li>如果使用异步函数添加任务，无论任务是否添加到串行队列都不会发生死锁，因为异步函数不会阻塞线程。</li>
<li>只在解决数据竞争问题时使用串行队列。</li>
</ul>
<p>使用同步函数 + 串行队列的组合<strong>不一定</strong>会发生死锁。同步函数所在的串行队列和要添加任务的队列不同时，不会发生死锁。</p>
<h4 id="5-iOS中有哪些锁？"><a href="#5-iOS中有哪些锁？" class="headerlink" title="5.iOS中有哪些锁？"></a>5.iOS中有哪些锁？</h4><p>锁：一段代码在一段时间内只能被一个线程访问。</p>
<p>NSLock </p>
<p>NSCondition 条件锁</p>
<p>NSConditionLock 条件锁</p>
<p>NSRecursiveLock 递归锁</p>
<h4 id="6-iOS中线程安全有哪些情况？"><a href="#6-iOS中线程安全有哪些情况？" class="headerlink" title="6.iOS中线程安全有哪些情况？"></a>6.iOS中线程安全有哪些情况？</h4><p>死锁，数据竞争，优先级反转</p>
<h4 id="7-多线程操作对同一块资源发生数据竞争时能怎样做？"><a href="#7-多线程操作对同一块资源发生数据竞争时能怎样做？" class="headerlink" title="7.多线程操作对同一块资源发生数据竞争时能怎样做？"></a>7.多线程操作对同一块资源发生数据竞争时能怎样做？</h4><ul>
<li><p>互斥锁 <code>@synchronized</code></p>
<ul>
<li>优点：不需要在代码中显式地创建锁对象，就能实现锁的机制。</li>
<li>缺点：消耗大量CPU资源。</li>
</ul>
</li>
<li><p>串行队列：一个串行队列就会开一条子线程，多个串行队列并发执行，可以用<code>dispath_set_target_queue</code>设置执行阶层。将不同的串行队列设置到新的串行队列中串行执行。</p>
</li>
<li><p>栅栏函数：使用并发队列和栅栏函数能实现高效的数据库访问和文件访问。</p>
</li>
<li><p>信号量：当信号量为1时可以当做锁使用。控制同时访问特定资源的线程数量。优势在于等待时不会消耗CPU资源。</p>
<ul>
<li><p><code>dispatch_semaphore_create(long value)</code> 创建信号量，括号中的数字表示能允许同时操作的线程数量。</p>
</li>
<li><p><code>dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)</code></p>
<p>第一个参数：信号量</p>
<p>第二个参数：阻塞时间。表示如果信号量为0时阻塞线程的时间。DISPATCH_TIME_FOREVER 表示永久阻塞。</p>
<p>当信号量 = 0 时，函数返回1，表示需要等待，不允许操作。</p>
<p>当信号量 &gt;= 1是，函数返回0，表示不需要等待，继续执行操作。<strong>并把信号量 - 1</strong></p>
</li>
<li><p><code>dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)</code></p>
<p>执行完操作后调用，将信号量 + 1。</p>
</li>
<li><pre><code class="objective-c">NSMutableArray *array = [[NSMutableArray alloc] init];
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
for (int i = 0; i &lt; 100; i++) &#123;
    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 信号量是0时等待，非0时，经过dispatch_semaphore_wait函数后信号量-1，其他线程等待
        [array addObject:[NSNumber numberWithInteger:i]];
        NSLog(@&quot;%d---%ld---%@&quot;, i, array.count, [NSThread currentThread]);
        dispatch_semaphore_signal(semaphore); // 信号量+1
    &#125;);
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NSLock</span><br><span class="line"></span><br><span class="line">  - 通过 &#96;- (void)lock &#96;和 &#96;- (void)unlock &#96;配对使用实现代码的锁定，只能执行被锁定的代码。需要使用相同的锁对象才能实现互斥。</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;objective-c</span><br><span class="line">    &#x2F;&#x2F; 实例类person</span><br><span class="line">    Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 创建锁</span><br><span class="line">    NSLock *myLock &#x3D; [[NSLock alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 线程A</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];	&#x2F;&#x2F; 锁定</span><br><span class="line">        [person personA];</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 线程B</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];  &#x2F;&#x2F; 锁定</span><br><span class="line">        [person personB];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><code>- (BOOL)tryLock</code>：尝试锁定，如果加锁失败（已经被锁定）返回NO，不会阻塞线程。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p>
<p><code>- (BOOL)lockBeforeDate:(NSDate *)limit</code>：在date时间之前尝试锁定，如果在date时间内都不能完成锁定，返回NO。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p>
</li>
</ul>
</li>
<li><p>NSCondition：最基本的条件锁，手动控制线程 wait（等待）和 signal （继续）</p>
<ul>
<li><p><code>[condition lock]</code> 锁定代码，其他线程的命令需要在lock 外等待，只到unlock ，才可访问。</p>
</li>
<li><p><code>[condition unlock</code> 与lock 同时使用。</p>
</li>
<li><p><code>[condition wait]</code> 让当前线程处于等待状态。</p>
</li>
<li><p><code>[condition signal]</code> CPU发信号告诉线程不用在等待，可以继续执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *condition &#x3D; [[NSCondition alloc] init];</span><br><span class="line"></span><br><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        if ([products count] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            NSLog(@&quot;wait for product&quot;);</span><br><span class="line">            [condition wait];  &#x2F;&#x2F; 线程等待</span><br><span class="line">        &#125;</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [condition signal];  &#x2F;&#x2F; 恢复线程</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
</li>
<li><p>NSConditionLock：条件锁，可以设置加锁/解锁条件，只有满足条件时才能加锁/解锁。</p>
<ul>
<li><p><code>- (void)lockWhenCondition:(NSInteger)condition</code> 满足条件时才能加锁。</p>
</li>
<li><p><code>- (void)unlockWithCondition:(NSInteger)condition</code> 满足条件时才能解锁。</p>
</li>
<li><p><code>- (BOOL)tryLockWhenCondition:(NSInteger)condition</code> 满足条件尝试加锁。</p>
</li>
<li><p><code>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit</code> 满足条件在limit时间内尝试加锁。</p>
</li>
<li><p>同时 NSLock 的相关方法依旧能够使用，可以使用 <code>- lock</code>  和 <code>- unlock</code> 方法加锁或解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line">NSInteger HAS_DATA &#x3D; 1;</span><br><span class="line">NSInteger NO_DATA &#x3D; 0;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [lock lockWhenCondition:NO_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [lock unlockWithCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        NSLog(@&quot;wait for product&quot;);</span><br><span class="line">        [lock lockWhenCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [lock unlockWithCondition:NO_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>NSRecursiveLock：递归锁，这个锁可以被同一线程多次使用，而不会引起死锁。主要用在循环及递归操作中。递归锁会跟踪它被 lock 的次数。每次成功的 lock 都必须平衡调用 unlock 操作。只有这样锁才会被最终释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NSLock *lock &#x3D; [[NSLock alloc] init];</span><br><span class="line">NSRecursiveLock *lock &#x3D; [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line"></span><br><span class="line">    RecursiveMethod &#x3D; ^(int value) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;value &#x3D; %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);	&#x2F;&#x2F; 递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这里如果把锁对象换为 NSLock 类型的话，从第二次递归调用开始会发生死锁。因为每次进入 block 都会加一把锁，从第二次开始因为已经加了锁并且没有解锁， 所以要等待解锁，造成了死锁，造成线程阻塞而 crash。如果换成 NSRecursiveLock 类就不会造成死锁。</p>
</li>
</ul>
<h4 id="8-atomic实现原理"><a href="#8-atomic实现原理" class="headerlink" title="8.atomic实现原理"></a>8.atomic实现原理</h4><p>atomic为原子属性，为setter方法加互斥锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic, assign)int age;</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">	@synchronized(self)&#123;</span><br><span class="line">        _age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>atomic 和 nonatomic 比较</p>
<ul>
<li><p>atomic：线程安全（并非真正安全），需要消耗大量CPU资源。</p>
<p>例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p>
</li>
<li><p>nonatomic: 非线程安全，适合移动设备。</p>
</li>
</ul>
</li>
</ul>
<h4 id="9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？"><a href="#9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？" class="headerlink" title="9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？"></a>9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？</h4><p><code>dispatch_sync()</code> 向<strong>当前线程</strong>中添加一个任务到指定队列</p>
<ul>
<li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列是同一个串行队列。串行队列中的任务是上一个任务执行完毕才会执行下一个任务。<code>dispatch_sync()</code>会将Block任务添加到队列尾部，等队列中所有任务执行完毕后才会执行；<code>dispatch_sync()</code> 需要Block任务执行完毕才会返回，造成互相等待。</p>
<p><strong>在追加Block执行结束之前，<code>dispach_sync</code> 会一直等待，等待意味着线程停止。</strong></p>
</li>
<li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列不是同一个队列。系统会在当前线程中新开一条指定队列，并加入Block任务到新开队列中，Block任务被执行并返回，然后<code>dispatch_sync()</code> 返回。指定队列无论是串行和并行的，在<code>dispatch_sync()</code> 所在队列中串行执行任务，因为<code>dispatch_sync()</code>  是阻塞的。</p>
</li>
<li><p><code>dispatch_async()</code> 新开线程执行任务，不等Block执行完毕就返回。</p>
</li>
</ul>
<h4 id="10-为什么使用atomic关键字的对象不一定是线程安全的？"><a href="#10-为什么使用atomic关键字的对象不一定是线程安全的？" class="headerlink" title="10.为什么使用atomic关键字的对象不一定是线程安全的？"></a>10.为什么使用atomic关键字的对象不一定是线程安全的？</h4><p>使用atomic只能保证 setter 方法和 getter 方法是线程安全的。但是仍然可能出现线程不安全的情况：</p>
<p><code>@property(atomic, strong)NSMutableArray *array</code>一个线程循环读数据，另一个线程循环存数据，这时就不是线程安全的，因为跟 setter 和 getter 方法没有关系。比如使用<code>[array addObject:object]</code>向数组中添加对象，因为不涉及到 setter 和 getter 方法，故不是线程安全的。</p>
<ul>
<li><p>多线程数据为什么不安全？</p>
<p>每条线程都有自己独立的栈空间，但是它们公用堆空间，所以可能同时访问同一块内存空间，因此造成数据竞争。</p>
</li>
</ul>
<h3 id="三、UI"><a href="#三、UI" class="headerlink" title="三、UI"></a>三、UI</h3><h4 id="1-UITableView优化"><a href="#1-UITableView优化" class="headerlink" title="1.UITableView优化"></a>1.UITableView优化</h4><ol>
<li><p>使用 UITableViewCell 重用机制。</p>
</li>
<li><p>利用 RunLoop 空闲时间执行预缓存任务。</p>
<p>利用 RunLoopObserver 观察当前 RunLoop 的运行状态，并在状态切换时收到通知。</p>
<p>在 RunLoop 即将进入睡眠时使用。</p>
</li>
<li><p>将预缓存任务分解到多个 RunLoop 中执行。</p>
</li>
</ol>
<h4 id="2-UITableViewCell重用机制的原因和原理是什么？"><a href="#2-UITableViewCell重用机制的原因和原理是什么？" class="headerlink" title="2.UITableViewCell重用机制的原因和原理是什么？"></a>2.UITableViewCell重用机制的原因和原理是什么？</h4><ul>
<li><p>关键：</p>
<ul>
<li>==可变数组<code>NSMutableArray *visiableCells</code>  保存屏幕正在显示的cell。==</li>
<li>==可变字典<code>NSMutableDictionary *reusableTableCells</code> 保存可重复利用的cell, key是重用标识identifier。==</li>
<li>==<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 从<code>reusableTableCells</code>中根据identifier取可被重用的cell。==</li>
</ul>
</li>
<li><p>原因：设备内存有限，TableView中有许多cell，而屏幕只能显示有限个cell，如果根据数据将cell全部创建完毕，会造成很大的内存负担。屏幕外的cell不需要立即创建，当滑动屏幕浏览cell时再加载。</p>
</li>
<li><p>作用：<strong>只创建了屏幕可显示的最大cell数+1个cell</strong>，然后循环使用这些cell，同时改变cell显示的数据，达到节省空间的目的。</p>
</li>
<li><p>原理：</p>
<ul>
<li><p>第一次执行<code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code> 方式时，<code>reusableTableCells</code>为空，<code>[tableView dequeueReusableCellWithIdentifier:idertifier forIdentifiter:identifiter]</code> 方法的返回值为nil。</p>
<p>此时通过<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifier:identifier]</code> 创建新的cell。</p>
</li>
<li><p>当数据很多，整个屏幕的cell显示不完全时</p>
<ol>
<li>调用<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifiter:identifier]</code> <strong>创建整个屏幕能显示的cell个数+1个cell</strong>（滑动屏幕时，第一个cell还没移出，最后一个cell已经出现），并且制定标识符identifier。</li>
<li>将创建并显示除最后一个外的cell加入<code>visiableCells</code> 数组，此时<code>reusableTableCells</code>字典为空。</li>
<li>滑动屏幕时，顶端的cell移出屏幕，该cell从<code>visiableCells</code> 数组中移除，并加入到<code>reusableTableCells</code> 字典中，key为该cell的identifier。将最后一个cell加入到<code>visiableCells</code> 数组中。</li>
<li>继续滑动时，<code>reusableTableCells</code> 中已经有值。需要显示新的cell时，<code>cellForRowAtIndexPath</code> 再次被调用，执行<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 方法，返回一个标识为identifier的cell。该cell从<code>reusableTableCells</code> 中移除，添加到<code>visableCells</code> 中，如果<code>resuableTableCells</code> 中没有identifier类型的cell，就会创建一个；同时，移出屏幕的cell从<code>visiableCells</code> 中移除，添加到<code>resuableTableCells</code> 中。</li>
</ol>
</li>
<li><p>iOS6中新方法</p>
<p><code>[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier]</code></p>
<p>当从<code>reusableTableCells</code> 中取cell时，如果没有，系统会自动创建给定类型的cell；如果有，直接重用。</p>
<p>在<code>cellForRowAtIndexPath</code> 中只需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)table:(UITableView *)tableView cellForRowAtIdexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">  &#x2F;&#x2F; 系统会自动判断cell是否存在，不需要手动判断。</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifiter:identifiter forIndexPath:indexPath];</span><br><span class="line">  return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="3-怎样裁剪圆头像"><a href="#3-怎样裁剪圆头像" class="headerlink" title="3.怎样裁剪圆头像"></a>3.怎样裁剪圆头像</h4><h4 id="4-自定义控件的封装"><a href="#4-自定义控件的封装" class="headerlink" title="4.自定义控件的封装"></a>4.自定义控件的封装</h4><h4 id="5-viewController生命周期"><a href="#5-viewController生命周期" class="headerlink" title="5.viewController生命周期"></a>5.viewController生命周期</h4><p><img src="http://img.blog.csdn.net/20130614155652265" alt="viewController声明周期"></p>
<ol>
<li><code>viewWillAppear</code> 之后，<code>viewDidAppear</code> 之前会调用 <code>viewWillLayoutSubviews</code> 和<code>viewDidLayoutSubviews</code> ，可以修改subviews。</li>
<li><code>-loadView</code> 中初始化view, 由系统调用，==在 viewController 的 view 被访问并且为nil时调用==（<code>self.view = …</code>），可能被调用多次。</li>
</ol>
<h4 id="6-改变UIButton的点击面积"><a href="#6-改变UIButton的点击面积" class="headerlink" title="6.改变UIButton的点击面积"></a>6.改变UIButton的点击面积</h4><p>重写<code>UIButton</code>的<code>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code>方法。</p>
<p>该方法返回<code>BOOL</code>值表示判断当前的点击或触摸事件是否在当前的UIView中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@inplementation NewButton</span><br><span class="line"></span><br><span class="line">-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">	CGRect bounds &#x3D; self.bounds;</span><br><span class="line">	bounds &#x3D; CGRectInset(bounds, -50, -50);  &#x2F;&#x2F; 该按钮上下左右范围各扩大了50.</span><br><span class="line">	return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><code>bounds = CGRectInset(bounds, -50, -50)</code> 后两个参数是在左右方向和上下方向扩大或缩小的长度，正值表示缩小，负值表示扩大。该行代码表示在水平和竖直方向各扩大了100。</p>
<p>苹果要求：点击的热点区域不小于44*44 pt。</p>
<h4 id="7-UIView、UIButton-、UITableView的继承关系"><a href="#7-UIView、UIButton-、UITableView的继承关系" class="headerlink" title="7.UIView、UIButton 、UITableView的继承关系?"></a>7.UIView、UIButton 、UITableView的继承关系?</h4><p>UIView -&gt; UIResponder -&gt; NSObject</p>
<p>UIButton -&gt; UIControl -&gt; UIView - &gt; UIResponder -&gt; NSObject</p>
<p>UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject</p>
<h3 id="四、设计模式"><a href="#四、设计模式" class="headerlink" title="四、设计模式"></a>四、设计模式</h3><h4 id="1-KVO的原理？"><a href="#1-KVO的原理？" class="headerlink" title="1.KVO的原理？"></a>1.KVO的原理？</h4><p>KVO的实现依赖于Runtime，使用isa混写（isa-swizzling）实现。当观察对象A时，KVO机制动态的创建对象A当前类的子类，并为这个新类重写了被观察属性的setter方法，在setter方法中通知观察对象属性的改变情况。将对象A的isa指针的指向修改为创建的新类。</p>
<ul>
<li><p>具体实现</p>
<ul>
<li><p>当观察对象A时，KVO机制<strong>动态地创建一个名为<code>NSKVONotifying_A</code>的新类</strong>，该类继承自对象A原来的类，并<strong>重写了被观察属性值的setter方法</strong>。重写的setter方法负责在调用原setter方法<strong>之前</strong>和<strong>之后</strong>，通知所有观察对象：属性值得更改。最后通过<strong>isa混写（isa-swizzling）</strong>把这个对象的isa指针指向新创建的子类，对象变成了新创建子类的实例。</p>
</li>
<li><p>setter方法剖析：</p>
<p>KVO依赖于两个方法<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code>，在原setter方法之前和之后分别调用。重写setter方法的注入是在<strong>运行时</strong>而不是在编译时。</p>
<ul>
<li><code>-willChangeValueForKey:</code>在<strong>属性值发生改变之前</strong>即原setter方法之前调用，通知keyPath属性值即将发生改变。</li>
<li><code>-didChangeValueForKey:</code>在<strong>属性值发生改变之后</strong>即原setter方法之后调用，通知keyPath属性值已经发生改变。</li>
<li>之后<code>-observerValueForKeyPath:ofObject:change:context</code>也会被调用</li>
</ul>
</li>
<li><pre><code class="objective-c">- (void)setName:(NSString *)newName &#123;
    [self willChangeValueForKey:@&quot;name&quot;];
      [super setValue:newName forKey:@&quot;name&quot;];    // 调用父类的存取方法,KVC实现
      [self didChangeValueForKey:@&quot;name&quot;];
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用前提</span><br><span class="line"></span><br><span class="line">  KVO被观察的是对象属性，只有__通过setter方法__或__KVC方法__修改对象属性时KVO才能被触发，使用KVO机制的__*前提是遵循KVO的属性设置方式来变更属性值*__。</span><br><span class="line"></span><br><span class="line">#### 2.手写KVO观察对象过程：</span><br><span class="line"></span><br><span class="line">1. 为__观察的对象__注册观察者</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;objective-c</span><br><span class="line">   &#x2F;* 第一个参数：观察者，负责处理监听事件的对象</span><br><span class="line">      第二个参数：被观察的属性</span><br><span class="line">      第三个参数：被观察属性新旧值得一些配置</span><br><span class="line">      第四个参数：上下文，可以为KVO回调方法传值 *&#x2F;</span><br><span class="line">   [self.person addObserver:self </span><br><span class="line">    			  forKeyPath:@&quot;name&quot; </span><br><span class="line">                    options:NSKeyValueObservingOptionNew |</span><br><span class="line">                            NSKeyValueObservingOptionOld </span><br><span class="line">                    context:nil];</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>被观察的属性发生变化时，收到通知，调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 第一个参数：被观察的属性</span><br><span class="line">   第二个参数：被观察的对象</span><br><span class="line">   第三个参数：改变的属性值，前后的变化都存在字典中</span><br><span class="line">   第四个参数：上下文，context传递的值 *&#x2F;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath object:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if([keyPath isEqualToString:@&quot;name&quot;] &amp;&amp; object &#x3D;&#x3D; self.person) &#123;</span><br><span class="line">        &#x2F;&#x2F; 响应变化处理</span><br><span class="line">      	NSLog(@&quot;new:%@, old:%@&quot;, [change valueForkey:@&quot;old&quot;], [change valueForKey:@&quot;new&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>-dealloc</code>方法中注销观察者 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-怎样手动触发KVO？"><a href="#3-怎样手动触发KVO？" class="headerlink" title="3. 怎样手动触发KVO？"></a>3. 怎样手动触发KVO？</h4><p>​    手动调用<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code></p>
<p>​    场景：希望能控制”回调的调用时机时“（控制<code>-didiChangeValueForKey</code>调用）</p>
<h4 id="4-KVC中setValue-forKeyPath-复制过程？"><a href="#4-KVC中setValue-forKeyPath-复制过程？" class="headerlink" title="4.KVC中setValue: forKeyPath: 复制过程？"></a>4.KVC中<code>setValue: forKeyPath:</code> 复制过程？</h4><ol>
<li>调用 setter 方法。</li>
<li>如果没有对应的 setter 方法，判断是否有与 key 值同名的成员属性，如果有，直接赋值。</li>
<li>如果没有与 key 值同名的成员属性，判断是否有与 key 值同名带下划线的成员属性，如果有，直接赋值。</li>
<li>报错：找不到对应的成员属性。</li>
</ol>
<h4 id="5-对MVC的理解？"><a href="#5-对MVC的理解？" class="headerlink" title="5.对MVC的理解？"></a>5.对MVC的理解？</h4><h4 id="6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"><a href="#6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）" class="headerlink" title="6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"></a>6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）</h4><ul>
<li><p>delegate：一对一</p>
<ul>
<li>优点：<ol>
<li>语法严谨，所有收听到的事件都必须有清楚的定义。</li>
<li>delegate协议中的方法如果没有实现编译器会报错。</li>
<li>每个controller可以遵守多个协议，每个协议有不同的delegate。</li>
<li>能够接收调用协议的协议方法的返回值。delegate可以返回信息给controller。</li>
<li>没有第三方对象要求保持/监视通信过程。</li>
</ol>
</li>
<li>缺点：<ol>
<li>需要定义的代码多：协议的定义，controller的delegate属性，在delegate本身中实现delegate方法的定义。</li>
<li>释放代理对象的时候，需要将delegate改为nil，否则调用对象的方法会crash。</li>
</ol>
</li>
</ul>
</li>
<li><p>block：</p>
<ul>
<li><p>优点</p>
<p>代码量比delegate少，更轻型，使用方便。</p>
</li>
<li><p>缺点：</p>
<ol>
<li>需要注意循环引用的问题。</li>
<li>有多个方法时，假如每个方法设置一个block会更麻烦。</li>
</ol>
</li>
</ul>
</li>
<li><p>Notifaction：一对多</p>
<ul>
<li>优点：<ol>
<li>需要写的代码少。</li>
<li>一对多实现简单。</li>
<li>controller能传递context对象（NSDictionary），context对象携带了发送通知的自定义信息。</li>
</ol>
</li>
<li>缺点：<ol>
<li>编译期不会检查通知是否能被被观察者正确的处理。</li>
<li>释放注册的对象时，需要在通知中心取消注册。</li>
<li>需要第三方管理controller和观察者的关系。</li>
<li>通知发出后，发出通知的对象不能从观察者获得任何反馈。</li>
</ol>
</li>
</ul>
</li>
<li><p>KVO：可以一对多</p>
<ul>
<li>优点：<ol>
<li>能够提供观察的属性的新值和旧值。</li>
<li>通过keyPath观察属性，因此也可以嵌套对象。</li>
<li>能够对非我们创建的对象，即内部对象的状态改变做出相应，而且不需要改变内部对象的实现。</li>
<li>不需要额外的代码允许观察值能够被观察。</li>
</ol>
</li>
<li>缺点：<ol>
<li>被观察的属性必须用string定义，编译器不会对其进行检查，可能写错。</li>
<li>对属性的重构导致代码不可用。</li>
<li>所有的观察代码通过一个方法来指向，导致方法中复杂的if语句。</li>
<li>释放观察者时需要移除观察者。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="五、网络请求"><a href="#五、网络请求" class="headerlink" title="五、网络请求"></a>五、网络请求</h3><h4 id="1-NSURLSession和NSURLConnection区别？"><a href="#1-NSURLSession和NSURLConnection区别？" class="headerlink" title="1.NSURLSession和NSURLConnection区别？"></a>1.NSURLSession和NSURLConnection区别？</h4><p>NSURLConnection从iOS 9废弃，NSURLSession在WWDC2013发布。</p>
<ul>
<li><p>普通任务和上传</p>
<p>NSURLSession 针对普通会话、上传、下载有三种不同的任务<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownnloadTask</code>。创建的会话都是挂起状态，需要<code>resume</code>才能启动。</p>
<ul>
<li>当服务器返回的数据较小时，<code>NSURLSession</code>和<code>NSURLConnection</code>执行普通任务的操作没有区别。</li>
<li>执行上传任务时，<code>NSURLSession</code>和<code>NSURLConnection</code>一样需要设置POST请求的<strong>请求体</strong>进行上传。</li>
</ul>
</li>
<li><p>请求方法的不同</p>
<ul>
<li><code>NSURLConnection</code>实例化对象，<ul>
<li>通过<code>-initWithRequest: delegate:</code>创建的请求被自动发送</li>
<li>通过<code>-initWithRequest: delegate: startImmediately:NO</code>创建的请求通过<code>[connect start]</code>发送请求，方法内部把connect对象作为一个source添加到当前线程的runloop的默认模式下执行。(如果runloop不存在会自动创建当前线程对应的runloop)</li>
</ul>
</li>
<li><code>NSURLSession</code>可以<code>cancel</code>(取消)、<code>suspend</code>(暂停)、<code>resume</code>(恢复)会话，暂停以后可以恢复继续请求。</li>
</ul>
</li>
<li><p>下载任务的方式不同</p>
<ul>
<li><code>NSURLConnection</code>下载文件时，<strong>先将文件下载到内存，再写入沙盒</strong>，如果文件比较大，会<strong>出现内存暴涨</strong>的情况。</li>
<li><code>NSURLSessionDownloadTask</code><ol>
<li>下载文件，<strong>默认下载到沙盒中的tem文件中</strong>，不会出现内存暴涨的情况。但是下载完成后会把tem中的临时文件删除，需要在<code>completionHandler</code>回调方法中将下载的文件移动到别的文件夹。</li>
<li>在代理方法中，能够方便地监听文件的下载进度。</li>
</ol>
</li>
</ul>
</li>
<li><p>断点续传方式不同（<code>NSURLSession</code>更加方便）</p>
<ul>
<li><code>NSURLConnection</code>实现断点续传需要通过设置请求头的<code>HTTPHeaderField</code>的range属性进行。</li>
<li><code>NSURLSessionDownloadTask</code>进行断点续传<ol>
<li>当Task暂停时，如果<code>downloadTask</code>非空，调用<code>-cancelByProducingResumeData:(void(^)(NSData *resumeData))completionHandler</code>接收<code>resumeData</code>参数，保存已下载文件。(注意block中的循环引用，定义self的属性_resumeData, <code>weakSelf.resumeData = resumeData</code>)</li>
<li>再次下载是，如果<code>self.resumeData != nil</code>那么调用<code>[[self.session downloadTaskWithResumeData:self.resumeData] rusume]</code>继续下载，否则创建会话和下载任务。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>NSURLSession</code>可以设置配置信息Configuration。</p>
<ul>
<li><code>+(NSURLSession *)sessionWithConfiguration: delegate: delegateQueue:</code></li>
<li>可以设置缓存策略，是否在后台进行请求，最大主机连接数，网络超时等。</li>
</ul>
</li>
</ul>
<h4 id="2-AFN框架为什么封装NSURLSession？"><a href="#2-AFN框架为什么封装NSURLSession？" class="headerlink" title="2.AFN框架为什么封装NSURLSession？"></a>2.AFN框架为什么封装NSURLSession？</h4><h3 id="六、底层相关"><a href="#六、底层相关" class="headerlink" title="六、底层相关"></a>六、底层相关</h3><h4 id="1-iOS程序的加载过程是什么？"><a href="#1-iOS程序的加载过程是什么？" class="headerlink" title="1.iOS程序的加载过程是什么？"></a>1.iOS程序的加载过程是什么？</h4><ol>
<li>执行 <code>main</code> 函数。</li>
<li>执行 <code>UIApplicationMain</code> 函数。</li>
<li>创建 <code>UIApplication</code> 对象（是单例的）。</li>
<li>创建 <code>UIApplication</code> 的代理，并且设置 application 的代理。</li>
<li>开启 主<code>RunLoop</code>。</li>
<li>加载完毕后调用 <code>- application: didFinishLaunchingWithOptions:</code>。</li>
</ol>
<h4 id="2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？"><a href="#2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？" class="headerlink" title="2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？"></a>2.<code>&lt;UIApplicationDelegate&gt;</code> 中有哪些方法？有什么作用？</h4><ul>
<li><code>- application: didFinishLaunchingWithOptions:</code> 应用被加载完毕后被调用</li>
<li><code>- applicationWillResignActive:</code> 当应用即将变为不活动状态时调用，比如电话进入、退出应用程序或开始进入后台状态。</li>
<li><code>- applicationDidEnterBackground:</code> 当应用进入后台状态后调用。在后台状态中应用工作，但是不派发新的事件到响应器。</li>
<li><code>- applicationWillEnterForeground</code> 应用将要回到前台时调用。</li>
<li><code>- applicationDidBecomeActive:</code> 应用已经变为活动状态时调用。</li>
<li><code>- applicationWillTerminate:</code> 应用即将结束时调用。</li>
<li><code>- applicationDidReceiveMemoryWarning:</code> 收到内存警告时调用。</li>
</ul>
<h4 id="3-load-方法和-initialize-方法异同"><a href="#3-load-方法和-initialize-方法异同" class="headerlink" title="3.+load 方法和 +initialize 方法异同"></a>3.<code>+load</code> 方法和 <code>+initialize</code> 方法异同</h4><ul>
<li>相同：<ul>
<li>都在实例化对象==之前==调用。</li>
<li>内部都使用了锁，应该避免线程阻塞在方法中。</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>+load</code> 方法</p>
<ul>
<li><p><code>+load</code> 方法在这个==文件被程序加载时==调用，程序启动时会调用<strong>所有</strong>类的<code>+load</code> 方法。与类的使用与否<strong>无关</strong>。</p>
</li>
<li><p><code>+load</code> 方法在<code>main</code>函数之==前==调用。</p>
</li>
<li><p>先调用父类的 <code>+load</code> 方法，再调用子类的 <code>+load</code> 方法。自动完成。</p>
<p>如果一个子类没有实现 <code>+load</code> 方法，那么也就<strong>不会</strong>调用父类的<code>+load</code> 方法。</p>
</li>
<li><p>使用场景：在<code>+load</code>方法中实现 Method swizzle。</p>
</li>
</ul>
</li>
<li><p><code>+initialize</code> 方法</p>
<ul>
<li><p>当第一次给一个类发送消息时，它的<code>+initiallze</code>方法会被调用。<strong><em>只会调用一次</em></strong>。</p>
<p>如果一个类一直没有被使用，它的<code>+initialize</code>方法不会被调用。</p>
</li>
<li><p>在<code>main</code>函数之==后==被调用。</p>
</li>
<li><p>先调用父类的<code>+initialize</code>方法，再调用子类的<code>+initialize</code>方法。</p>
<p>如果子类没有实现<code>+initialize</code>方法没有被实现，父类的<code>+initialize</code>方法也会被调用。</p>
</li>
<li><p>使用场景：初始化全局变量或静态变量。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？"><a href="#4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？" class="headerlink" title="4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？"></a>4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？</h4><blockquote>
<ul>
<li><code>_objc_msgForward</code>是 IMP 类型(一个函数指针)，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</li>
</ul>
</blockquote>
<p>IMP: 指向方法实现开头的指针。</p>
<ul>
<li>我们可以这样创建一个<code>_objc_msgForward</code>对象：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>objc_msgSend</code>在“消息传递”中的作用：</p>
<p>在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p>
</li>
<li><p>消息转发过程：</p>
<ol>
<li>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</li>
<li>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</li>
<li>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</li>
<li>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</li>
<li>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</li>
</ol>
<ul>
<li>最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</li>
</ul>
</li>
</ul>
<ul>
<li><code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：<ol>
<li><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</li>
<li><code>forwardingTargetForSelector:</code>方法</li>
<li><code>methodSignatureForSelector:</code>方法</li>
<li><code>forwardInvocation:</code>方法</li>
<li><code>doesNotRecognizeSelector:</code> 方法</li>
</ol>
</li>
</ul>
<ul>
<li><p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p>
<p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p>
<p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p>
<blockquote>
<p>“我没有在这个对象里找到这个方法的实现”</p>
</blockquote>
<p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。</p>
</li>
</ul>
<h4 id="5-block为什么能够-block-在内部修改-blcok-外部变量？"><a href="#5-block为什么能够-block-在内部修改-blcok-外部变量？" class="headerlink" title="5.__block为什么能够 block 在内部修改 blcok 外部变量？"></a>5.<code>__block</code>为什么能够 block 在内部修改 blcok 外部变量？</h4><blockquote>
<p>我们都知道：<strong>Block不允许修改外部变量的值</strong>，这里所说的==<strong>外部变量的值，指的是栈中指针的内存地址</strong>。==<code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就<strong>将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</strong></p>
</blockquote>
<p>block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址</p>
<p> 变量在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="1-访问域名和访问IP地址的区别？"><a href="#1-访问域名和访问IP地址的区别？" class="headerlink" title="1.访问域名和访问IP地址的区别？"></a>1.访问域名和访问IP地址的区别？</h4><ul>
<li>IP地址是服务器的物理地址，一台服务器可能对应多个网站，访问IP地址可能不知道要访问哪个。</li>
<li>一个域名可能对应多个IP地址，通过域名访问自动选择速度最快的建立连接。</li>
</ul>
<h4 id="2-访问www-xxx-com的过程？"><a href="#2-访问www-xxx-com的过程？" class="headerlink" title="2.访问www.xxx.com的过程？"></a>2.访问<a href="http://www.xxx.com的过程？">www.xxx.com的过程？</a></h4><ol>
<li><p>首先找本机的HOSTS文件，映射为IP地址或客户端向 DNS 服务器请求解析该 URL 中域名对应的 IP 地址。<strong>(域名解析)</strong></p>
</li>
<li><p>根据 IP 地址和端口，客户端同服务器建立连接。<strong>(建立连接)</strong></p>
</li>
<li><p>客户端向服务器发送请求。<strong>(发送请求)</strong></p>
<p>该请求报文作为 TCP 三次握手第三个报文的数据发送给服务器。</p>
</li>
<li><p>服务器对请求做出响应，并把对应的数据发送给客户端。<strong>(作出相应)</strong></p>
</li>
<li><p>释放 TCP 连接。<strong>(释放连接)</strong></p>
</li>
<li><p>客户端对响应数据进行解析、处理。<strong>(解析数据)</strong></p>
</li>
</ol>
<h4 id="3-GET和POST请求的区别？POST一定安全么？"><a href="#3-GET和POST请求的区别？POST一定安全么？" class="headerlink" title="3.GET和POST请求的区别？POST一定安全么？"></a>3.GET和POST请求的区别？POST一定安全么？</h4><ul>
<li>请求形式<ul>
<li>GET 请求：请求的数据附在 URL 之后（数据在请求头中）。以？分割URL和传输数据，多个参数用&amp;相连。</li>
<li>POST 请求：请求的数据封装在请求体中。</li>
</ul>
</li>
<li>安全性<ul>
<li>GET 请求：请求的数据在地址栏中显示。</li>
<li>POST 请求：请求的数据虽然在请求体中，但也不安全，需要加密。</li>
</ul>
</li>
<li>传输数据的大小<ul>
<li>GET 请求：传输数据受URL长度限制，特定浏览器和服务器对URL的长度有限制。</li>
<li>POST 请求：理论上不受限制，实际服务器会对 POST 请求提交的数据大小进行限制。</li>
</ul>
</li>
<li>获取变量值的方式<ul>
<li>GET 请求：Request QueryString</li>
<li>POST 请求：Request Form</li>
</ul>
</li>
</ul>
<h4 id="4-HTTPS安全协议请求过程-HTTPS握手-是什么？"><a href="#4-HTTPS安全协议请求过程-HTTPS握手-是什么？" class="headerlink" title="4.HTTPS安全协议请求过程(HTTPS握手)是什么？"></a>4.HTTPS安全协议请求过程(HTTPS握手)是什么？</h4><p><img src="http://upload-images.jianshu.io/upload_images/449687-4e2ec739a1487779?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信过程"></p>
<ul>
<li><p><strong>涉及密钥：</strong></p>
<p>对称加密密钥A 。</p>
<p>用于加密密钥A的非对称密钥B。公钥发送给客户端，私钥服务器持有。</p>
<p>用于加密密钥B公钥的CA证书密钥C。公钥保存在浏览器或系统中，私钥服务器持有。</p>
</li>
<li><p>请求过程(HTTPS握手)：</p>
<ol>
<li><p>客户端发送HTTPS请求，请求对称加密公钥B。</p>
</li>
<li><p>服务器响应客户端请求，发送CA数字证书。</p>
<p>证书中包括：密钥B的公钥，域名，服务器信息，数字签名，数字摘要算法等信息。</p>
</li>
<li><p>客户端验证CA数字证书的正确性。</p>
<ul>
<li>验证域名的正确性，比较CA证书中的域名和请求域名，可以验证证书是否是服务器发送的。</li>
<li>验证CA证书中数字签名，可以验证CA证书是否被第三方篡改。</li>
</ul>
</li>
<li><p>客户端用CA证书的公钥对密文解密，得到密钥B的公钥。</p>
</li>
<li><p>客户端生成密钥A，用密钥B的公钥进行加密，发送给服务器。</p>
</li>
<li><p>服务器用密钥B的私钥对密文进行解密，得到密钥A。</p>
</li>
<li><p>安全连接建立完成，双方用密钥A对信息进行对称加密传输。</p>
</li>
</ol>
</li>
<li><p>HTTPS加密在传输层</p>
<p>HTTPS报文在包装成TCP报文的时候完成加密过程，报文的header和body都会被加密。</p>
</li>
</ul>
<h4 id="5-HTTPS作用？"><a href="#5-HTTPS作用？" class="headerlink" title="5.HTTPS作用？"></a>5.HTTPS作用？</h4><ul>
<li>内容加密：建立一个信息安全通道，来保证数据传输的安全。</li>
<li>身份认证：认证用户或服务器，确保数据发送到正确的客户或服务器。</li>
<li>数据完整性：防止内容被第三方冒充或篡改。（原因：数字摘要）</li>
</ul>
<h4 id="6-HTTP和HTTPS区别？"><a href="#6-HTTP和HTTPS区别？" class="headerlink" title="6.HTTP和HTTPS区别？"></a>6.HTTP和HTTPS区别？</h4><ul>
<li><p>HTTPS需要到CA申请证书或自制证书。</p>
</li>
<li><p>HTTP直接进行明文传输。</p>
<p>HTTPS先经过具有安全性的SSL/TSL（表示层）加密，再传输密文。</p>
</li>
<li><p>HTTP端口：80。</p>
<p>HTTPS端口：443。</p>
</li>
</ul>
<h4 id="7-数字证书作用？"><a href="#7-数字证书作用？" class="headerlink" title="7.数字证书作用？"></a>7.数字证书作用？</h4><ul>
<li><p>确定得到公钥的正确性</p>
</li>
<li><p>确定目标主机的正确性</p>
<p>​</p>
</li>
<li><p>数字证书包括：</p>
<ul>
<li>用户个人信息、公钥信息、颁发机构名称、证书本身的数字签名、证书数字签名用的HASH算法。</li>
</ul>
</li>
</ul>
<h4 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h4><ul>
<li>数字签名 = 非对称加密 + 数字摘要</li>
<li>数字签名验证数据完整性过程：<ul>
<li>将摘要信息用发送者私钥加密后，与原文一起传送给接受者。<strong>(摘要+原文)</strong></li>
<li>接受者用发送者的公钥将被加密的摘要解密。<strong>(解密)</strong></li>
<li>接受者用与发送者相同的HASH算法对接收到的明文产生一个摘要信息。<strong>(产生摘要)</strong></li>
<li>将产生的摘要与解密得到的摘要进行对比，如果相同，则数据没有被修改。<strong>(比较摘要)</strong></li>
</ul>
</li>
</ul>
<h4 id="9-请求报文包括哪些？请求体和请求报文的关系？"><a href="#9-请求报文包括哪些？请求体和请求报文的关系？" class="headerlink" title="9.请求报文包括哪些？请求体和请求报文的关系？"></a>9.请求报文包括哪些？请求体和请求报文的关系？</h4><p>请求报文包括：请求行、请求头、空行、请求体。</p>
<p>请求报文包括请求体。</p>
<p>响应报文包括：状态行、响应头、空行，响应体。</p>
<h4 id="10-UDP和TCP的区别？"><a href="#10-UDP和TCP的区别？" class="headerlink" title="10.UDP和TCP的区别？"></a>10.UDP和TCP的区别？</h4><ul>
<li><p>TCP：面向连接，三次握手最低限度保证连接可靠性</p>
<p>UDP：无连接，传送数据前无需建立连接，数据到达后也无需确认。（发送端不知道数据是否到达接收端，也不知道数据是否被正确接受）</p>
</li>
<li><p>TCP：可靠交付。</p>
<p>UDP：不可靠交付。</p>
</li>
<li><p>TCP：报文头部长，传输开销大</p>
<p>UDP：报文头部短，传输开销小，时延较短，实用性更好。</p>
</li>
</ul>
<h4 id="11-TCP三次握手和四次挥手过程"><a href="#11-TCP三次握手和四次挥手过程" class="headerlink" title="11.TCP三次握手和四次挥手过程"></a>11.TCP三次握手和四次挥手过程</h4><ul>
<li><p>三次握手</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1641067-8d52ca990ffbee0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p>
</li>
<li><p>四次挥手</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="四次挥手"></p>
</li>
</ul>
<h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h4 id="1-strstr函数是什么？"><a href="#1-strstr函数是什么？" class="headerlink" title="1.strstr函数是什么？"></a>1.strstr函数是什么？</h4><h4 id="2-free-函数做了什么？"><a href="#2-free-函数做了什么？" class="headerlink" title="2.free() 函数做了什么？"></a>2.free() 函数做了什么？</h4><h4 id="3-strcpy和strnpy函数的区别？"><a href="#3-strcpy和strnpy函数的区别？" class="headerlink" title="3.strcpy和strnpy函数的区别？"></a>3.strcpy和strnpy函数的区别？</h4>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author: </strong>bomo
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/" title="iOSiOS面试整理(一)">http://fangliquan.github.io/2021-03-14/iOS面试整理(一)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a>" rel="external nofollow" target="_blank">undefined</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017-03-20/swift3-0-Protocol-And-Eextension/" rel="prev" title="swift3.0_协议(Protocal)和扩展(Extension)">
      <i class="fa fa-chevron-left"></i> swift3.0_协议(Protocal)和扩展(Extension)
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS"><span class="nav-number">1.</span> <span class="nav-text">iOS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">一、内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B0%88%E8%B0%88%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.谈谈对内存管理的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MRC"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">MRC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ARC"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">ARC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-ARC%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">2.ARC如何实现？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AF%B9MRC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.1.3.</span> <span class="nav-text">3.对MRC的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E5%92%8CARC%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.GC（垃圾回收）和ARC的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%86%85%E5%AD%98%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88assign-weak-strong-copy-retain-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.内存关键字（assign, weak, strong, copy, retain)介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-weak%E5%92%8Cstrong%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%85%E9%83%A8%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">6.weak和strong关键字内部做了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E9%99%A4%E4%BA%86NSString%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E7%94%A8copy%EF%BC%9Fblock%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%8D%E5%88%B6%E5%88%B0%E5%A0%86%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">7.除了NSString什么情况下用copy？block为什么要复制到堆中？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E8%B0%83%E7%94%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%89%E6%97%B6%E9%9C%80%E8%A6%81release%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">8.调用静态方法（类方法）时需要release么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-autorelease%EF%BC%8CAutoreleasePool%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.9.</span> <span class="nav-text">9. autorelease，AutoreleasePool的原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-autoreleasepool%E7%9A%84drain%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.10.</span> <span class="nav-text">10.autoreleasepool的drain时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-autoreleasepool%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">1.1.11.</span> <span class="nav-text">11.autoreleasepool的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-iOS%E4%B8%AD%E5%A0%86%E6%A0%88%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.1.12.</span> <span class="nav-text">12.iOS中堆栈的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-weak%E5%9C%A8%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81%E6%97%B6%E4%BD%BF%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E7%BD%AEnil%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">13.weak在对象销毁时使指向对象的指针置nil的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-block%E4%BD%9C%E4%B8%BAviewControler%E5%B1%9E%E6%80%A7%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9Cblock%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86self-view%E4%BC%9A%E5%8F%91%E7%94%9F%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.14.</span> <span class="nav-text">14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">二、多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.对多线程的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-iOS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.iOS中实现多线程的方式有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-GCD%E5%92%8CNSOperation%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.GCD和NSOperation优缺点？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%AD%BB%E9%94%81%E5%8F%91%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.死锁发生的原因是什么？如何避免？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-iOS%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.iOS中有哪些锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-iOS%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.iOS中线程安全有哪些情况？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C%E5%AF%B9%E5%90%8C%E4%B8%80%E5%9D%97%E8%B5%84%E6%BA%90%E5%8F%91%E7%94%9F%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E6%97%B6%E8%83%BD%E6%80%8E%E6%A0%B7%E5%81%9A%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">7.多线程操作对同一块资源发生数据竞争时能怎样做？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-atomic%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.2.8.</span> <span class="nav-text">8.atomic实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8-dispatch-sync-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97-%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="nav-number">1.2.9.</span> <span class="nav-text">9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8atomic%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.10.</span> <span class="nav-text">10.为什么使用atomic关键字的对象不一定是线程安全的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81UI"><span class="nav-number">1.3.</span> <span class="nav-text">三、UI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-UITableView%E4%BC%98%E5%8C%96"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.UITableView优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-UITableViewCell%E9%87%8D%E7%94%A8%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.UITableViewCell重用机制的原因和原理是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%80%8E%E6%A0%B7%E8%A3%81%E5%89%AA%E5%9C%86%E5%A4%B4%E5%83%8F"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.怎样裁剪圆头像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.自定义控件的封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-viewController%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.viewController生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%94%B9%E5%8F%98UIButton%E7%9A%84%E7%82%B9%E5%87%BB%E9%9D%A2%E7%A7%AF"><span class="nav-number">1.3.6.</span> <span class="nav-text">6.改变UIButton的点击面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-UIView%E3%80%81UIButton-%E3%80%81UITableView%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="nav-number">1.3.7.</span> <span class="nav-text">7.UIView、UIButton 、UITableView的继承关系?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">四、设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-KVO%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.KVO的原理？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%80%8E%E6%A0%B7%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91KVO%EF%BC%9F"><span class="nav-number">1.4.2.</span> <span class="nav-text">3. 怎样手动触发KVO？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-KVC%E4%B8%ADsetValue-forKeyPath-%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.KVC中setValue: forKeyPath: 复制过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AF%B9MVC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">5.对MVC的理解？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Notifaction%E3%80%81KVO%E3%80%81block%E3%80%81delegate%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BD%93%E5%8F%91%E7%94%9F%E5%A4%A7%E9%87%8F%E9%80%9A%E4%BF%A1%E6%97%B6%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88delegate%EF%BC%89"><span class="nav-number">1.4.5.</span> <span class="nav-text">6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82"><span class="nav-number">1.5.</span> <span class="nav-text">五、网络请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-NSURLSession%E5%92%8CNSURLConnection%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.NSURLSession和NSURLConnection区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-AFN%E6%A1%86%E6%9E%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%81%E8%A3%85NSURLSession%EF%BC%9F"><span class="nav-number">1.5.2.</span> <span class="nav-text">2.AFN框架为什么封装NSURLSession？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BA%95%E5%B1%82%E7%9B%B8%E5%85%B3"><span class="nav-number">1.6.</span> <span class="nav-text">六、底层相关</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-iOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.iOS程序的加载过程是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-lt-UIApplicationDelegate-gt-%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.6.2.</span> <span class="nav-text">2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-load-%E6%96%B9%E6%B3%95%E5%92%8C-initialize-%E6%96%B9%E6%B3%95%E5%BC%82%E5%90%8C"><span class="nav-number">1.6.3.</span> <span class="nav-text">3.+load 方法和 +initialize 方法异同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%EF%BC%8C-objc-msgForward%E5%87%BD%E6%95%B0%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.6.4.</span> <span class="nav-text">4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-block%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F-block-%E5%9C%A8%E5%86%85%E9%83%A8%E4%BF%AE%E6%94%B9-blcok-%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">1.6.5.</span> <span class="nav-text">5.__block为什么能够 block 在内部修改 blcok 外部变量？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">2.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AE%BF%E9%97%AE%E5%9F%9F%E5%90%8D%E5%92%8C%E8%AE%BF%E9%97%AEIP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.0.1.</span> <span class="nav-text">1.访问域名和访问IP地址的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AE%BF%E9%97%AEwww-xxx-com%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.0.2.</span> <span class="nav-text">2.访问www.xxx.com的过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-GET%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FPOST%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E4%B9%88%EF%BC%9F"><span class="nav-number">2.0.3.</span> <span class="nav-text">3.GET和POST请求的区别？POST一定安全么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-HTTPS%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B-HTTPS%E6%8F%A1%E6%89%8B-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.0.4.</span> <span class="nav-text">4.HTTPS安全协议请求过程(HTTPS握手)是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-HTTPS%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.0.5.</span> <span class="nav-text">5.HTTPS作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-HTTP%E5%92%8CHTTPS%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.0.6.</span> <span class="nav-text">6.HTTP和HTTPS区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">2.0.7.</span> <span class="nav-text">7.数字证书作用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="nav-number">2.0.8.</span> <span class="nav-text">8.数字签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B7%E6%B1%82%E4%BD%93%E5%92%8C%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">2.0.9.</span> <span class="nav-text">9.请求报文包括哪些？请求体和请求报文的关系？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-UDP%E5%92%8CTCP%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.0.10.</span> <span class="nav-text">10.UDP和TCP的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-number">2.0.11.</span> <span class="nav-text">11.TCP三次握手和四次挥手过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80"><span class="nav-number">3.</span> <span class="nav-text">C语言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-strstr%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.0.1.</span> <span class="nav-text">1.strstr函数是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-free-%E5%87%BD%E6%95%B0%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.0.2.</span> <span class="nav-text">2.free() 函数做了什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-strcpy%E5%92%8Cstrnpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.0.3.</span> <span class="nav-text">3.strcpy和strnpy函数的区别？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS,Windows开发者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengbomo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengbomo@hotmail.com" title="Email → mailto:zhengbomo@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/intent/user?user_id=371531868" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;intent&#x2F;user?user_id&#x3D;371531868" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://facebook.com/zhengbomo" title="Facebook → http:&#x2F;&#x2F;facebook.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://message/?uin=449179249&Site=&Menu=yes" title="QQ → tencent:&#x2F;&#x2F;message&#x2F;?uin&#x3D;449179249&amp;Site&#x3D;&amp;Menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/1891587992" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;1891587992" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bomo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
