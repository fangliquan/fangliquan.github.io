<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fangliquan.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="91 组件化1.底基层(放置最基础,最常用的相关库)—MMBaseFoundation—baseCypto2.底层基础层(主要提供各种基础功能(网络库,数据库, im等))—MFDB—SDWebimage3.底层应用层(提供各种通用代理等)—DNS—MDAnalyzeRecord4.业务基础层—momokit—MDWebview5.业务应用层(封装一些通用业务的功能)—大图预览 70 pod库循环">
<meta property="og:type" content="article">
<meta property="og:title" content="2021-03-14-iOS面试整理(二)">
<meta property="og:url" content="http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/index.html">
<meta property="og:site_name" content="microleo的个人博客">
<meta property="og:description" content="91 组件化1.底基层(放置最基础,最常用的相关库)—MMBaseFoundation—baseCypto2.底层基础层(主要提供各种基础功能(网络库,数据库, im等))—MFDB—SDWebimage3.底层应用层(提供各种通用代理等)—DNS—MDAnalyzeRecord4.业务基础层—momokit—MDWebview5.业务应用层(封装一些通用业务的功能)—大图预览 70 pod库循环">
<meta property="og:locale">
<meta property="article:published_time" content="2021-03-16T03:48:09.000Z">
<meta property="article:modified_time" content="2021-03-16T03:48:55.183Z">
<meta property="article:author" content="microleo">
<meta property="article:tag" content="iOS面试">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>2021-03-14-iOS面试整理(二) | microleo的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="microleo的个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">microleo的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">工作学习中的学习笔记及技术积累</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">17</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-exclamation-circle fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Author">
      <meta itemprop="description" content="iOS,Windows开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="microleo的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2021-03-14-iOS面试整理(二)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Post created:2021-03-16 11:48:09 / Post modified:11:48:55" itemprop="dateCreated datePublished" datetime="2021-03-16T11:48:09+08:00">2021-03-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>91 组件化<br>1.底基层(放置最基础,最常用的相关库)<br>—MMBaseFoundation<br>—baseCypto<br>2.底层基础层(主要提供各种基础功能(网络库,数据库, im等))<br>—MFDB<br>—SDWebimage<br>3.底层应用层(提供各种通用代理等)<br>—DNS<br>—MDAnalyzeRecord<br>4.业务基础层<br>—momokit<br>—MDWebview<br>5.业务应用层(封装一些通用业务的功能)<br>—大图预览</p>
<p>70 pod库循环引用怎么解决<br>如何检测？  Pod install就会报错，<br>解决方案，分层，通过代理解决</p>
<p>71 防Crash 方案<br>1.UI非主线程刷新<br>setNeedsLayout、setNeedsDisplay、setNeedsDisplayInRect:、setNeedsUpdateConstraints四个方法，判断当前是否是主队列，如果不是主队列，则跳转到dispatch_get_main_queue执行。<br>2.KVO 非对称添加删除<br>hook了NSObject的addObserver:forKeyPath:options:context:、removeObserver:forKeyPath:。为被观察对象增加一个map属性，存储所有的observer和keypath的对应关系。每次添加或者删除观察者的时候，都会先去检查observer的keypath是否已存在或者消失，在执行相当逻辑。避免重复添加或者删除<br>3.unrecognized selector<br>forwardingTargetForSelector<br>4.container类型crash, 数组越界</p>
<p>计算机基础</p>
<p>69 mp3和wav的区别</p>
<p>Wav是无损音乐的一种, 文件较大, 和CD格式一样, 44.1k的取样频率, 最接近无损的音乐格式<br>Mp3文件通过对音频进行编码, 去掉了某些部分, 节省空间<br>Pcm 数据是最原始的音频数据, 完全无损. pcm是没有压缩的编码方式 ,Wav是使用pcm编码的一种音频格式. Wav就是pcm+文件头</p>
<p>68 HTTP2.0 和 HTTP1.1的区别<br>—多路复用, 现在只是并发请求, 相互之间没有影响<br>—首部压缩<br>—流量控制</p>
<p>48 HTTPS</p>
<p>HTTPS是HTTP协议+SSL/TLS协议. 让HTTP先和SSL通信, 再由SSL和服务器通信,  (私钥还是公钥)</p>
<p>HTTPS的采用了混合的加密机制, 使用非对称秘钥加密方式, 传输对称秘钥秘钥加密方式所需要的key, 获取到key后, 在使用对称秘钥加密方式进行通讯, 从而保证效率</p>
<p>如何连接的?, 秘钥怎么交换<br>客户端连接上服务器, 服务器发送CA证书给客户端, 客户端随机生成会话秘钥K, 用CA证书加密, 然后发给服务端, 服务器用自己的私钥解密得到会话秘钥K, 然后用秘钥K进行通信</p>
<p>RSA非对称加密<br>AES对称加密</p>
<p>TCP协议的三次握手和四次挥手<br>客户端和服务器端的通信其实和人与人之间的通信是一样的, 假设两个人相互确认对方<br>三次握手</p>
<p>第一次握手: 客户端给服务发送一个SYN报文, 此时客户处于SYN_SEND状态<br>第二次握手: 服务器收到SYN报文后, 会以自己的SYN报文作为应答, 同时也会以客户端ISN+1作为ACK的值, 表示自己已经收到了客户端的SYN, 此时服务器处于SYN_REVD的状态<br>第三次握手: 客户端收到SYN报文之后, 会发送一个ACK报文, 也是一样把服务器的ISN+1作为ACK的值, 标识已经收到服务器的SYN报文</p>
<p>三次握手可以携带数据吗?<br>第三次可以, 前两次不可以</p>
<p>四次挥手<br>第一次挥手:客户方发送一个FIN报文, FIN=1, 并停止在发送数据,<br>第二次挥手: 服务器收到FIN之后, 会发送ACK报文, 且把客户端的序列号值+1作为ACK报文的序列号<br>第三次挥手:服务器发送FIN报文<br>第四次挥手:客户端收到FIN之后, 一样会发送一个ACK报文作为应答, 且把服务端的序列号值+1. 服务器收到ACK之后, 处于关闭状态, 客户端会在发出确认报文之后, 进入时间等待, 经过2MSL后, 客户端才进入closed状态</p>
<p>为什么连接只用三次握手, 而断开连接却要四次挥手?<br>Tcp 链接是一种全双工传输模式, 既是数据的发送方也是数据的接收方, 所以需要两端都完成数据传输之后在断开, 保证链接释放的可靠性<br>首先, 当客户端数据已发送完毕, 且知道服务器也全部接受到时, 就会去断开连接即向服务器端发送FIN<br>服务器端收到客户端的FIN, 为了标识接收到了, 就会向客户端发送ACK<br>但此时, 服务器可能还在发送数据, 并没有关闭TCP窗口的意思, 所以服务器的FIN和ACK并不是同步发的, 只有当数据发送完, 才会发送FIN</p>
<p>综上所述, 服务器的FIN和ACK需要分开发, 并不是像三次握手那样, SYN可以和ACK同步发, 所以就需要四次挥手</p>
<p>TCP和UDP的区别<br>    0.    基于链接与无连接<br>    0.    对系统资源的要求(TCP较多, UDP较少)<br>    0.    Udp 程序结构较简单<br>    0.    流模式与数据包模式<br>    0.    Tcp保证数据正确性, UDP可能丢包<br>    0.    TCP 保证数据顺序 UDP不保证</p>
<p>HTTP状态码<br>1XX: 请求正在处理<br>2XX: 请求正常处理完毕<br>3XX: 重定向<br>4XX: 客户端错误状态码  404 notFound<br>5XX: 服务器错误  500 Internal server error 服务器正在执行请求时发生错误</p>
<p>对称加密: DES<br>非对称加密 RSA</p>
<p>http请求头和响应头<br>常用的请求头<br>accept: <em>/</em> 可以处理所有类型<br>accept-encoding<br>accept-language<br>connection:keep-alive<br>host:<br>UA<br>cookie:<br>range</p>
<p>响应头<br>Content-type:告诉客户端资源文件的类型<br>connection:keep-alive</p>
<p>七层设计模式, 对应做什么的<br>应用层-HTTP协议 FTP协议<br>表示层-数据的编码解码, 将设备固有的数据格式转换为网络标准传输格式<br>会话层—三次握手,四次挥手在这里完成的<br>传输层—TCP/UDP<br>网络层-根据网络设备地址路由数据包, 地址解析, ip<br>数据链路层—物理地址寻址, 流量控制, 重发<br>物理层:物理设备</p>
<p>5层<br>应用层<br>传输层<br>网络层<br>数据链路层<br>物理层</p>
<p>78 多态<br>子类通过覆盖或重载父类的方法, 使得对同一类对象统一方法的调用产生不同的结果</p>
<p>77 设计模式  java里面有23中, 但是不一定能映射到ios上面<br>单例模式,<br>工厂方法模式<br>观察者模式<br>抽象工厂模式</p>
<p>工厂模式<br>在工厂模式中, 可以根据参数的不同返回不同类的实例. 简单工厂模式专门定义一个类来负责创建其他类的实例. 被创建的实例通常都具有共同的父类</p>
<p>抽象工厂模式生产的事多个不同类型的类, 所以必须将公共点抽象出来</p>
<p>普通工厂产出是一个产品（实例），抽象工厂产出是一个抽象（接口）。区别在于，若添加一个新的产品，前者是修改工厂，后者是创建新工厂（符合“闭合原则”）。</p>
<p>设计模式6大原则<br>1.单一责任原则<br>—一个类就干一类事情, 不要耦合<br>2.开放封闭原则<br>—类,函数等应该是可以拓展的, 但是不可修改<br>3.里式替换原则<br>—只要父类能出现的地方, 子类也能出现, 反之, 父类则未必能胜任<br>4.依赖倒置原则<br>—高层模块不应该依赖于底层模块<br>5.接口隔离原则<br>—建立单一接口, 不要建立庞大臃肿的接口<br>6.迪米特法则<br>—迪米特法则又叫做最少知道原则, 就是一个类对自己依赖的类知道的越少越好. 对于被依赖的类来说, 无论逻辑多么复杂, 都尽量地将逻辑封装在类的内部, 对外提供public放阿飞, 不对外泄漏任何信息. 迪米特发着还有个简单的定义, 只与直接的朋友通信<br>解决方案: 尽量降低类与类之间的耦合</p>
<p>31 数据库索引<br>唯一索引和普通索引使用的都是B-Tree, 执行时间复杂度都是O(logn)<br>普通索引: 由关键字Key或INDEX定义的索引, 唯一任务是加快数据的访问速度. 应该为那些经常出现在查询条件或排序条件中的数据列创建索引. 被索引的数据列包含重复的值<br>唯一索引:确定某个数据列将至包含彼此各不相同的值, 那就应该用关键字 UNIQUE把它定义为一个唯一索引. 好处是, 1.简化了对索引的管理工作, 这个索引也因此而变得更有效率. 二是, 数据库会在有新纪录插入数据表是, 自动检查新纪录的这个字段的值是否已经在某个记录的字段里出现过. 唯一索引既可以保证数据的重复出现, 又可以提高访问速度<br>主键索引: 唯一索引的特殊类型</p>
<p>主键和索引的区别<br>    0.    对于主键, oracle, sql, musql都会自动建立唯一索引<br>    0.    主键课作为外键, 唯一索引不可<br>    0.    主键不可为空, 唯一索引可以<br>    0.    主键也可以是多个字段的组合<br>    0.    主键和唯一索引不同的是, A 有not null属性, B,每个表只能有一个</p>
<p>61 git 原理, git 的各种命令</p>
<p>Git 是一种分布式版本控制系统</p>
<p>从本质上讲, git是一套内容寻址的文件系统, 他存储的也是key-value键值对, 然后根据key值来寻找value. git根据指针来寻址的, 这些指针就存储在git对象中.git共有三种对象, commit对象, tree对象, blob对象</p>
<p>Git的核心是它的对象数据库, 其中保存了git的对象, 其中最重要的事blob(数据对象), tree和commit对象. blob对象实现了对文件内容的记录, tree对象实现了对文件名,文件目录结构的记录, commit对象实现了对版本提交时间, 版本作者, 版本序列,版本说明等附加信息的记录. 这三类对象, 完美实现了git的基础功能: 对版本状态的记录</p>
<p>Git所做的实质工作是将被改写的文件保存为数据对象, 更新暂存区, 记录树对象, 最后创建一个指明了顶层树对象和父提交的提交对象</p>
<p>Git引用是指指向git对象hash键值. 通过git引用, 我们可以更加方便的定位到某一个版本的提交, git分支, tags等功能都是基于git引用实现的</p>
<p>merge 和 rebase<br>Rebase会把你当前的分支的commit放到公共分支的最后面, 所以叫变基<br>Merge 会把公共分支和当前的commit合并带一起, 形成新的commit提交</p>
<p>82 动态库与静态库的区别<br>静态库是在程序编译时会被链接到目标代码中, 动态库是在程序编译是并不会被链接到目标, 只在程序启动的时候, 加载完mach-o文件后才会加载动态库<br>静态库, 以.a和.framwork为文件后缀名, 自建的.framword一般都是静态库. 自己也可以修改<br>动态库, 以.tbd和.framwork为后缀名(系统直接提供给我们的framework都是动态库)</p>
<p>App启动后, 动态链接器DYLD, 解析app需要的未定义的外部符号external symbols, 在运行时 dynamic loader也会加载哪些被请求的其他库</p>
<p>动态库分为两种<br>动态链接库:在可执行文件被夹在, 动态库也随着被加载到内存中<br>动态加载库:在需要的时候再使用dlopen等通过代码或者命令的方式来加载</p>
<p>88 LLDB 常用的调试命令<br>Po 打印对象, 会调用对象的description方法<br>Expr 可以在调试的时候动态执行指定表达式<br>P 打印对象<br>Bt 打印调用堆栈, 加all 可打印所有thread的堆栈<br>brl 是breakpoint list 的简写</p>
<p>编译原理</p>
<p>76 ios编译过程<br>OC是编译型语言, 先将代码编译成机器码, 再加以运行. 好处就是运行速度快, 缺点就是开发,调试比较长. c++, OC, swift c java<br>解释型语言开发调试比较短, 运行速度慢, 一遍由相应语言的解释器翻译成目标代码, 一边执行. Js, python, PHP</p>
<p>Ios采用三相设计.<br>clang+LLVM编译过程<br>Clang编译前端负责语法分析语义分析,生成中间代码. 编译器后端会进行机器无关的代码优化, 生成机器语言, 并进行机器相关的代码优化, 不同的cpu生成不同的机器码</p>
<p>在预编译阶段. 会做宏替换,删除注释, 头文件引入. 然后将文件转成语法树, 编译器会根据这可语法树, 做一些额外的操作以找出可能存在的错误<br>1.类型检查.即检查程序中是否有类型错误<br>2.检查变量定义了但是未使用. 就是我们看到的warning<br>3.编译, 将AST转换为更低级的中间码(LLVM IR), 对生成的中间码做优化, 生成特定目标代码, 输出汇编代码<br>4.汇编: 将汇编代码转换成目标对象文件<br>5.链接, 将多个目标对象文件合为一个可执行文件<br>6.生成可执行文件 mach-o</p>
<p>编译原理<br>1.词法分析—对字节流进行扫描和分享, 从而识别出一个个单词(token)序列的过程<br>2.语法分析—将单词序列分解成各类语法短语(语法树AST)<br>3.语义分析—审查程序有无语义错误<br>4.中间代码生成<br>5.代码优化—<br>6.目标代码生成—将中间代码变换成特定机器上的指令代码或汇编指令代码</p>
<p>66 ios在编译的时候做了那些事情</p>
<p>Oc是编译语言. 编译的时候先进行, 语法分析,, 语义分析, 然后对无关的代码优化, 生成机器码.<br>编译语言在执行的时候, 必须先通过编译器生成机器码, 机器码可以直接在cpu上运行, 所以执行效率比较高</p>
<p>词法分析是计算机将字符序列为token序列的过程</p>
<p>84 bitCode 的理解和作用<br>bitCode是LLVM编译器的中间代码的一种编码, 他可以转换为任何被支持的CPU架构, 比如打开bitCode功能提交一个app到应用商店, 以后苹果新出了一款手机并cpu也是全新设计, 一样可以编译转换为新cpu的可执行程序</p>
<p>75 app的启动<br>添加环境变量可以打印出app的启动时间分析<br>App的冷启动可以概括3大阶段<br>—dyld(dynamic link editor) apple的动态连接器, 可以用来装载mach-0文件<br>——启动app时, dyld 所做的事情有<br>———装载app的可执行文件, 同时会递归所有依赖的动态库(如何找到动态库的?)<br>———当dyld把可执行文件, 动态库都装载完毕后, 会通知runtime进行下一步的处理<br>—runtime阶段<br>——启动App, runtime所做的事情有<br>———调用map_images进行可执行文件内容的解析和处理<br>———在load_images中调用call_load_methods,调用所有class和category的+load方法(告诉研发已经加载好了)<br>———进行各种objc结构的初始化(注册objc类,初始化类对象等)<br>———调用c++静态初始化器和<strong>attribute</strong>(constrictor)修饰的函数<br>———到此为止, 可执行文件和动态库中所有的符号(Class,, protocol, selector, IMP)都已经按格式成功加载到内存中, 被runtime所管理<br>—main<br>——调用uoapplicationMain函数, AppDelegate的application:didfinishAltuchingWithOptions方法</p>
<p>优化<br>dyld<br>—减少动态库, 合并一些动态库(定期清理不必要的动态库)<br>—减少Objc类, 分类的数量, 减少selector数量(定期清理不必要的类, 分类)<br>—减少c++虚函数数量<br>—swift进来使用struct</p>
<p>runtime<br>—用+initialize方法和dispatch_once取代所有的<strong>attribute</strong>((constrictor) c++静态构造器, objc的+load)</p>
<p>main<br>—在不影响用户体验的前提下, 尽可能将一些操作延迟, 不要全部都放在finishLaunching方法中<br>—按需加载</p>
<p>72 ios程序的内存布局<br>//运行时分配<br>{<br>栈:局部变量+方法实参<br>堆:通过alloc init创建的对象<br>}<br>//编译时分配<br>{<br>BSS段: 未初始化的全局变量和静态变量<br>数据段:已初始化的全局变量, 静态变量,常量<br>代码段:被编译成二进制的代码<br>}</p>
<p>45 悬挂指针 野指针</p>
<p>悬挂指针: 指针指向的内存已经被释放了, 但指针还存在</p>
<p>野指针: 没有进行初始化的指针</p>
<p>BAD_ACCESS 访问了已经被销毁的内存空间, 就会报这个错误, 根本原因是有悬挂指针没有被释放</p>
<p>iOS基础知识</p>
<p>60 iOS 事件的传递和相应机制<br>Ios只有继承了UIResponder的对象才能接受并处理事件</p>
<p>Uibutton-&gt;uicontrol-&gt;uiview-&gt;uiresponder-&gt;NSObject</p>
<p>uiviewController-&gt;UIResponder-&gt;NSObject</p>
<p>事件的产生和传递<br>    0.    发生触摸事件后, 系统会将该事件加入到一个UIApplicaiton管理的事件队列中<br>    0.    UIApplication会从事件队列中取出最前面的事件, 并将事件分发下去进行处理, 通常先发送事件给应用程序的主窗口<br>    0.    前台App主线程RunLoop收到转发的消息, source0将封装IOHEvent为UIEvent, 然后将UIEvent传递给UIWindow<br>    0.    通过递归调用UIView层级的 hitTest:With 找到对应的view, (hitTest:wtih 底层用有pointInSide 判断是否在点击区域)<br>    0.    找到对应的会调用view 的touchsBegin:withEvent:方法来处理事件. 如果当前第一响应者没有进行出出力, 系统就将事件传递给响应者中的下一个响应者, 看看是否可以进行处理</p>
<p>控件的点击时机和添加在上面的手势谁先相应<br>    0.    如果当前是普通控件, 比如uiview 会先相应手势事件, 不过手势是需要时间的, 时间传递给了响应链的第一个响应对象, 响应链 uiresponder的touchsBegan:withEvent 方法, 之后手势识别成功, 就回去cancel之前传递到的所有响应对象, 于是就会调用他们的touchesCancelled:withEvent 方法.<br>    0.    UIGestureRecognizer 有个属性cancelsTouchesInView 这个属性默认值是yes, 即当手势识别成功后, 会发送touchesCancelled消息给view来结束view的响应. 如果cancelsTouchesInView为no, 那么gestureRecognizer和view都可以响应<br>    0.    如果控件是uibutton, uiswitch, , 未来防止事件重叠, 先响应控制事件, 并且拦截了手势事件</p>
<p>事件的传递是从上到下(父控制到子控制), 事件的相应是从下到上(顺着响应者链条向上传递, 子控件到父控件)</p>
<p>Uiview 不接受触摸事件的三种情况<br>    0.    userinterfaceEnable = NO;<br>    0.    hidden = yes<br>    0.    alpha = 0.0~0.1</p>
<p>87 ios 如何根据uiview获取所在的uiviewController<br>uiview 和UIVIewcontroller 都是直接继承自UIResponder. responder chain 大概的传递规则就是从视图顶层的uiview向下到uiviewcontroller再到rootviewContooler 再到window最后到application<br>id responder = self.nextResponder;<br>while (![responder isKindOfClass: [UIViewController class]] &amp;&amp; ![responder isKindOfClass: [UIWindow class]])<br>     {<br>        responder = [responder nextResponder];<br>    }<br>    if ([responder isKindOfClass: [UIViewController class]])<br>    {<br>        // responder就是view所在的控制器<br>        // do something<br>    }</p>
<p>64 手势的响应, 单击, 双击的判断, 底层实现<br>-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event<br>{<br>    [NSObject cancelPreviousPerformRequestsWithTarget:self];<br>    UITouch *touch = [touches anyObject];<br>    CGPoint touchPoint = [touch locationInView:self];</p>
<pre><code>if (touch.tapCount == 1) &#123;
    [self performSelector:@selector(handleSingleTap:) withObject:[NSValue valueWithCGPoint:touchPoint] afterDelay:0.3];
&#125;else if(touch.tapCount == 2)
&#123;
    [self handleDoubleTap:[NSValue valueWithCGPoint:touchPoint]];
&#125;</code></pre><p>38 iOS 深浅拷贝</p>
<p>不可变对象, copy 是指针复制, mutablecopy是内容复制<br>NSString copy之后还是同一个NSString  mutableCopy之后是NSMutableString</p>
<p>可变对象, copy是内容复制, mutableCopy 也是内容复制<br>NSMutableString copy 之后是NSString, mutableCopy之后还是NSMutableString</p>
<p>集合的单程深复制,可以用initWithArray:copyItems, 将第一个参数设置为YES即可深复制</p>
<p>如果是完全的深拷贝, 归档实现</p>
<p>NSString 为什么要用copy关键词?<br>当源字符串是不可变类型是, copy strong 都一样<br>当源字符串是可变类型, copy是深拷贝, 会生成一个新对象,  strong修饰的属性, 会随着源字符串的改变而改变. 所以一个类型有可变类型, 在声明不可变属性的时候要用copy</p>
<p>67 block和函数指针的理解<br>函数指针和block都可以实现回调的操作, 声明上也很相似, 实现上都可以看成是一个代码片段<br>不同:函数指针只能指向预先定义好的函数代码块, 函数地址是在编译链接时就已经确定好的. block本质是oc对象, NSObject 的子类, 可以接收消息</p>
<p>39 Block的几种形式</p>
<p>block本质上是一个OC对象, 它内部也有个isa指针. block是封装了函数调用以及函数调用环境的OC对象<br>Block: 带有自动变量的匿名函数. 封装了函数调用以及调用环境的OC对象</p>
<p>全局block, 存储在已初始化数据(.data)区—没有访问auto变量<br>栈block 堆区—访问了auto变量<br>堆block 栈区—NSStackBlock__ 调用copy</p>
<p>对栈block 进行copy操作, 就是堆block, 对全局block进行copy, 仍是全局block . 对堆block进行copy, 将会增加引用计数<br>(不copy会怎么样)</p>
<pre><code>0.    __block typeof(self) weakSelf = self 和 __weak typdeof(self) weakSelf = self 的区别</code></pre><p>由于 block 捕获<strong>block 修饰的变量会去持有变量, 那么如果用</strong>block修饰self, 且self持有block, 并且block内部使用到了<strong>block 修饰的self时, 就会造成多循环引用, 即self持有block, block 持有</strong>block变量, <strong>block变量持有self, 造成内存泄漏. 主动断开</strong>block的持有, 就可以解决这种循环引用. 即在block内部使用完weakself后, 将其置为nil, 但这种方式有个问题, 如果block 一直不被调用, 那么循环引用将一直存在. 好处就是在block里面self会一直存在, 所以最好还是用__weak来修饰self</p>
<p>-(void)dealloc{<br>    __weak typdeof(self) weakSelf = self;<br>    NSLog(%@,weakSelf)<br>}<br>会crash. 添加weak的时候, runtime会通过检查引用计数的个数来判断对象是否在deallocationg, 如果是会让程序crash</p>
<pre><code>0.    为什么__block修饰的变量可以在block里面访问</code></pre><p><strong>block 修饰的int, clang下文件就会发现, __block修饰的参数, 其实转换成了 __block_byref_valueInt_0 结构体 ,在构造这个结构体的时候, 里面有个参数传递的事&amp;valueint 地址 . 经过</strong>block后, 编译器会将value拷贝到了堆上. Block修改的其实是堆上的内容</p>
<pre><code>0.    为什么声明block属性要用 copy?</code></pre><p> 使用copy 是从MRC 遗留下来的传统, 在mrc中, 手动管理内存, 方法内部的block 是在栈区, 使用copy可以把它放在堆区. 堆由开发自己管理内存, 在ARC中对block 使用copy还是strong 效果是一样的, 但是建议写copy, 因为这样显示告知调用者编译器会自动进行copy操作, 将block复制到堆上 </p>
<p>20 互斥锁和自旋锁<br>自旋锁 不会引起调用者睡眠, 如果自旋锁已经被别的执行单元持有, 调用者就一直循环在那里等待是否自旋锁的保持住释放了锁.其作用是为了解决某项资源的互斥使用, 因为自旋锁不会引起调用者睡眠, 所以自旋锁的效率远高于互斥锁</p>
<p>互斥锁: 属于sleep-waiting类型的锁, 如果他要访问的的一个锁正在被别的线程只有, 那么他就会sleep, 然后等待被running</p>
<p>互斥锁适合临界区持锁时间比较长的操作, 比如临界区有IO操作, 临界区代码复杂或者循环量大, 临界区竞争非常结论, 单核处理器</p>
<p>自旋锁主要用于在临界区持锁时间非常短且CPU资源不紧张的情况下, 自旋锁一般用户多核的服务器</p>
<p>自旋锁会忙等, 就是被访问的资源被锁是, 调用者线程不会休眠, 而是不停循环在哪里, 直到被锁资源释放锁. 优点在于, 自旋锁不会引起调用者睡眠, 不会进行线程调度, cpu时间陪轮转等耗时操作. 所以如果能在短时间内获得锁, 自旋锁的效率远高于互斥锁. 缺点就是一直占用cpu. 自旋锁不能实现递归调用   例子: atomic, dispatch_semaphore_t<br>互斥锁会休眠, 所谓的休眠, 即在访问被锁资源时, 调用者线程休眠, 此时cpu可以调度其他线程工作, 直到被锁资源释放锁, 此时会唤醒休眠线程. pthread_metex, @synchronized NSLock, 适合 单核处理器, 临界区有IO操作, 执行时间比较长, 竞争比较激烈</p>
<p>OSSpinLock 自旋锁<br>os_unfaire_lock 互斥锁</p>
<p>pthread_mutex  互斥锁, 等待锁的线程会处于休眠状态/递归锁(允许同一个线程对一把锁重复加锁)<br>NSLock 对mutext的封装<br>dispatch_queue dispatch_semaphore 也可以实现锁<br>@synchronized 对mutex 互斥的封装<br>—传nil是无法启动加锁作用<br>—不会持有传入的对象, 所以在sychronized里面销毁了这个对象, 也不会有问题<br>—乡里低, 传入对象必须等待之前的锁执行完之后才能执行, 无法达到异步的效果</p>
<p>41 死锁</p>
<p>死锁的四个必要条件: 互斥, 请求保持, 不可剥夺, 环路<br>死锁的处理: 鸵鸟策略,预防策略,避免策略,检测与解除死锁</p>
<p>19.一个 NSObject 对象占用多少内存空间？</p>
<p>class_getInstanceSize([Person class]) 获取类对象实际占用的大小<br>两个原则,1.内存对齐(提高内存访问速度): 大小必须是最大成员字节的整数倍</p>
<p>malloc_size((__bridge const void*)p) 获取的是实际内存大小<br>系统实际分配内存大小是16的整数倍</p>
<p>sizeof(p) 运算符函数, 计算的事传入的p, 计算的是p指针的大小为8</p>
<p>64位的系统<br>BOOL 1个字节<br>Int float 基础类型占4个字节<br>NSSting NSInterge Block CGFloat long double 8个字节<br>CGRect 32<br>20 OC的本质<br>OC的面向对象都是基于C/C++数据格式(结构体)实现的</p>
<p>一个OC对象在内存中是如何布局的?<br>以NSObjet为例, 在内存中是一个struct, 里面有个 class ias指针</p>
<p>21 OC的类信息存放在哪里<br>对象方法, 属性, 成员变量, 协议信息,存放在class对象中<br>类方法, 存放在meta-class对象中<br>成员变量的具体值, 存放在instance对象</p>
<p>12 weak的实现原理？SideTable的结构是什么样的</p>
<p>Weak 表明该属性定义了一种”非拥有关系”, 为这种属性设置新值时, 设置方法既不保留新值, 也不释放旧值, 性质同assign类似, 然而在属性所指的对象遭到摧毁时, 属性值也会清空<br>runTime维护了一个weak_table_t结构的hash表, 用于存储指向某个对象的所有weak指针. key是对象的地址, value是 weak_entry_t 的一个动态数组, 用来存储 weak_entry_t 类型的元素. weak_entry_t的结构体也是hash结构. 存储了弱引用对象指针的指针</p>
<p>Sidetable 主要用于管理对象的引用计数和weak表<br>struct SideTable{<br>    spinlock_t slock;    //保证原子操作的自旋锁<br>    RefcountMap refcnts    //引用计数hash表<br>    weak_table_t weak_table //weak 引用全局 hash表<br>}</p>
<p>13 引用计数<br>当调用allock new copy mutableCopy方法返回了一个对象, 在不需要这个对象是, 需要调用release 或者autorelease来释放它</p>
<p>引用计数存储在isa指针里面, 如果不够存储就存在一个散列表里</p>
<p>10 load、initialize方法的区别什么？在继承关系中他们有什么区别<br>调用时机不一样, load是app一启动就会调用,  Initialize,只有在对象初始化的时候才会调用<br>Load调用时机, 先父类在子类, 主类先于类别<br>Load 函数只要你动态加载了这个类, load方法就会执行</p>
<p>在执行load方法之前, 会调用load_image方法, 用来扫描+load符号, 将需要调用load方法的类添加到一个列表中loadable_classes, 在这个列表, 会先把父类接入到待加载列表, 这样保证父类在子类前调用load方法, 而load方法会在类的load的方法后面加入另外一个待加载列表loadable_categories. 待扫描结束后, 先从loadable_classes调用类的load方法, 然后会调用loadable_categories中分类的方法<br>+(load)方法是根据方法地址直接调用, 并不是经过objc_msgSend函数调用. 而initialize是通过objc_msgSend进行调用</p>
<p>1.分类的load方法和编译有关, 先编译的先调用, 后编译的后调用<br>2.多个category方法冲突, 会找到最后一个编译的category对于的方法<br>3.类的load方法能否调用category中声明的方法? 可以的. 因为附加category到类的工作会先于load方法的执行<br>4.category的方法和类的方法冲突了. 想调用类的方法咋办, 运行时获取当前类的方法列表, 然后遍历, 获取最后一个方法</p>
<p>initalize 会强制父类先调用, 子类和父类同时实现initalize, 父类的先被调用, 然后调用子类, 如果本类和category同时实现了initialize, category会覆盖本类的方法, 只调用category的initialize 只会调用一次一次. 如果子类没实现+initalize, 会调用父类的+initialize(父类的+initalize可能会调用多次)</p>
<p>4 category的实现原理</p>
<p>Category 编译之后的底层结构是struct category_t, 里面存储这分类的对象方法,类方法,属性, 协议信息<br>在程序运行时的时候, runtime会将category的数据, 合并到类信息中(类对象, 元类对象中)</p>
<p>6 category &amp; extension区别，能给NSObject添加Extension吗，结果如何<br>Category 只能添加方法, extension可以为已知类新增方法和属性, 不能为NSObject新增extension, 因为不知道NSObject里面方法的实现<br>Extension在编译的时候, 它的数据就已经包含在类信息中<br>Category是在运行时, 才会将数据合并到类信息中</p>
<p>28 Category 在编译过后，是在什么时机与原有的类合并到一起的</p>
<p>1 程序启动后, 通过编译之后, runtime 会进行初始化, 调用 objc_init<br>2 然后会map_images<br>3 接下来调用map_images_nolock<br>4 然后就是 read_images, 这个方法会读取所有的类的相关信息<br>5 然后调用reMethodizeClass: 这个方法是重新方法化的意思<br>6 在reMethodizeClass, 方法内部会调用attachCategories, 这个方法会传入class和Category, 会将方法列表, 协议列表等与原有的的类合并, 最后加入到class_rw_t结构体中</p>
<p>29 Category 有哪些用途？  Category 的实现原理？</p>
<p>将方法分类, 添加属性和协议<br>比如添加方法, 声明方法和实现, 然后在runtime的时候将声明的方法, 协议, 和主类的方法进行合并, 放在class_rw_t</p>
<p>类别如果设计的不好的话容易出现方法冲突, 至于先调用哪个和编译顺序有关</p>
<p>13 关联对象的应用？系统如何实现关联对象的在category里面添加假属性<br>objc_setAssociatedObject(self,”name”,OBJC_ASSOCIATION_COPY);<br>objc_getAssociatedObject(self,”name”);</p>
<p>associationManager 维护了一个hash表, key是对象地址, value是一张hash表, hash表里又是关联对象的key和ObjcAssocation的映射, objcAssocation是一个C++的类, 表示一个具体的关联对象, 包括两个实例变量, _policy表示关联策略, _value标识关联对象</p>
<p>14 关联对象的如何进行内存管理的？关联对象如何实现weak属性<br>内存管理是通过赋值的时候设置一个policy, 根据这个policy的类型来对设置的对象进行retain/copy操作, 当poliy是asign的时候, 设置的关联值是以weak的方式进行内存管理</p>
<p>19 属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗<br>Atomic,确保属性的赋值的原子性, 只保证的getter 和setter存取的线程安全, 并不能保证整个对象的线程安全, 为了保证线程安全可以考虑加锁, 比如最简单的@synchronized NSLock  pthread_mutex (互斥锁) OSSpinLock (自旋锁, 但是ios因为优先级反转的问题, 已经不安全了)</p>
<p>多个线程, 线程A写,线程B写, 线程A读. 这个时候读到的事线层B写的</p>
<p>62 OC和c交换对象内存权限<br>__bridge 只做类型转换, 但是不修改对象的内存管理权<br>__bridge_retained 将OC对象转换成CF对象, 同事将对象内存的管理权交给开发, 后续使用CFRelease来释放对象<br>__bridge_transfer 将CF对象转换成OC对象, 同时将对象内存的管理权交给ARC</p>
<p>59 const extern static</p>
<p>Const 与 宏的区别</p>
<p>宏是预编译, const 是编译阶段<br>宏不做检查, 不会报编译错误, 只是替换,  const会编译检查, 会报编译错误<br>宏能定义一些函数,方法,  const不能<br>使用大量的宏, 容易造成编译时间久, 每次都需要重新替换</p>
<p>Static:<br>用static修饰的变量, 在其所限定的作用域中只会有一份内存.<br>如果在一个函数内部, 说明是一个静态局部变量, 不管这个函数调用多少次, static修饰的变量只会有一份内存<br>如果在一个文件内部, 是一个静态全局变量, 该文件中的函数都可以访问, 并且不同函数在对改变量修改是都是在上一次函数修改的基础上修改的</p>
<p>extern 外部变量<br>用extern修饰的变量, 可以被其他类所访问, 凡是引用了extern所修饰的变量的头文件, 那么就可以使用该变量</p>
<p>Const 一个变量如果用const修饰, 说明该变量不可以被修改</p>
<p>混搭<br>static 和 const 混用 定义一个宏  static NSString *const identifier = @“hello“</p>
<p>extern 和 const混用 .h文件中 extern NSString *const hello.在.m文件中赋值 NSString *const hello = @“hello”; 用来多个文件使用同一个变量</p>
<p>int  const  *p   //  *p只读 ;p变量</p>
<p>int  * const  p  // *p变量 ; p只读</p>
<p>const  int   * const p //p和*p都只读</p>
<p>int  const  * const  p   //p和*p都只读</p>
<p>58 tagged Pointer</p>
<p>为了节省内存和提高执行效率, 苹果首次在64位处理器上面提出了tagged pointer的概念. 对于64位程序, 引入tagged pointer后, 相关逻辑减少一半的内存占用, 以及3倍的访问速度提升, 100倍的创建,销毁速度提升</p>
<p>tagged pointer的特点<br>    0.    专门用来存储小的对象, 比如 NSNumber, NSDate, 个别NSSTring<br>    0.    taggedPointer 指针的值不在是地址了, 而是真正的值<br>    0.    在内存的读取上有着3倍的效率, 创建时比以前快了100倍</p>
<p>NSString 是个类簇<br>_NSCFConstantString 常量字符串<br>NSTaggedPointerString<br>_NSCFString  对象类型的字符串</p>
<p>1 dynamic 告诉系统不用自动生成set get方法</p>
<p>54 pod install 和 pod update </p>
<p>CocoaPods原理是将所有的依赖库都放在另一个名为Pods的项目中, 然后让主项目依赖Pods项目</p>
<p>Pod install 是第一次在工程里使用pods的时候使用, 并且每次编辑podfile (添加, 移除, 更新)的时候使用. 每次运行pod isntall的时候, 在下载, 安装新的库的同时, 也会把你安装的每个库的版本都写在Podfile.lock文件里面. 这个文件记录你每个安装库的版本号, 并且锁定了这些版本</p>
<p>当使用podinstall它只解决了pods里面, 但不在Podfile.lock文件里面的那些库直接的依赖. 对于在Podfile.lock里面所列出的那些库, 会下载在Podfile.lock里面明确的版本, 并不会去检查是否该库有最新的版本</p>
<p>Pod update. 会帮你更新这个库的新版本, 而不需要考虑Podfile.lock里面的限制. 他会更新到这个库尽可能的新版本, 只要符合Podfile里面的版本限制</p>
<p>90 iOS包签名<br>1.从keychain里的从”从证书颁发机构请求证书”, 这里就本地生成了一对公私钥, 保存的certificateSigningRequest 就是公钥, 私钥保存在本地电脑里<br>2.把对应的certificateSigningRequest 传到苹果后台生成证书(用苹果后台的私钥去签名), 并下载到本地. 这时候本地有两个证书, 一个是第一步生成的, 一个是从这里下载的. keychain会把这两个证书关联起来.<br>3.在苹果后台配置AppID/权限/设备等, 最后下载Provisioning profile文件<br>4.Xcode会通过第三步下载回来的证书(存着公钥), 在本地找到对应的私钥, 用本地私钥去签名app, 并将Provisioning profile文件命名为embedded.mobileprovision 一起打包进去.<br>5.安装时, iOS系统取得证书, 通过系统内置的公钥, 验证embedded.mobileprovision, 验证成功后, 取出里面的数据, 做各种验证, 比如公钥L验证app签名, 验证设备ID是否在列表上, 权限是否一样</p>
<p>certificateSigningRequest 本地公钥<br>P12 本地私钥<br>provisioning profile:包含了证书/entitlements等数据, 并由苹果后台私钥签名的数据包</p>
<p>89 为什么不能再子线程刷新ui<br>Uikit 并不是线程安全的类, 如果异步操作会存在读写的问题, 如果加锁的话会消耗大量的资源并拖慢运行速度</p>
<p>如何避免在子线程刷新ui<br>runtime swizzling 解决, 刷新ui的时候, 一定会调用uilayer和uiview的 setNeedsDisplay, SetNeedsLayout, SetNeedsDisplayInRect , 确保这几个方法在main thread中执行就行了</p>
<p>87 沙盒目录结构是怎样的<br>application:存放程序源文件<br>Document:常用目录, iCloud备份目录, 存放数据<br>library<br>—caches:存放体积大又不需要备份的数据<br>—preference: 设置目录, iCloud 会备份设置信息<br>tmp: 存放历史文件</p>
<p>85 APM application performance management ,应用性能管理, 通过对应用的可靠性, 稳定性等方面的监控, 进而达到快速修复问题, 提供用户体验的目的</p>
<p>83 coreAnimation 和 coreGraphics 的区别<br>coreGraphics是核心图形库, 包含Quartz2D绘图API接口<br>CoreAnimation是核心动画库, 用来做iOS相关动画</p>
<p>CoreAnimation 是依赖于openGL ES做GPU渲染, coreGraphincs做cpu渲染</p>
<p>做动画的时候获取frame<br>每个CALayer有个presentationLayer属性, 当CAAniamtion做动画的时候, 其实是看到的事presentationLayer, 开启一个计时器去获取presentationLayer的frame</p>
<p>82 drawRect调用情况</p>
<p>-如果UIView 没有设置frame大小, drawRect不会被自动调用<br>-drawRect在loadview 和viewDidLoad这两个方法之后调用<br>-调用sizeToFit后自动调用drawRect<br>-调用setNeedsDisplay或者setNeedsDisplayinRect会触发调用<br>-设置contentmode属性值为UIViewContentModeRedraw. 每次设置/更改frame的时候自动调用drawRect</p>
<p>81 drawrect空实现 是否会有影响<br>重写drawRect 会导致内存大量上涨. 画板视图的 -drawRect: 方法背后实际上都是底层的 CALayer 进行了重绘和保存中间产生的图片. 每次重绘的时候都需要重新抹掉内存然后重新分配. 空寄宿图的产生消耗了大量内存, 这就是drawRect内存暴增的原因</p>
<p>解决方案<br>使用专有图层 CAShapeLayer. 他是一个通过矢量图形而不是bitmap来绘制图层子类. 用CGPath 来定义要绘制的图形, CAShapeLayer会自动渲染. 它可以完美替代我们之间使用CoreGraphics绘制layer<br>优点<br>    0.    渲染快速<br>    0.    高效使用内存, 不会像普通CALayer一样创建一个寄宿图形<br>    0.    不会被图层编辑剪裁掉<br>    0.    不会出现像素化</p>
<p>63 setNeedsLayout与layoutIfNeeded   和 setNeedsDisplay<br>layoutIfNeeded 方法被调用, 主线程会立即强制重新布局, 他会从当前视图开始, 一直到完成所有字数图的布局.</p>
<p>layoutSubviews 用来自定义视图尺寸, 他是系统调用的, 开发者不能手动调用(手动调用怎么样), 可以重写该方法, 让系统在调整布局时候按照我们希望的方式进行布局. 选择屏幕,滑动/触摸屏幕修改子视图的时候被处罚<br>—addsubview会触发<br>—修改view的frame会触发layoutSubviews<br>—滚动uiscrollview<br>—旋转screen会触发父uiview的layoutSubviews<br>—直接调用setlayouSubviews</p>
<p>setNeedsLayout 触发布局, 他不回立即强制视图重新布局, 而是在下一个布局周期才会被触发. 异步执行..  默认调用layoutSubviews</p>
<p>setNeedsDisplay 标记为需要重绘. 会自动异步调用drawRect 方法, 然后拿到currentContext 就可以画画了<br>-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘</p>
<p>35 利用RunLoop 解释下页面的渲染过程</p>
<p>当我们调用 [uiview setNeedsDisplay] 时, 这时会调用当前的 view.layer 和 [view.layer setNeedsDisplay] 方法. 这等于给当前的 layer 打上一个脏标记, 而此时并没有直接绘制工作, 而是会到当前的 RunLoop 即将休眠, 也就是 beforeWaiting 时才会进行绘制工作.<br>紧接着会调用 [CALayer display], 进入真正绘制的工作. CALayer 层会判断自己的 delegate 有没有实现异步绘制的代理工作 displayer: 这个代理方法是异步绘制的入口. 如果没有实现这个方法, 那么会继续进行系统绘制的流程, 然后绘制结束<br>CALayer 内部会创建一个 Backing Store 用来获取图形上下文, 接下来会判断这个 layer 是否有 delegate. 如果有的话,会调用 [layer.delegate drwaLayer:inContext:] 并且会返回给我们 [UIView DrawRect] 的回调, 让我们在系统绘制的基础上在做一些事情<br>如果没有 delegate,那么会调用 [CALayer drawInContext]<br>以上两个分支, 最终 CALyaer 都会将位图提交到 Backing Store, 最后提交给 GPU, 至此绘制的过程结束</p>
<p>80  OOM机制和监控方式<br>由于iOS的Jetsam 机制造成的另一种另类crash, 他不同于常规的crash, 通过singal 捕获等crash监控方案无法不会oom事件<br>原因<br>1.系统内存使用较高, 系统基于优先级杀死优先级较低的app<br>2.当前使用的App达到了””high water mark, 也就是达到了对单个app的内存限制, 系统会kill你</p>
<p>常见的导致问题<br>    0.    uigraphicsEndImageContext — UIGraphicsBeginImageContext和UIGraphicsEndImageContext必须成双出现，不然会造成context泄漏<br>    0.    uiwebview<br>    0.    autoreleasePool<br>    0.    相互引用<br>    0.    大图片处理, 处理大分辨图片时, 往往容易oom, 因为解码的时候, 生成原始分辨率大小的bitmap, 这很消耗性能<br>    0.    uiview太大时</p>
<p>74 图片解码<br>加载完图片之后, 不能直接展示到屏幕上, 加载完之后需要先进行解码, 解码是在主线程进行的, 如果图片比较多也会导致卡顿<br>解决方案:<br>1.拿到图片后获取CGImage<br>2.将CGImage解码, 创建图形上下文, 然后将图片画在图形上下文, 这样就完成了解码操作, 然后在从上下文获取图片, 这个图片是解码过的, 然后将这个图片包装成uiimage</p>
<p>74 渲染过程<br>Cpu一般用户显示内容的计算， 而GPU的并行计算能力更强， 能够通过计算将图形结果显示在屏幕像素中<br>在渲染过程中， CPU专门用来处理渲染内容的计算， 比如视图创建，布局，图片解码等，内容计算完成后，在传输给GPU进行渲染<br>原生渲染的过程：1.CPU计算要显示的内容，包括视图创建，计算布局，视图布局。 当Runloop在BeforWaiting和Exit时，会通知注册的监听， 然后对图层打包，打包后将打包数据发送给一个独立负责渲染的进程Render Server。2.数据达到Render Server后会被反序列化，得到图层树，然后再次过滤之后得到渲染树，渲染树的信息会转给OpenGL/Metal， 3.Render Server会调用GPU，<br>总结一句话，CPU处理完渲染内容会输入到Render Server中， 经图层树和渲染树的转换，通过OpenGL接口提供给GPU，GPU处理完后在屏幕上显示</p>
<p>73 屏幕成像</p>
<p>Cpu——计算——&gt;GPU—渲染—&gt;帧缓存———读取——&gt;视频缓存器——显示——&gt;屏幕</p>
<p>卡顿产生的原因, vsync(垂直信号)来的时候, 页面没渲染完, 就会等待下一次的再来的时候渲染<br>—cpu—&gt;—GPU—&gt;(VSync)—</p>
<p>卡顿优化—CPU<br>1.尽量用轻量级的对象, 比如用不到事件点击处理的地方, 可以考虑使用CALayer取代uiview<br>2.不要频繁调用uiview的相关属性, 比如 frame bounds<br>3.尽量提前计算好布局, 在需要时一次性调整对应的属性<br>4.autolayout会比直接设置frame消耗更多的cpu资源<br>5.图片的size最好刚好跟uiimageView的size保持一致<br>6.控制一下线程的最大并发数量<br>7.尽量将耗时的操作放在子线程<br>—文字处理(尺寸计算, 绘制)<br>—图片处理(解码,绘制)</p>
<p>卡顿优化—GPU<br>1.降级避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示<br>2.GPU能处理的最大纹理尺寸是4096*4096, 一旦超过这个尺寸, 就会占用cpu资源进行处理<br>3.尽量减少视图数量和层次<br>4.减少透明的视图<br>5.尽量避免出现离屏渲染</p>
<p>耗电优化<br>1.尽可能降低CPU,GPU功耗<br>2.少用定时器<br>3.优化IO操作<br>—尽量不要频繁写入小数据, 最好批量一次性写入<br>—读写大量重要数据时, 考虑用dispatch_io 其提供了基于GCD异步操作文件IO的api, 用dispatch_io系统会优化磁盘<br>—数据量比较大的, 建议使用数据库<br>4.网络优化<br>—减少,压缩网络数据<br>—如果多次请求的结果相同, 尽量使用缓存<br>—断点续传<br>—网络不可用, 不要尝试执行网络请求<br>—网络操作设置超时时间<br>5.定位优化</p>
<p>74 离屏渲染<br>在openGL中, GPU有两种渲染方式<br>——当前屏幕渲染, 在当前用于显示的屏幕缓冲区进行渲染操作<br>——离屏渲染, 在当前屏幕缓冲区外开辟一个缓冲区进行渲染操作(当使用圆角, 阴影,遮罩的时候, 图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制, 所以就需要离屏渲染)</p>
<p>离屏渲染消耗的原因<br>—需要创建新的缓冲区<br>—离屏渲染的整个过程, 需要多多次切换上下文环境, 先从当前屏幕切换到丽萍,<br>哪些操作会触发离屏渲染<br>—光栅化<br>—遮罩<br>—maskstoBounds +cornerRaudius,解决方案:通过coreGraphics 绘制剪裁圆角或者uibezierpath+CAShapeLayer来做<br>—阴影<br>——如果设置了layer.shaowpath 就不会产生离屏渲染</p>
<p>49 离屏渲染</p>
<p>离屏渲染的代价很高, 想要进行离屏渲染, 首先要创建一个新的缓冲区, 屏幕渲染会有一个上下文环境的概念, 离屏渲染的整个过程需要切换上下文环境, 从当前屏幕切换到离屏, 等结束后, 又要讲上下文环境切换回来</p>
<p>离屏渲染触发的场景<br>    0.    圆角<br>    0.    图层蒙版<br>    0.    阴影<br>    0.    光栅化</p>
<p>50 如何提高 tableview 的流畅度</p>
<p>优化cpu<br>    0.    尽量用轻量级的对象, 比如用不到点击时机的地方可以考虑用calayr取代uiview<br>    0.    不要频繁的调用uiview的相关属性, 比如frame, bounds,transform等属性, 尽量减少不必要的修改<br>    0.    尽量提前计算好布局, 在有需要时, 一次性调整对应的属性, 不要多次修改属性<br>    0.    autolayout 会比直接设置 frame 消耗更多的cpu资源<br>    0.    图片的size最好刚好跟uiimageview的size保持一致<br>    0.    控制一下线程的最大并发数量<br>    0.    尽量把耗时的操作放在子线程<br>    0.    文本的处理 尺寸计算, 绘制<br>    0.    图片处理, 解码, 绘制</p>
<p>优化GPU<br>    0.    避免出现离屏渲染<br>    0.    尽量减少视图数量和图层<br>    0.    尽量避免短时间内大量图片的显示, 尽可能将多张图片合成一张进行显示</p>
<p>65 实现监听卡顿<br>添加Observer到主线程RunLoop中, 通过监听RunLoop状态切换的耗时, 以达到监控卡顿的时间<br>—结束休眠到处理source0,这段时间<br>—监听beforeSource和afterWaiting, 也就是source0回调和接受mach_port 消息两个状态. 一旦发现进入睡眠前的KCFRunloopBeforeSource状态, 或者唤醒后的状态 KCFRunloopAfterWaiting, 在设置的时间阈值内一直没有变化, 即可判定为卡顿<br>—dump 出堆栈的信息, 从而进一步分析出具体哪个方法执行时间过长</p>
<p>62 CALayer 的一些具体属性, 介绍下各个layer<br>contents  id类型, 可以是任何类型的对象, 但是一般都是复制CGimage<br>mask  遮罩, 让父图层部分区域可见</p>
<p>一个渐变色, 如果不创建新的layer, 如果写一个<br>view.layer.mask = CAGradientLayer</p>
<p>CAShapeLayer: 指定CGpath和贝塞尔曲线, 可以画出各种图形<br>CAGradientLayer: 渐变色<br>CATiledLayer:大图绘制</p>
<p>隐式动画: CoreAnimation 在每个runloop周期中自动开始一次新的食物. 任何在一次runloop循环中属性的改变都会被集中起来, 然后做一次0.25s动画<br>关闭<br>    [CATransaction begin];<br>    [CATransaction setDisableActions:YES];<br>    XXX<br>    [CATransaction commit];</p>
<p>76 安装包瘦身<br>资源<br>—采取无损压缩<br>—去除没有用到的资源</p>
<p>可执行文件瘦身<br>—去掉异常支持</p>
<p>检测未使用的代码<br>检测重复代码, 未被调用的代码</p>
<p>55 NSTimer 循环引用</p>
<p>RunLoop强引用了Timer, timer强引用了VC, 所以无法释放<br>为什么用weakSelf也不行? 因为timer传进入的对象, 会重新strong一下</p>
<p>71 CADisplayLink 和 NSTImer 注意点<br>这里俩都会对target产生强引用, 如果target又对他们强引用, 就会引发循环引用<br>使用NSProxy弱引用解决<br>NSPorxy本身是一个抽象类, 他遵守NSObject协议, 提供了消息转发的通用接口<br>VC强引用了Timer, Timer强引用了porxy, 但是porxy弱引用了VC</p>
<p>NSProxy 一个抽象的超类, 通常发给proxy的消息会被转发给实际对象</p>
<p>47 访问 __weak 修饰的变量是否已经被注册在了 @autoreleasePool中<br>__weak修饰的变量属于弱引用, 如果没有被注册到 @autoreleasePool中, 创建之后也就会随之销毁, 为了延长它的生命周期, 必须注册到 @autoreleasePool 中, 亿延缓释放</p>
<p>_unsage_unretained, 和 weak一样, 表示的事对象的一种弱引用关系, 唯一的区别是, __weak 修饰的对象别释放后, 指向对象的指针会置空, 也就是指向nil, 不会产生野指针. 而_unsafe_unretained修饰的对象被释放后, 指针不会置空, 而是变成野指针, 那么此时如果访问这个对象的话, 程序就会crash, 抛出BAD_ACCESS的异常</p>
<p>ARC</p>
<p>16 ARC的实现原理？ARC下对retainrelease做了哪些优化<br>ARC 是LLVM编译器你和runtime系统相互协作的一个结果<br>RAC所做的无非就是在合适的时机帮我们添加retain, release 或者autoRelease, 无需程序员手动写这些代码, 本质上和MRC一样, 但是比MRC手动写更高效, 因为ARC是直接调用C语言的方法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wangyanchang21/article/details/79461511">https://blog.csdn.net/wangyanchang21/article/details/79461511</a></p>
<p>Copy 或者strong 会增加引用计数吗?  Strong 会, copy. 分情况, 可变对象, 还是不可变对象</p>
<p>以alloc,copy, mutableCopy new这些方法会被标记位 __attribute(ns_returns_retained). 以这些方法创建的对象, 编译器会在调用方法外网要加上内存管理代码 retain/release, 所以会在作用域结束的时候就会释放. 而不以这些关键字开头的方法, 会被标记为 __attribute(ns_returns_not_retained). 编译器会在方法内部自动加上 autorelease方法, 这些方法会被注册到自动释放池, 同时其释放会延迟, 等到自动释放池销毁的时候才释放</p>
<p>MRC中对一个对象执行autorelease 会发生什么, 引用计数1. ARC中用 autoreleasing 修饰 引用计数为2. 因为他转换成了  id o = [obj retain] autorelease];<br>-(id)autorelease{<br>[NSAutoreleasePool addobject:self]<br>}</p>
<p>15 Autoreleasepool的原理？所使用的的数据结构是什么<br>struct __AtAutoreleasePool{<br>    void  *atAutoreleaseobj = objc_autoreleasePoolPush();<br>    objc_autoRealeasePoolpop(autoreleasepoolobj);<br>}<br>objc_autoreleasePoolPush ==&gt; autoreleasePoolPage:push<br>objc_autpreleasePoolPop  ===&gt;autoreleasePoolPage::pop(ctxt)</p>
<p>autoreleasePoolPage 是一个双向链表<br>class autorealsePoolPage{<br>    magic_t const magic<br>    id *next<br>    pthread_t const thread<br>    AutorealesePoolPage * parent<br>    AutorealeasePoolPage *child<br>    depth<br>    hiwat<br>}</p>
<p>哨兵对象 POOL_SENTINEL, 就是nil, 释放的时候一直释放到哨兵对象为止</p>
<p>16 什么对象会放到autoreleasepool里面什么对象不都会<br>__autoreleasing声明的对象都会放到pool里<br>—静态变量不会放到autoreleasepool<br>—objc_autoreleaseReturnValus()后面跟着objc_retainautoreleaseReturnValue()不会放到autoreleasePool, 比如 NSMutableArray的array方法</p>
<p>17 ARC下哪些情况会造成内存泄漏<br>Block  两个对象循环引用,  错误的delegate属性, nstimer</p>
<p>MRC下重写set方法</p>
<p>(Void)setA:(int)A{<br>    if (_A != A){<br>        _A release;<br>        _A = [A retain]<br>}<br>}</p>
<p>(Void)setA:(int)A{<br>[A retain]<br>_A relase<br>_A = A<br>}</p>
<p>44 MRC 下重写Set 和get</p>
<p>-(Void)SetA:(NSString *)brand{<br>    if (_brand != brand){<br>    _brand release;<br>    _breand = [brand retain]<br>}}</p>
<p>-(NSString *)getBrand{<br>    return [_brand retain] autorelease]<br>}</p>
<p>-(void)dealloc{<br>    _string release];<br>    super dealloc]<br>}</p>
<p>runtime</p>
<p>1 什么是Runtime<br>OC是一门动态性的编程语言, 允许很多操作推迟到程序运行时在进行. OC的动态性就是由Runtime来支撑和实现的, Runtime是一套C语言的API, 封装了很多动态性相关的函数. 平时编写的OC代码, 底层都是转换成了Runtime API进行调用</p>
<p>具体应用<br>    0.    关联对象给分类添加属性<br>    0.    遍历类的所有成员变量<br>    0.    交换方法实现<br>    0.    利用消息转发机制解决方法找不到的异常</p>
<p>1.介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）<br>Struct objc_class{<br>    class isa<br>    class superClass<br>    cache_t cache //方法缓存<br>    class_data_bits_t bits //用于获取具体的类的信息<br>}</p>
<p>Struct class_rw_t{<br>    uint32_t flags;<br>    unit32_t version;<br>    const class_ro_t *ro<br>    method_list_t *methods; //方法列表<br>    property_list_t *perperties //属性列表<br>    const protocol_list_t *protocols //协议列表<br>}</p>
<p>Struct class_ro_t {<br>    unit32_t instanceSize; // instance 对象占用的内存空间<br>    const char *name<br>    method_list_t *baseMethodlist<br>    protocol_list_t *baseProtocols<br>    const ivar_list_t *ivars // 成员变量列表<br>}</p>
<p>2.isa详解</p>
<p>在arm64架构之前, isa就是一个普通的指针, 存储这calss, meta-class对象的内存地址<br>从arm64架构开始, 对isa进行了优化, 变成了一个共用体(union)结构, 还是用位域来存储更多的信息</p>
<p>20.对象的isa指针指向哪里</p>
<p>instance对象的isa指针指向class对象,<br>class对象的isa指针指向meta-class对象,<br>meta-class对象的isa指针指向基类的meta-class对象,<br>基类自己的isa指针也指向自己</p>
<p>runtime面试题</p>
<p>[self class]   //当前类<br>[super class] //当前类  </p>
<p>—objc_msgsendSuper((_rw_objc_super){(id)self, (id)class_getSuperClass(objc_getClass(“当前类”))}, @selector(“class”)), 里面的receiver 依然是self, 后面的class, 决定方法从哪里开始找<br>—从当前类的父类开始寻找class方法, 最后找到了NSObject</p>
<p> [self superclass]  //父类<br>[super superclass] //父类</p>
<p>[super message]的底层实现<br>    0.    消息接受者仍然是子类对象<br>    0.    从父类开始查找方法的实现</p>
<p>-(class) class{<br>    return object_getClass(self);<br>}</p>
<p>-(class)superClass{<br>    return class_getSuperclass(object_getClass(self))<br>}</p>
<p>面试题1<br>    BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];  1<br>    BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; 0<br>    BOOL res3 = [(id)[Person class] isKindOfClass:[Person class]]; 0<br>    BOOL res4 = [(id)[Person class] isMemberOfClass:[Person class]] ; 0<br>    BOOL res5 = [(id)[Person class] isKindOfClass:[NSObject class]]; 1<br>    BOOL res6 = [(id)[Person class] isMemberOfClass:[NSObject class]]; 0</p>
<p>-(BOOL)isMemberOfCLass:(class )cls{<br>return object_getClass(self) == cls<br>}</p>
<p>-(BOOL)isKindOfClass:(class)cls{<br>    for(class cls == object_GetClass(self);tcls = tcls-&gt;SuperClass){<br>        if tcls == cls return yes<br>    }<br>}</p>
<p>面试题2<br>@interface MDPerson: NSObjct<br>@property (nonatomic, copy) NSString *name<br>-(void)print<br>@end</p>
<p>@implementation MJPerson<br>-( void)print{<br>NSLog(@“my name %@”,self.name)<br>}</p>
<p>id cls = [MJPerson class]<br>Void *obj = &amp;cls<br>((__bridge id)objc print)<br>打印输出— my name [uiviewcontroller ]</p>
<p>为什么可以输出?<br>通过objc 找到对应内存, 然后取出前8个字节, 这前八个字节刚好是isa指针, 通过isa可以找到类</p>
<p>为什么输出 uiviewcontroller [super viewdidLoad] 导致的<br>内存布局, 从高到低</p>
<p>21 iOS 中内省的几个方法有哪些？内部实现原理是什么isKindOfClass:<br>isMemberOfClass:<br>respondToSelector:<br>conformToProtocol:      会查父类<br>class_conformToProtocl 只查当前类</p>
<p>23 class、object_getclass ,objc_getClass方法有什么区别?当参数为实例对象的时候, class 和 object_getclass 返回的都是当前的类<br>如果参数是类, class返回的是当前类,  object_getclass获取的是元类</p>
<p>objc_getClass 根据字符串获取类</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d4d8a79fd97">https://www.jianshu.com/p/0d4d8a79fd97</a></p>
<p>2.为什么要设计metaClass<br>功能分离, 各司其职, 符合单一职责设计原则, metaClass是关于类的类, 类方法会存在metaClass里面</p>
<p>3 class_copyIvarList 和 class_copyPropertyList的区别<br>class_copyIvarList 会获取所有属性和成员变量, 属性会有个_<br>class_copyPropertyList 会获取所有的属性</p>
<p>4 子类如何获取父类的属性<br>通过class_copyPropertyList 获取的只有子类的属性, 如果想获取父类的属性就需要调用 [self superclass], 同理, method_list 和 iva_list都是一样的, 只能包含当前类的, 不包含父类的</p>
<p>4 class_rw_t 和 class_ro_t的区别<br>class_rw_t结构体包含class_ro_t, class_ro_t主要是类无法修改, 已经确定的东西,  class_rw_t是可以扩充的, 在runtime新增的东西都放在了class_rw_t里面</p>
<p>14 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？<br>不需要, 因为被关联的对象在生命周期内要比对象本身释放的晚, 他们会在NSObject - dealloc调用objct_dispose()方法中释放<br>对象的内存销毁时间表, 分为四个步骤<br>    1 调用 -release 引用计数变为0<br>    2 父类调用 -dealloc<br>    3 NSObject 调用dealloc, 在这里只做了一件事情,  调用object_dispose()方法<br>    4 调用 object_dispose<br>        1 解除所有使用Runtime Associate方法管理的对象<br>        2 解除所有 _weak引用</p>
<p>24 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？<br>不可以向编译后得到的类添加实例变量, 因为编译后的类已经注册在runtime中, 类结构体重的objc_ivar_list实例变量的链表和instance_size实例变量的内存大小已经确定<br>运行时创建的类是可以添加实例变量, 调用class_addIvar函数. 但是得在调用objc_allocateClassPaird之后, objc_registerClassPair之前</p>
<p>25 runtime如何通过selector找到对应的IMP地址？</p>
<p>先介绍下struct method_t{SEL, IMP, chat } SEL 和 IMP是一一对应的<br>在寻找IMP地址时, runtime提供了两种方法A IMP class_getMethodImplementation(Class cls, SEL name)  B IMP method_getImplementation(Method m), </p>
<p>对于方法A, 类方法和实例方法实际上都是通过调用class_getMethodImplementation来寻找IMP地址, 不同之处是传入的第一个参数不同, 类方法传的是 objc_getMetalClass(“A”), 实例方法 [A class], 通过传入不同的参数, 找到不同的方法列表, </p>
<p>对于方法B, 类方法  Method class_getClassMethod(class cls, SEL name)  实例方法 Method class_getInstanceMethod(Class cls, SEL name), 最后调用 IMP method_getImplementation(Method m)获取IMP地址</p>
<p>8在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么<br>1 先看当前方法是不是可以被忽略 2.查看self是不是nil 3. 查找cache 4.从当前类查找methodList, 然后再去父类, 已知找到NSobejct , 如果还没找到开始动态方法解析和重定向,转发</p>
<p>9 IMP、SEL、Method的区别和使用场景<br>Method是一个method_t的结构体, 里面有IMP函数指针, 指向具体的方法实现, SEL是方法名类型<br>使用场景: 实现类的swizzle的时候会用到, 通过class_getInstanceMethod(Class, SEL), 获取类的方法Method, class_addMethod(Class, SEL,IMP)</p>
<p>11 说说消息转发机制的优劣<br>可以预防crash, 实现多继承</p>
<p>22 什么是method swizzling（俗称黑魔法), 为什么可以做到<br>先说下 Method的结构<br>Struct Method{<br>    imp  指向具体的实现<br>    SEL  方法名<br>    char *types<br>}</p>
<p>23 什么时候会报unrecognized selector的异常<br>说下方向寻找的过程,<br>objc_class:objc_object{<br>    cache<br>}</p>
<p>先去cache中寻找, 如果cache没有找到, 就是methodlist中寻找, 先子类在父类, 一直找到NSObject, 如果还没有找到, 就进入消息转发, 这里给了三步</p>
<p>27 objc在向一个对象发送消息时，发生了什么？<br>objc_sendMsg(self,SEL,…);<br>先去判断self是不是nil, 如果是nil, 直接return, 否则进入下一步<br>查找sel, 先去cache中查, 如果没有就去methodList查, 先子类在父类, 最后调用到了Nsobject, 如果还没有就进入动态方法解析和消息转发阶段</p>
<p>//第一步,动态方法解析 给个机会让类添加这个实现的函数—这个方法需要在类的本身上动态添加它本身不存在的方法, 这些方法对于该类来说是冗余的</p>
<ul>
<li>(BOOL)resolveInstanceMethod:(SEL)aSEL{<br>  if (aSEL == @selector(foo:)){<pre><code>class_addMethod([self class], aSEL, (IMP)fooMethod,”V@:”)</code></pre>Return YES<br>}<br>  return [super resolveInstanceMethod]<br>}</li>
</ul>
<p>// 第二步消息转发 让别的对象去执行这个函数——将这个消息转发给一个对象, 开销较小, 并且被重写的概率较低, 适合重写<br>-(id)forwardingTargetForSelector:(SEL)aSelector{<br>    if (aSelector == @selector(foo:)){<br>        return [BackupClass alloc]ini];<br>}<br>Return [super forwardingTragetForSelector:aSelector]<br>}</p>
<p>返回self会咋么样 会继续执行, 先执行methodSignatureForSelector, 在走回resolveInstanceMethod, 在直接执行到forwardInvocation</p>
<p>//第三步 —通过NSInvocation的形式将消息转发给多个对象, 但是其开销较大, 需要创建新的NSInvocation对象, 并且forwardInvocation的函数经常被使用者调用, 来做多层消息转发机制, 不适合多次重写<br>里面的invocation 是从methodsignatureForSelector 获取, 如果返回nil转发流程终止, 抛出无法处理的异常<br>-(void)forwardInvocation:(NSInvocation *)invocation{<br>    SEL sel = invocation.selector<br>    if (newObject invokeWithTarge:sel){<br>        [invocation invokeWithTarget:alternateObjct]<br>}else{<br>    [self doesNotRecognizeSelector:sel];<br>}<br>}</p>
<p>//通过类型编码获取方法签名  如果返回nil直接crash, 如果调用super 方法会走到resolveInstanceMethod 然后crash<br>-(NSMethodSingature *)methodSignatureForSelector:(SEL)aSelector{<br>    NSMethodSignature *methodSignature = [super methodsingatureForSelector:aSelector];<br>    if (!methodSignautre){<br>        methodsignature = [NSMethodSignature signatureWithObjcTypes:””V@:X]<br>}<br>    return methodsignaure</p>
<p>}</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae96e8c6fb9a07ac85a3860">https://juejin.im/post/5ae96e8c6fb9a07ac85a3860</a></p>
<p>26 objc中向一个nil对象发送消息将会发生什么？</p>
<p>不会有任何错误, 也不会崩溃</p>
<p>如果这个方法返回值是一个对象, 那么发送给nil的消息将返回null<br>如果返回值是float, doubel, 返回0<br>如果方法返回值是结构体, 返回的结构体的值都是0</p>
<p>30 _objc_msgForward函数是做什么的</p>
<p>objc_msgForward是IMP类型, 用于消息转发, 当向一个对象发送一条消息, 但它并没有实现的时候, objc_msgForward 会尝试做消息转发<br>涉及到的流程</p>
<p>18 Method Swizzle注意事项</p>
<p>在change之前, 先添加下, 看看当前类有没有这个方法, 防止更换了父类的方法<br>防止多次更换, 两次更换相当于没有更换</p>
<pre><code>Class  = object_getClass([self class]);

Method originalMethod = class_getInstanceMethod(className, ori);
Method swizzleMethod = class_getInstanceMethod(className, swi);

BOOL didAddMethod = class_addMethod(className, ori, method_getImplementation(swizzleMethod), method_getTypeEncoding(swizzleMethod));
if (didAddMethod) &#123;
    class_replaceMethod(className, swi, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
&#125;
else&#123;
    method_exchangeImplementations(originalMethod, swizzleMethod);
&#125;</code></pre><p>RunLoop<br>31 RunLoop</p>
<p>一个RunLoop 是一个事件处理环, 系统利用这个事件处理环来安排事物, 协调输入的各种事件. RunLoop的目的是让你的线程在有工作的时候忙碌, 没有工作的时候休眠, 节省CPU事件</p>
<p>RunLoop 实际上就是一个对象, 这个对象管理了其需要处理的事件和消息, 并提供了入口函数来执行事件. 线程执行了这个函数后, 就会一直处于这个函数内部”接收消息-&gt;等待-&gt;处理”的循环中, 直到这个循环结束, 函数返回</p>
<p>32 AFNetworking 中如何使用了RunLoop</p>
<p>AFURLConnnectionOperation 这个类是基于NSURLConnection构建的, 为了希望能在后台线程接受Delegate回调, 为此AF单独创建了一个线程, 并在线程里启动了RunLoop,</p>
<ul>
<li>(void)networkRequestThreadEntryPointer:{<br>  [NSThread currentThread] setName:@“AFNetworking”];<br>  NSRunLoop *runLoop = [NSRunloop currentRunLoop]<br>  runLoop addPort:[NSMackPort Port] forMode:NSDefaultRunLoopMode]<br>[runloop run]<br>}</li>
</ul>
<p>RunLoop启动前必须有至少一个timer observer source, 所以AFNetworking在[runloop run]之前先创建了一个新的NSMackPort 添加进去, 通常情况下, 调用者持有这个 NSMachPort(mack_port)并在外部线程通过这个Port 发送消息到Loop内,但此处添加Port 只是为了让RunLoop 不至于退出, 并没有用于实际发消息</p>
<p>当需要在这个后台线程执行任务的时候, AF通过[NSobject performSelectr:onThread]将这个任务扔到了后台线程的runLoop中</p>
<p>33 AutoReleasePool 何时释放</p>
<p>App启动后, 苹果在主线程RunLoop注册了两个Observer, 其回调都是 wrapRunLoopWithAutorealeasePoolHandler()</p>
<p>第一个Observer监视的事件是 Entry(即将进入Loop), 其回调内会调用 _objc_AutoRelaasePoolPush() 创建自动释放池, 其Order是-2147483647, 优先级最高, 保证创建释放池在其他回调之前</p>
<p>第二个 Observer 监听了两个事件,1.  BeforeWaiting (准备进入休眠)时调用 _objc_autorealesePoolPop() 和 _objc_autoreleasePoolPush() 释放旧池并创建新池.  2. Exit (即将退出Loop)时调用 _objc_autorealeasePoolPop() 来释放自动释放池, 这个Observer的order 是2147347474, 优先级最低, 保证释放池子发生在其他所有回调之后</p>
<p>34 RunLoop的mode</p>
<p>KCFRunLoopDefaultMode: 默认模式, 主线程是在这个运行模式下运行<br>UITrackingRunLoopMode, 跟踪用户交互事件(用于scrollview追踪触摸滑动, 保证界面滑动时不受其他mode影响)<br>UIInitializationRunLoopMode 在刚启动App的进入的第一个mode, 启动完成后就不再使用<br>GSEventReceiveRunLoopMode 接受系统内部事件, 通常用不到<br>KCFRunLoopCommonModes 伪模式, 不是一种真正的运行模式, 是同步Source/Timer/Observe到多个mode中的一种解决方案</p>
<p>36 RunLoop 的数据结构</p>
<p>NSRunLoop 是 CFRunLoop 的封装, 提供了面向对象的API RunLoop相关的主要涉及五个类<br>CFRunLoop: RunLoop 对象<br>CFRunLoopMode 运行模式<br>CFRunLoopSource 输入源/事件源<br>CFRunLoopTimer: 定时源<br>CFRunLoopObserver 观察者</p>
<p>1 CFRunLoop 由 pthread, currentMode, modes, commonModes, commonModelItems 构成</p>
<p>2 CFRunLoopMode 由name source0  source1 observers timers 构成</p>
<p>3 CFRunLoopSource 分两种 source0 和 source1</p>
<p>source0 即非基于port 的, 也就是用户触发的事件. performSelector:onTHread,需要手动唤醒线程, 将当前线程从内核态切换到用户态<br>Source1 基于port , 包含一个 mach_port 和一个回调, 可监听系统端口和通过内核和其他线程发送的消息, 能主动唤醒RunLoop, 接手分发系统事件, 具备唤醒线程的能力</p>
<p>4基于时间的触发器, 基本上说的就是NSTimer. 在预设的时间点唤醒RunLoop 执行回调. 因为他是基于RunLoop的, 因此他不是实时的<br>5 CFRunLoopObserver</p>
<p>监听以下时间点: CFRunLoopActivity</p>
<p>KCFRunLoopEntry RunLoop 准备启动</p>
<p>KCFRunLoopBeforeSources RunLoop 将要处理一些Source事件</p>
<p>KCFRunLoopBeforeWating  将要进行休眠状态, 即将由用户态切换到内核态</p>
<p>KCFRunLoopAfterWaiting RunLoop 被唤醒, 即从内核态切到用户态</p>
<p>KCFRunLoopExit RunLoop 退出</p>
<p>KCFRunLoopAllActivities 监听所有状态</p>
<p>什么叫内核态和用户态<br>内核态:运行操作系统程序, 操作手机硬件资源, 比如协调CPU资源, 分配内存资源<br>用户态:运行用户程序. 内核提供通用的访问接口, 让用户态调用<br>当一个进程在执行用户自己的代码是处于用户态. 用户态没有能力直接操作硬件, 只能通过操作操作系统内核提供的调用使用硬件资源<br>当一个进程因为系统调用陷入内核代码中执行时处于内核态</p>
<p>37 解释下事件相应的过程</p>
<p>苹果注册了一个 source1 用来接收系统事件, 其回调函数为 IOHIDEventSystemClientQueueCallBack()  当一个硬件事件(触摸/锁屏/摇晃等)发生后, 首先由 IOKit.framework 生成一个 IOHIDEvent 事件, 并由 SpringBoard 接收. SpringBoard 只接收按键(锁屏/静音等) 触摸, 加速, 接近传感器等几种 event, 并调用 UIApplicationHandleEventQueue() 进行应用内部的分发. UIApplicationHandlerEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理分发, 其中包括识别 UIGesture/处理屏幕旋转.发送给 UIWindow 等. 通常事件, 比如 UIButton 点击 touchesBegin/move/end/cancle 事件都是在这个回调中完成的</p>
<p>KVC&amp;KVO</p>
<p>53 KVC<br>setValue:forkey  setObject:forKey<br>setValue 中value可以为nil, 但是setobject不行, 如果setValue中value是nil, 会自动调用removeObjectForKey<br>setValue中的key只能是NSString, 但是setObject中的key可以使任意类型</p>
<p>使用KVC给一个对象赋值时, 会有以下方法和属性的调用顺序<br>    0.    查看setXXX 或者 _setXXX 方法<br>    0.    查看+ (Bool)accessInstanceVariablesDirecty 方法的返回值, 默认返回yes<br>    0.    yes: 可以访问成员变量, 进入下一步<br>    0.    NO 不可以访问成员变量, 同时调用 -(void)setValue:(id)value forUndefinedKey:(nsstring *)key方法, 如果方法不存在会抛出异常<br>    0.    调用成员变量: _key _isKey key isKey<br>    0.    调用顺序, 从左到右, 只要发现存在成员变量, 就不会调用后续变量<br>    0.    如果没有成员变量, 会调用-(void)setValue:(id)value forUndefineKey 方法, 如果方法不存在会抛出异常</p>
<p>KVC取值是, 方法和成员变量的调用顺序<br>    0.    判断是否有这几个方法 getKey key isKey _key, 依次调用<br>    0.    调用+ (Bool)accessInstanceVairablesDirectkly 勘察是否可以访问成员变量 默认yes<br>    0.    Yes, 可以访问成员变量, 进入下一步<br>    0.    No, 不可以访问成员, 判断是否实现 -(id)valueForUndefinedKey:(NSString *)key, 实现是调用, 未实现报错<br>    0.    判断是否有这几个成员变量 _key _iskey key isKey, 一次调用<br>    0.    判断是否实现 -(id)valueForUNdefineKey:(NSSTring *)key方法, 实现时调用, 未实现报错</p>
<p>KVC可以修改只读. (为什么?)</p>
<p>51 KVO 实现原理</p>
<p>KVO 是通过 isa-swizzling 技术实现的, 在运行时根据原类创建一个中间类 NSKVONotifying_XXX, 这个中间类是原类的子类, 并动态修改当前对象的isa指向中间类, 并且将class方法重写返回原类的 class, dealloc. isKVO方法, ,  所以苹果建议在开发中不应该依赖isa指针, 而是通过class实例方法获取对象类型</p>
<p>重写的类<br>class<br>dealloc<br>set方法<br>isKVO</p>
<p>苹果也会重写对于的set方法, 将原来的setXXX方法转换成C语音的foundation框架的 _NSSetXXXValueAndNofity 函数, 子类拥有自己的set方法实现, set方法实现内部会顺序调用 willChangeValueforKey 原来的setter方法实现, didChangeValueforKey方法. didChangeValueforKey 会调用监听器的方法</p>
<p>KVO可以监听category中的属性, 也是重写了set方法</p>
<p>如何手动触发KVO?</p>
<p>通过实例对象调用willChangeValueForKey 和 didChangeValueForKey, 能否不调用willChangeValueForKey 不调用Didchange? 不可以. 因为didChange内部会检查是否执行了willchange, 如果没有被调用是不会触发监听方法的</p>
<p>通过KVC赋值也会触发KVO.  通过KVC修改成员变量也会触发KVO, 可能内部会调用willchangevalueforkey didchangevalueforkey<br>但是 直接修改成员变量不会触发KVO</p>
<p>52 NSNotification 实现原理<br>    [NSNotificationCenter defaultCenter] addObserver:&lt;#(nonnull id)#&gt; selector:&lt;#(nonnull SEL)#&gt; name:&lt;#(nullable NSNotificationName)#&gt; object:&lt;#(nullable id)#&gt;<br>通知中心是单例类, 并且通知中心维护了一个包含所有注册的观察者的集合</p>
<p>首先在初始化 NSNotificationCenter会创建一个对象, 这个对象里面保存了 NamedTable ,unNameTable ,wildcard 和一些其他东西<br>根据传入的参数实例化一个obarvation, observation对象保存了观察者对象, 接收到通知观察者所执行的方法, 以及下一个observation对象的地址<br>根据是否传入notificationName, 选择操作NamedTable 还是NameLessTable<br>若传入了NotificationName, 则会以NotificaitonName为key去查找对应的table(这个table key是object, value 是一个链表), 若找到table, 则取出对应的table. 若未找到对应的table, 则新建一个table, 然后将这个table以NotificaitonName为key添加到NamedTable中<br>若在保存Observation 的table找那个, 以object为key取对应的链表. 若找到了则直接在链表尾部插入之前创建的observation. 若未找到则以之前实例好的Observation对象作为头结点插入进入</p>
<p>NSNotification是同步的</p>
<p>多线程</p>
<p>40 线程和进程</p>
<p>多线程的优点 适当提高程序的执行效率, 适当提高资源利用率 (Cpu, 内存利用率)</p>
<p>缺点: 开启线程需要占用一定的内存空间, 默认情况下, 主线程1M, 子线程512kb, 如果开启大量线程, 会占用大量的内存空间, 降低程序的性能<br>线程越多, cpu在调度线程上的开销就越大<br>程序设计更加复杂, 比如线程之间的通信, 多线程的数据共享</p>
<p>42 NSOperation</p>
<p>NSOperation 是苹果对GCD的面向对象的封装, 他使用起来比GCD更加灵活, 功能更加强大, 虽然会增加一点点额外的开销, 但是却换来了非常强大的灵活性和功能, 我们可以给operation直接添加依赖关系, 取消一个正在执行的opreation, 暂停和回复 operation queue等. NSOperation 和 NSOperationQueue 还提供了判断执行状态, 取消任务, 控制线程数量等更多任务管理的api</p>
<p>添加依赖<br>NSoperationQueue *queue = []<br>NSBlockOperation *op1 = []<br>NSBlockOperation *op2 = []<br>op2.completionBlock = ^{}</p>
<p>[Op1 addDependency:op2]<br>Queue addOperation:op1]</p>
<p>63 GCD</p>
<p>GCD 是基于XNU内核实现的</p>
<p>自动利用CPU的高性能多线程解决方案. 能自动管理分配线程池<br>GCD 有三种队列<br>    0.    主线程队列<br>    0.    全局队列<br>    0.    自定义队列</p>
<p>同步: 只能在当前线程中执行任务, 不具备开启新线程的能力, 任务立刻马上执行, 会堵塞当前线程并等待block中的任务执行完毕, 然后当前线程才会继续往下执行<br>异步: 可以在新的线程中执行任务, 具备开启新线程的能力, 但不一定会开新线程, 当前线程会直接往下执行, 不会堵塞当前线程</p>
<p>线程和队列<br>队列是保存以及管理任务的, 线程负责去队列中取得任务进行执行</p>
<pre><code>0.    dispatch_async</code></pre><p>用来异步执行任务, 可以分成三个阶段, 第一阶段是更新队列链表, 第二部分是从队列取任务, 第三部分是执行任务<br>如果是async到主队列, 则会向主线程的RunLoop发送消息并唤醒Runloop, 接着会在回调函数中取出block并执行<br>如果是async到其他线程, 会检测线程池中可用的线程, 从队列中依次取出任务执行</p>
<pre><code>0.    dispatch_sync</code></pre><p>—向串行队列提交同步任务, 执行的是dispatch_barrier_sync_f函数<br>——如果当前队列没有任务执行, 则调用_dispatch_barrier_sync_f_invoke 执行任务<br>——如果当前队列有任务执行, 等待该队列的任务执行完之后用信号量通知队列继续执行任务<br>—向并发队列提交同步任务<br>——如果队列存在其他任务, 使用信号量等待<br>——没有任务, 直接调用_dispatch_sync_f_invoke执行任务</p>
<pre><code>0.    dispatch_barrier_async</code></pre><p>—如果是全局队列, 和dispath_async一样<br>—如果是串行队列,同dispatch_sync 一样<br>—自定义并行队列<br>——等待前面任务执行完<br>——修改suspend_count保证其他任务不会同步执行<br>——barrier block执行完之后重置suspend_count<br>实现多读单写的功能<br>-(id)objectForKey:(NSString*)key{<br>    dispatch_sync(concurrent_queue),^{}<br>}<br>-(void)setobject:(id)obj{<br>    dispatch_barrier_async(concurrent_queue,^{})<br>}</p>
<p>dispath_barrier_sync 和 dispatch_barrier_async 都会隔离队列中栅栏前后的任务, 不同的是会不会阻塞当前队列</p>
<pre><code>0.    dispatch_group</code></pre><p>dispatch_group本质是初始化一个LONG_MAX的信号量, 等到group中的任务完成其实是等待value回复初始值<br>—dispatch_group_enter 和 _leave必须成对出现, 如果enter比leave多一次, 则wait函数等待的线程不会被唤醒和注册的notify回调block不会执行<br>—如果leave比enter多一次, 则会引起崩溃</p>
<pre><code>0.    dispatch_once </code></pre><p>—用原子性操作block执行完成标记位, 同时用信号量确保只有一个线程执行block, 等block执行完在唤醒所有等待中的线程</p>
<pre><code>0.    Dispatch source 使用最多的就是用来实现定时器, source创建后默认是暂停状态, 需要手动调用 resume 启动定时器. dispatch_after 只是封装调用了dispatch_source定时器, 然后在回调中执行定义的block</code></pre><p>—resume和suspend调用次数需要平衡, 如果重复调用resume则会崩溃<br>—source在suspend状态下, 如果直接设置source=nil或者重新创建source都会造成crash. 正确的方式是在resume状态下调用dispatch_source_cancle(source)后重新创建</p>
<pre><code>0.    dispatch_after 延迟提交,不是延迟执行, 函数依赖于 dipatch_source 定时器, 他注册了一个定时器, 然后在回调函数中执行block

0.    dispatch_apply 类似一种for循环, apply是同步调用,block任务执行N次后才会返回, 用并行队列才能发挥最大的作用, 效率一般快于for循环的串行机制

0.    判断是否是执行线程</code></pre><p>使用dispath_queue_set_specific &amp; dispatch_get_speific 标记并获取指定队列<br>dispatch_queue_t queueA = dispatch_queue_create(“com.lyk.queueA”, NULL);</p>
<pre><code>static int kQueueSpecific;
CFStringRef queueSpecificValue = CFSTR(&quot;queueA&quot;);
dispatch_queue_set_specific(queueA, &amp;kQueueSpecific, (void *)queueSpecificValue, (dispatch_function_t)CFRelease);
dispatch_sync(queueA, ^&#123;
    dispatch_block_t block = ^&#123;
        NSLog(@&quot;NO deadlock!&quot;);
    &#125;;

    CFStringRef retrievedValue = dispatch_get_specific(&amp;kQueueSpecific);

    if (retrievedValue) &#123;
        block();
    &#125; else &#123;
        dispatch_sync(queueA, block);
    &#125;
&#125;);
0.    死锁</code></pre><p>-(void)viewDidload{<br>    [super viewDidLoad];<br>    dispatch_sync(dispatch_get_main_queue(), ^{<br>        NSLog(@“”deallock)<br>    })<br>}<br>同步对于任务是立即执行, 那么当把任务放进主队列是, 他就会立即执行, 只有执行完这个任务, viewDidLoad才会继续往下执行. 由于队列是先进先出原则, 任务有需要等待viewDidLoad执行完毕后才能继续执行. viewDidLoad和这个任务就形成了相互循环等待, 就造成了死锁</p>
<p>GCD面试题1<br>dispatch_queue_t queue = dispatch_Get_global_queue(0,0)<br>dispatch_async(queue, ^{<br>nslog(@“1”)<br>[self performSelector:@selector(test) withObject:nil afterDelay:0.0]<br>NSLog(@“3”)})</p>
<p>只会输出1,3 , test方法不执行, 因为没有runloop</p>
<p>面试题2<br>NSThread *thread = [NSThread alloc]initWithBlock:^{ NSLog(@“1”)}];<br>[thread start]<br>[self perforemSelector:@selector(test) onTheard:thread withObject:nil waitUntilNode:yes]</p>
<p>只输出1, 因为start之后, 线程就结束了, 解决方法, 新增runloop</p>
<p>面试题3<br>63  同步线程<br>Aaa;<br>dispatch_semaphore_t sema = dispatch_semaphore_create(0);<br>AsyncNetRequest^(id response){<br>   // use response<br>dispatch_semaphore_signal(sema, DISPATCH_TIME_FOREVER);<br>Bbb;<br>}<br>dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);<br>ccc;</p>
<p>方案2<br>dispatch_group_t disGroup = dispatch_group_create()<br>dispatch_group_enter(group);<br>Aaa;<br>AsyncNetRequest^(id response){<br>   // use response<br>Bbb;<br>dispatch_group_leave(group);<br>}</p>
<p>dispatch_group_notify(group, dispatch_get_global_queue(0, 0), ^{<br>    ccc<br>    });</p>
<p>单例</p>
<p>+(id *)shared{<br>Static manager *m = nil<br>Static dispathc_once_t onceToken;<br>dispathc_once(&amp;onceToken, ^{<br>    m = [manager alloc]init];<br>});<br>Return manager<br>}</p>
<pre><code>0.    线程和RunLoop的关系</code></pre><p>—Runloop和线程是一一对应的, 他们的关系保存在一个全局的字典里<br>—对于主线程, runloop在程序一启动就默认创建好了, 但是子线程默认没有创建runloop. 需要使用懒加载的方式去获取</p>
<p>熟悉的第三方库</p>
<p>—Aspects<br>实现原理<br>—通过将目标函数的方法实现改写为转发函数的实现(objc_msgForward), 从而使对目标方法的调用可以走入主流程-方法改写中被改写的转发函数实现中, 从而相当于调用了改写后的方法</p>
<p>—-为什么在forwardInvocation?<br>——因为消息转发的几个阶段的特性不太一样, resolveInstanceMethod:适合给类/对象动态添加一个相应的实现, forwardingTargetForSelector:适合将消息转发给其他对象处理  forwardInvocation: 是里面最灵活, 最能符合需求的<br>——当执行objc_msgForward 会直接触发消息转发机制, 即 forwardInvocation</p>
<p>替换流程<br>—动态创建子类<br>—将子类的forwardInvocation的实现替换成<strong>ASPECTS_ARE_BEING_CALLED</strong><br>—将子类的元类的isa指向原生的类<br>—注册子类<br>—把self对象的isa指针指向子类<br>—添加别名方法<br>—替换原始方法为转发方法 _objc_msgForward</p>
<p>无法hook类方法<br>因为在获取的方法的时候用的是[object class] instanceMethodsignatureForSelector:selector], 如果是类方法, 会返回nil</p>
<p>—SDWebImage<br>—先使用占位图<br>—在缓存里找图片<br>—硬盘里找图片<br>—开始下载图片, 图片下载用NSURLConnection来做<br>—下载成功后, 在NSOperationqueue完成解码<br>—通知主线程宣告解码完成,然后回调展示图片<br>—保存图片到内存和硬盘里<br>源码再看看</p>
<p>如何加载高分辨率的图片<br>—未来避免内存暴增, 将原图剪裁成多个小图, 然后依次绘制到目标位图context中<br>—或者用苹果提供的异步绘制内容的图层CATiedLayer , 不需要加载全部图片, 可以将大图分解成小图片, 然后在载入显示</p>
<p>如何加载一个内存很大的图片: 降低采样率</p>
<p>AsyncDisplayKit<br>将消耗时间的渲染,图片解码, 布局以及其他ui操作等等全部移除主工程, 这样主工程对用户的操作及时作出反应, 达到流畅运行的目的<br>ASDisplayNode用UIView-CALayer 实现了ASNode-&gt;UIView的一种关系. 当不需要相应触摸事件时, ASDisplayNode 可以被设置为layer backed, node刚创建的时候, 并不会在内部创建uiview和calyer, 只有第一次在主线程访问uiview和calyer属性是, 他才会在内部生成相应对象. 当frame改变后, 等待runloop设置内部的uiviiew和layer<br>ASDK的图层预合成. 把一个大的层级绘制到一张图上, 性能会获得很大提升. cpu也避免了创建uikit对象的资源消耗</p>
<p>86 如将一张内存极大的图片可以像地图一样的加载出来<br>使用CATiledLayer加载大图, tilelayer 设置一个缩放区间的集合和重绘阈值, 让让scrollView 在缩放时, 绘制层根据这些区域和缩放阈值去重新绘制当前显示的区域</p>
<p>图片内存大小, 字节数 = 宽高<em>高度</em>4(颜色RGBA占用的4个字节)<br>1.之所有图片的大小与硬盘的占用大小无关是因为硬盘中的图片都是以不同的容器格式被编码了的, 如png, jpeg 等格式, 这些不能被用来直接显示;<br>2.能够被用来直接显示的只有一种格式就是 bitmap 位图的方式. 要从硬盘中的容器格式变成位图,就会经历 图片解码的过程. 而解码后的位图大小计算方式如上</p>
<p>64 实现内存泄漏的检测<br>为nsobject 新增一个属性willDealloc, 然后hook VC的dismiss或者pop方法, 在页面消失之后遍历页面的subviews, 访问新增的属性是否是nil</p>
<p>68 RN的声明周期<br>getDefaultProps<br>getInitalState:创建的时候调用的第一个函数. 对组件的一些状态进行初始化<br>componentWillMount: 控件渲染前触发<br>Render:渲染控件的方法<br>componentDidMount:控件渲染后触发</p>
<p>66<br>请画出一条开始和结束比较慢, 中间比较快的贝塞尔曲线<br>1.创建CAShapeLayer 和 贝塞尔曲线</p>
<p>yellowLayer = [shapeLayer [alloc init]<br>UIBezierPath *path = [UIBezierPath alloc]init]<br>path moveToPoint<br>path addLineToPoint<br>yellowLayer.path = path.cgpath<br>self.view.layer addsubLayer:yellowLayer]<br>2.动画<br>CALayer *car<br>car.frame  = CGRectMake<br>car.contents = (__bridge id _Nullable)([UIImage imageName:@“”].CGImage)<br>CAKeyframeAnimation *ani = [CAkeyframeAnimation animationWithKeyPath:@“position”]<br>Ani.path = yellowLayer.path<br>Ani.duration = 1<br>Ani.atuoreverses = NO<br>Ani.repeatCount = 1<br>Ani.timingFunction = [CAMediaTimingFunction funcitonWithName:kCAMediaTimingFunctionEaseInEaseOut]<br>yellowLayer addSubLayer:car<br>Car addAnimation:ani forKey:@“carAni”</p>
<p>67<br>递归搜索指定目录下指定类型文件的函数</p>
<ul>
<li><p>(NSMutableArray *)filePathArray:(NSString *)directoryPath<br>{<br>  NSMutableArray *mFilePathArray = [NSMutableArray array];<br>  NSFileManager *fileManager = [NSFileManager defaultManager];<br>  //获取当前路径的文件<br>  NSArray *array = [fileManager contentsOfDirectoryAtPath:directoryPath error:nil];<br>  __block BOOL isDir = YES;<br>  [array enumerateObjectsUsingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) {</p>
<pre><code>NSString *path = [directoryPath stringByAppendingPathComponent:obj];
if ([fileManager fileExistsAtPath:path isDirectory:&amp;isDir])&#123;
    if ([path hasSuffix:@&quot;.png&quot;]) &#123;
        [mFilePathArray addObject:path];
    &#125;
    if (isDir) &#123;
        NSLog(@&quot;继续遍历&quot;);
        [mFilePathArray addObjectsFromArray:[self filePathArray:path]];
    &#125;
&#125;</code></pre><p>  }];<br>  return mFilePathArray;<br>}</p>
</li>
</ul>
<p>57 wkwebview 的优点<br>    0.    单独的进程加载url, app进程内存消耗不大, 但是ohter process的内存占比会增加<br>    0.    在uiwebvew上内存占比太大的时候, app process 会crash, 但在wkwebview上当总体的内存占用比较大的时候, webContentProcess 会crash, 从而出现白屏现象<br>    0.    Ios9 有 customUserAgent, 单独页面定制ua<br>    0.    代理回调很多, 比如https权限认证代理方法回调<br>    0.    有一些坑没解决, 比如拦截post请求丢参数<br>    0.    Uiwebview 执行一段简单的js代码, 也会占用app大量内存, 而wkwebview, 不仅有出色的渲染性能, 而且他还有独立进程, 一些网页相关的内存消耗移到自身进程中, 最适合取代uiwebview</p>
<pre><code>0.    39 打通前端与原生的桥梁: JSScore能干那些事情
0.    JavaScriptCore, 原本是WebKit中用来解释执行JavaScript代码的核心引擎
0.    JSCore框架主要由JSVirtualMachine JSContext JSValue类组成
0.    JSVirtualMachine的作用是为JavaScript代码的运行提供一个虚拟机环境
0.    JSContext是JavaScript运行环境的上下文, 负责原生和JavaScript的数据传递
0.    JSValue是JavaScript的值对象, 用来记录JavaScript的原始值, 并提供进行原生值对象转换的接口方法
0.    JavaScriptCore内部是由Parser InterPreter Compiler GC等部分组成
0.    Js调用原生除了Block外, 我们还可以通过JSExport协议来实现在JavaScript中调用原生代码, 也就是原生代码中让遵循JSExport协议的类, 能够供JavaScript使用, 比如Weex
0.    原生调用js全局函数, 需要使用jsvalue的invokeMethod:WithArguments方法</code></pre><p>bridge调用, 拦截 decidePolicyForNavigationAction<br>mk注入js,  [mkwebview.configuration.userContentController addUserScript:<br>时机  WKUserScriptInjectionTimeAtDocumentStart 注入时机为document的元素生成之后,其他内容load之前..  WKUserScriptInjectionTimeAtDocumentEnd 注入时机为document全部load完成,任意子资源load完成之前.</p>
<p>UIWebView 支持全局的cookie可以共享 NSHTTPCookieStorage单利中的cookie而WKWebView不能共享（ WKWebView存储cookie的路径和NSHTTPCookieStorage存储cookie的路径目前是不同的</p>
<p>iOS 11.0后增加了【WKHTTPCookieStore】类，专门用来管理与之关联的WKWebView的Cookie</p>
<p>应用<br>1.获取ios内存</p>
<p>#import &lt;sys/sysctl.h&gt;<br>#import &lt;mach/mach.h&gt;<br>获取当前设备的可用内存 获取到的是字节, 转换成M需要处于1024/1024</p>
<ul>
<li>(double)availableMemory<br>{<br>vm_statistics_data_t vmStats;<br>mach_msg_type_number_t infoCount =HOST_VM_INFO_COUNT;<br>kern_return_t kernReturn = host_statistics(mach_host_self(), <pre><code>HOST_VM_INFO, 
(host_info_t)&amp;vmStats, 
&amp;infoCount);</code></pre>if (kernReturn != KERN_SUCCESS) {<br>  return NSNotFound;<br>}<br>return ((vm_page_size *vmStats.free_count) /1024.0) / 1024.0;<br>}<br>获取当前任务所占的内存</li>
<li>(double)usedMemory<br>{<br>task_basic_info_data_t taskInfo;<br>mach_msg_type_number_t infoCount =TASK_BASIC_INFO_COUNT;<br>kern_return_t kernReturn =task_info(mach_task_self(), <pre><code>TASK_BASIC_INFO, 
(task_info_t)&amp;taskInfo, 
&amp;infoCount);</code></pre>if (kernReturn != KERN_SUCCESS<pre><code>) &#123;</code></pre>  return NSNotFound;<br>}<br>return taskInfo.resident_size / 1024.0 / 1024.0;<br>}</li>
</ul>
<p>2.ios启动周期<br>1.didfinishLaunchingWithOption<br>2.applicationDidBecomeActive</p>
<p>//进入后台<br>2.applicationWillResignActive<br>3.applicationDidEnterBackground</p>
<p>//进入前台<br>4.applicationWillEnterForeground<br>5.applicationDidBecomeActive</p>
<p>App的声明周期<br>1.loadview—不应该被直接调用, 如果self.view 为nil 会调用self.loadview 创建uiview<br>2.viewDidLoad<br>3.viewWillAppear<br>4.viewwillLayoutsubviews<br>5.viewDidLayoutSubviews<br>6.viewDidAppear<br>7.viewWillDisapper<br>8.viewDidDisappear<br>9.viewWillUnload<br>10.viewDidUnload<br>dealloc</p>
<p>3.strlen和sizeof的区别<br>sizeof是求数据类型所占的空间大小,而strlen是求字符串的长度</p>
<p>4.宏最大值<br>#define MAX(x,y) (((x)&gt;(y))?(x):(y))</p>
<p>5 隐式动画和显示动画<br>隐式动画一直存在, 如需隐藏需设置<br>显示动画不存在, 如果显示要创建</p>
<p>6.NSInvocation与PerformSelector区别<br>作用一样, 都可以实现直接调用某个对象的消息<br>在参数个数&lt;= 2的时候performSelector：的使用要简单一些，但是在参数个数 &gt; 2的时候NSInvocation就简单一些</p>
<p>7.autolayout<br>Autolayout基于布局算法CAssowary. autoLayout的核心是一个layout Engine 的布局引擎系统. 每个视图在得到自己的布局之前, layout Engine 会将视图, 约束, 优先级, 固定大小通过计算转换成最终的代销和位置. 在layout engine里, 每当约束发生变化, 都会触发layout, 完成后进入监听约束变化的状态.</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author: </strong>bomo
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://fangliquan.github.io/2021-03-16/2021-03-14-iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E4%BA%8C/" title="2021-03-14-iOS面试整理(二)">http://fangliquan.github.io/2021-03-16/2021-03-14-iOS面试整理-二/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a>" rel="external nofollow" target="_blank">undefined</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS%E9%9D%A2%E8%AF%95/" rel="tag"># iOS面试</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/" rel="prev" title="iOS面试整理(一)">
      <i class="fa fa-chevron-left"></i> iOS面试整理(一)
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Author"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Author</p>
  <div class="site-description" itemprop="description">iOS,Windows开发者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhengbomo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhengbomo@hotmail.com" title="Email → mailto:zhengbomo@hotmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>Email</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/intent/user?user_id=371531868" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;intent&#x2F;user?user_id&#x3D;371531868" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://facebook.com/zhengbomo" title="Facebook → http:&#x2F;&#x2F;facebook.com&#x2F;zhengbomo" rel="noopener" target="_blank"><i class="fab fa-facebook fa-fw"></i>Facebook</a>
      </span>
      <span class="links-of-author-item">
        <a href="tencent://message/?uin=449179249&Site=&Menu=yes" title="QQ → tencent:&#x2F;&#x2F;message&#x2F;?uin&#x3D;449179249&amp;Site&#x3D;&amp;Menu&#x3D;yes" rel="noopener" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/1891587992" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;1891587992" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bomo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
