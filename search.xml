<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOSiOS面试整理(一)</title>
      <link href="2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/"/>
      <url>2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h2><h3 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h3><h4 id="1-谈谈对内存管理的理解"><a href="#1-谈谈对内存管理的理解" class="headerlink" title="1.谈谈对内存管理的理解"></a>1.谈谈对内存管理的理解</h4><p>MRC (手动引用计数) 和ARC (自动引用计数)</p><ol><li><h5 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h5><ul><li><p><strong>核心思想：引用计数式内存管理</strong></p><ul><li><p>四个法则</p><ul><li><p>自己生成的对象自己持有 (使用 alloc/new/copy/mutableCopy 开头的方法生成对象后持有对象)</p></li><li><p>非自己生成的对象自己也能持有 (retain)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有</span><br><span class="line">&#x2F;&#x2F; 通过autorelease使对象的持有权在AutoreleasePool</span><br><span class="line">[obj retain]; &#x2F;&#x2F; 自己持有对象</span><br></pre></td></tr></table></figure></li><li><p>不再需要自己持有的对象时释放 (release)</p></li><li><p>非自己持有的对象不能释放</p></li></ul></li></ul></li><li><p>对象操作对应的方法</p><table><thead><tr><th align="center">对象操作</th><th align="center">OC中方法</th><th align="center">retainCount变化</th></tr></thead><tbody><tr><td align="center">生成并持有对象</td><td align="center">alloc/new/copy/mutableCopy</td><td align="center">+1</td></tr><tr><td align="center">持有对象</td><td align="center">retain</td><td align="center">+1</td></tr><tr><td align="center">释放对象</td><td align="center">release</td><td align="center">-1</td></tr><tr><td align="center">废弃对象</td><td align="center">dealloc</td><td align="center">无</td></tr></tbody></table><ul><li>alloc/new方法通过调用 allocWithZone: 类方法分配存储空间并初始化，同时使得retainCount = 1。</li><li>调用 retain 方法后引用计数值+1。</li><li>调用release方法后引用计数-1。</li><li>当retainCount = 0 时，调用 dealloc 方法废弃对象。</li></ul></li><li><p>苹果将引用计数保存在引用计数表中（是一个散列表）</p><p>优点：</p><ul><li>对象内存块的分配无需考虑内存块头部</li><li>引用计数表各记录中有内存块地址，可从各个记录追溯到各对象的内存块。（即使对象占用内存块损坏，能够根据引用计数表找到各内存块的位置）</li></ul></li><li><p>autorelease</p><ul><li>autorelease使得对象在超出其作用作用域（生命周期）后，在废弃autoreleasepool时，其中所有对象的release方法会被调用一次，可以指定变量的作用域。</li><li>步骤：<ol><li>生成并持有 NSAutoreleasePool 对象</li><li>调用已分配对象的 autorelease 对象方法</li><li>废弃NSAutoreleasePool对象。（调用 <code>- drain</code> 对象方法）</li></ol></li><li>release 和 autorelease 区别：<ul><li>调用 release 方法，对象会立即被释放</li><li>调用 autorelease 方法，对象不会立即被释放，而是被注册的 autoreleasepool 中，当autoreleasepool 对象被废弃时（drain），对其中的对象都做一次 release 操作。</li></ul></li></ul></li></ul></li><li><h5 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h5><ul><li><p><strong>本质还是引用计数式内存管理</strong></p></li><li><p><strong>由编译器进行内存管理</strong>。实际上是 编译器 + 运行时库。在编译时，系统自动在合适的位置添加 retain/ release/ dealloc/ autorelease 方法。</p></li><li><p><strong>所有权修饰符</strong></p><p>ARC中通过变量所有权修饰符，不需要使用 retain/release 就能完美满足引用计数式的思考方式：</p><p><strong>从手写 release 语句变为通过控制对象的作用域控制对象的释放。</strong></p><p>“自己生成的对象自己持有” 和 “非自己生成的对象自己也能持有” 通过对带 <code>__strong</code> 修饰符的变量赋值即可达到，“不再需要自己持有的对象时释放”通过废弃带 <code>__strong</code> 修饰符的变量（变量作用域结束或成员变量所属对象被废弃）或变量赋值（nil）（block中打破循环引用）做到。</p><p><code>__strong</code>、<code>__weak</code>、<code>__autoreleasing</code> 修饰的自动变量会自动初始化为nil</p><p>对象没有被变量强引用着时，该对象被释放。</p><ul><li><p><code>__strong</code> : id 类型和对象类型默认的所有权修饰符。表示对对象的强引用。</p><p>在被 <code>__strong</code> 修饰的变量超出其作用域时，即在该变量被废弃时，会释放其被赋予的对象（随强引用的失效，引用的对象随之释放）。当要废弃被强引用的对象时，要保证所有指向该对象的强引用变量都置为nil。</p></li><li><p><code>__weak</code> 提供弱引用，弱引用不能持有对象。当持有对象的弱引用时，若该对象被废弃，则此弱引用自动失效，且被置为nil。</p><p>使用 <code>__weak</code> 修饰符的变量，就是使用注册到 autoreleasepool中的对象。</p></li><li><p><code>__unsafe_unretained</code> 声明这个引用不会保持对象的存活，如果对象被废弃，不会被置nil，该变量会变成野指针。使用被其修饰的变量时，先判断是否存在。被其修饰的变量不属于编译器的内存管理对象。</p></li><li><p><code>__autorelease</code> 在ARC中替代 <code>- autorelease</code> 方法。如果方法名<strong>不以</strong> alloc/new/copy/mutableCopy 开头，编译器自动将返回值的对象注册到 autoreleasepool 中（ init 开头的方法返回的对象不会被注册到 autoreleasepool 中，只是对 alloc 方法返回值的对象）</p></li></ul></li></ul></li><li><p>内存泄漏：应当被废弃的对象在超出其生存周期后依然继续存在。</p></li></ol><h4 id="2-ARC如何实现？"><a href="#2-ARC如何实现？" class="headerlink" title="2.ARC如何实现？"></a>2.ARC如何实现？</h4><p>通过变量所有权修饰符，满足引用计数式内存管理。</p><p>编译器+运行时。</p><p>==通过运行时发送消息，通过编译器自动插入release==。</p><ul><li><p><code>__strong</code> 修饰符</p><ul><li><p>使用 alloc/new/copy/mutableCopy 产生对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">id __strong obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译后转换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; obj_msgSend(NSObject, @selector(alloc));</span><br><span class="line">obj_msgSend(obj, @selector(init));</span><br><span class="line">obj_release(obj); &#x2F;&#x2F; 编译器插入</span><br></pre></td></tr></table></figure><p>两次调用 <code>obj_msgSend()</code> 方法，在作用域结束调用 <code>obj_release</code> 释放对象。编译器自动插入了release。</p></li><li><p>非 alloc/new/copy/mutableCopy 产生对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __strong obj &#x3D; [NSMutableArray array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后转换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id obj &#x3D; objc_magSend(NSMutableArray, @selector(array));</span><br><span class="line">objc_retainAutoreleaseReturnValue(obj); &#x2F;&#x2F; 编译器插入</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure><p><code>objc_retainAutoreleaseReturnValue()</code> 函数用于持有对象，但持有的对象应为函数的返回值或者注册在 autoreleasepool 中的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后转换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id) array &#123;</span><br><span class="line">    id obj &#x3D; objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">  objc_msgSend(obj, @selector(init));</span><br><span class="line">  return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>obj_autoreleaseReturnValue()</code> 时，如果方法或函数的调用方在调用了方法或函数后紧接着调用了 <code>objc_retainAutoreleaseReturnValue()</code> 函数，那么就不将返回的对象注册到 autoreleasepool 中-而是直接传递给方法或函数的调用方。</p></li></ul></li></ul><h4 id="3-对MRC的理解"><a href="#3-对MRC的理解" class="headerlink" title="3.对MRC的理解"></a>3.对MRC的理解</h4><h4 id="4-GC（垃圾回收）和ARC的区别？"><a href="#4-GC（垃圾回收）和ARC的区别？" class="headerlink" title="4.GC（垃圾回收）和ARC的区别？"></a>4.GC（垃圾回收）和ARC的区别？</h4><ul><li><p>ARC 相比 GC 优点：</p><ul><li><p>ARC 工作在编译期，在运行时没有额外的开销。</p></li><li><p>ARC 的内存回收是平稳进行的，当对象不被持有时会立即被回收。</p><p>GC 的内存回收时需要暂停程序，会有一定的卡顿。</p></li></ul></li><li><p>ARC 相比 GC 缺点：</p><ul><li>==ARC 需要手动处理循环引用等内存管理问题，GC 不需要。==</li></ul></li></ul><h4 id="5-内存关键字（assign-weak-strong-copy-retain-介绍"><a href="#5-内存关键字（assign-weak-strong-copy-retain-介绍" class="headerlink" title="5.内存关键字（assign, weak, strong, copy, retain)介绍"></a>5.内存关键字（assign, weak, strong, copy, retain)介绍</h4><ul><li><p>assign：用于非对象类型。其 setter 方法只是执行简单的赋值操作。</p></li><li><p>weak：用于对象类型，表示弱引用。其 setter 方法中既不保留新值，也不释放旧值，同assign类似。</p><p>但是在属性所指对象遭到废弃时，属性值会被置nil。</p></li><li><p>strong：用于<strong>除</strong> NSString/block 之外的对象类型，表示一种“拥有关系”，表示对对象的持有和强引用。其 setter 方法中，先 relsease 旧值，再 retain 新值。</p></li><li><p>copy：所表达的所述关系与 strong 类似。在其 setter 方法中，不保留新值，而是将其 copy。当属性类型为 NSString 类型时，通过 copy 关键字保护器封装性，防止指向 MutableString 类型。</p></li><li><p>retain：MRC中使用，作用同 strong 相同。</p></li></ul><h4 id="6-weak和strong关键字内部做了什么？"><a href="#6-weak和strong关键字内部做了什么？" class="headerlink" title="6.weak和strong关键字内部做了什么？"></a>6.weak和strong关键字内部做了什么？</h4><h4 id="7-除了NSString什么情况下用copy？block为什么要复制到堆中？"><a href="#7-除了NSString什么情况下用copy？block为什么要复制到堆中？" class="headerlink" title="7.除了NSString什么情况下用copy？block为什么要复制到堆中？"></a>7.除了NSString什么情况下用copy？block为什么要复制到堆中？</h4><ol><li><p>带有可变类型的对象，比如 NSArray、NSDictionary等。</p><ul><li>因为父类指针能够指向子类对象，使用 copy 的目的是让本对象的属性不受外界影响，使用 copy 后无论传入的是可变还是不可变的对象，==本身持有的就是一个不可变对象==。</li><li>当用 strong 时，该属性可能指向一个可变对象，如果这个对象在外部被修改了，那么就会修改该属性。</li></ul></li><li><p>用作 block 的关键字。</p><p>在 ARC中，对 block 使用 strong 和 copy 效果一样，ARC 中会自动将栈上的 block 拷贝到堆中。这里使用 copy 关键字是为了提醒我们这里的 block 被复制到了堆中。</p><p><strong>扩展：block 为什么要复制到堆中？</strong></p><p>将栈中的 block 复制到堆上，这样即使 block 语法记述的变量作用域结束，堆上的 block 还可以继续存在。</p><p>当 block 从栈复制到堆时，block 中使用的 <code>__block</code> 变量也全部从栈复制到堆中，此时 blcok <strong>持有</strong> <code>__block</code> 变量。如果堆上的 block 被废弃，那么它使用的 <code>__block</code> 变量也就被释放。</p></li></ol><h4 id="8-调用静态方法（类方法）时需要release么？"><a href="#8-调用静态方法（类方法）时需要release么？" class="headerlink" title="8.调用静态方法（类方法）时需要release么？"></a>8.调用静态方法（类方法）时需要release么？</h4><p>静态方法（类方法）创建的对象自动加入了自动释放池中，所以不需要release。</p><h4 id="9-autorelease，AutoreleasePool的原理是什么？"><a href="#9-autorelease，AutoreleasePool的原理是什么？" class="headerlink" title="9. autorelease，AutoreleasePool的原理是什么？"></a>9. autorelease，AutoreleasePool的原理是什么？</h4><p>autoreleasepool 以==队列数组的形式==实现，主要通过3个函数完成：</p><p>1.<code>objc_autoreleasePoolPush</code> </p><p>创建 autoreleasepool，相当于NSAutoreleasePool  *pool = [[NSAutoreleasePool alloc] init]。</p><p>2.<code>objc_autoreleasePoolPop</code> </p><p>倾倒 autoreleasepool，相当于 [pool drain]。</p><p>3.<code>objc_autorelease</code></p><p>将对象加入 pool 中。</p><p><strong>扩展</strong>：如果 autorelease NSAutoreleasePool对象会如何？</p><p>答：<strong>发生异常</strong>。无论调用哪一个对象的 autorelease 实例方法，实际上是调用 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已经被重载，因此运行时会出错。</p><h4 id="10-autoreleasepool的drain时机"><a href="#10-autoreleasepool的drain时机" class="headerlink" title="10.autoreleasepool的drain时机"></a>10.autoreleasepool的drain时机</h4><ul><li><p>手动创建的 autoreleasepool（指定的autoreleasepool）：当作用域大括号结束时释放。</p></li><li><p>系统创建的 autoreleasepool（不指定autoreleasepool）：autorelease 对象出作用域后，被添加到==最近一次创建的== autoreleasepool 中，==在当前 runloop 结束时释放==。</p><ul><li><p>当 runloop 检测到事件并启动后，会自动创建一个 autoreleasepool 。</p></li><li><p>所有延迟释放的对象都被添加到这个 autoreleasepool 中。</p><p>所有 autorelease 的对象，在<strong>出了作用域之后</strong>，会被自动添加到<strong>最近创建的自动释放池中</strong>。</p></li><li><p>当 runloop 即将结束时，倾倒 autoreleasepool ，向其中所有的对象发送 release 消息后，autoreleasepool 被销毁。</p></li></ul></li></ul><h4 id="11-autoreleasepool的作用"><a href="#11-autoreleasepool的作用" class="headerlink" title="11.autoreleasepool的作用"></a>11.autoreleasepool的作用</h4><p>ARC中，不允许使用 autorelease 方法，每个 runloop 循环中系统都自动加入了autoreleasepool 的创建和释放</p><p>但是，==在需要创建和销毁大量对象时（大数的 for 循环中创建和销毁对象），使用手动创建的 autoreleasepool 可以避免内存峰值的出现==。如果不手动创建，被加入系统创建的 autoreleasepool 中的对象在 runloop 结束时才会被统一执行 release 操作，如果在 for 循环内部创建 autoreleasepool，那么每循环一次都会执行 release 操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 100000000; i++)</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool</span><br><span class="line">    &#123;</span><br><span class="line">        NSString* string &#x3D; @&quot;ab c&quot;;</span><br><span class="line">        NSArray* array &#x3D; [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-iOS中堆栈的理解？"><a href="#12-iOS中堆栈的理解？" class="headerlink" title="12.iOS中堆栈的理解？"></a>12.iOS中堆栈的理解？</h4><ul><li>堆栈的区别<ul><li>堆空间的内存是动态分配的，一般存放对象，需要手动释放。</li><li>栈空间的内存是系统自动分配的，一般存放局部变量等，系统自动回收。</li></ul></li></ul><h4 id="13-weak在对象销毁时使指向对象的指针置nil的原理？"><a href="#13-weak在对象销毁时使指向对象的指针置nil的原理？" class="headerlink" title="13.weak在对象销毁时使指向对象的指针置nil的原理？"></a>13.weak在对象销毁时使指向对象的指针置nil的原理？</h4><ul><li>使用<strong>哈希表（散列表实现</strong>）<ul><li>key：对象的内存地址。</li><li>value：被__weak修饰的变量的地址。</li></ul></li><li>当对象被废弃时发生：<ul><li>从weak表中获取被废弃对象的地址为key的记录。（<strong>获取记录</strong>）</li><li>将包含在记录中所有被<code>__weak</code>修饰的变量的地址，赋值为nil。(<strong>赋值为nil</strong>)</li><li>从weak表中删除记录。(<strong>删除记录</strong>)</li><li>从引用技术表中删除被废弃对象的地址为键值的记录。</li></ul></li></ul><h4 id="14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？"><a href="#14-block作为viewControler属性时，如果block块中使用了self-view会发生循环引用么？" class="headerlink" title="14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？"></a>14.block作为viewControler属性时，如果block块中使用了<code>self.view</code>会发生循环引用么？</h4><p>会发生。</p><p>在block代码块之前使用<code>__weak typeof(self) weakSelf = self;</code>，打破闭环。</p><h3 id="二、多线程"><a href="#二、多线程" class="headerlink" title="二、多线程"></a>二、多线程</h3><h4 id="1-对多线程的理解？"><a href="#1-对多线程的理解？" class="headerlink" title="1.对多线程的理解？"></a>1.对多线程的理解？</h4><p>进程：CPU分配资源和调度的最小单位</p><p>线程：CPU执行任务的最小单位</p><h4 id="2-iOS中实现多线程的方式有哪些？"><a href="#2-iOS中实现多线程的方式有哪些？" class="headerlink" title="2.iOS中实现多线程的方式有哪些？"></a>2.iOS中实现多线程的方式有哪些？</h4><h4 id="3-GCD和NSOperation优缺点？"><a href="#3-GCD和NSOperation优缺点？" class="headerlink" title="3.GCD和NSOperation优缺点？"></a>3.GCD和NSOperation优缺点？</h4><ul><li>GCD是纯C语言的 API，NSOperation 是基于 GCD 的面向对象的封装。</li><li>NSOperation 可以轻松在 operation 间设置依赖，设置它们的优先级，任务能够被方便地暂停、恢复，可以自定义子类。可以将 KVO 应用在 NSOperation 中，监听一个 operation 是否完成、取消、正在执行。可以设置最大并发数。</li><li>GCD 以 block 为单位，代码简洁，更为轻量化。对于一次性运算，或是仅仅为了加快现有方法的运算速度，选择轻量化的 GCD 更为方便。</li></ul><h4 id="4-死锁发生的原因是什么？如何避免？"><a href="#4-死锁发生的原因是什么？如何避免？" class="headerlink" title="4.死锁发生的原因是什么？如何避免？"></a>4.死锁发生的原因是什么？如何避免？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autorelease &#123;</span><br><span class="line">dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;发生死锁&quot;)；</span><br><span class="line">    &#125;)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步函数，会把 block 加入指定队列中，<strong>会一直等待 block 执行完成才返回。</strong>因此在 block 执行完之前，调用同步函数的线程是<strong>阻塞的</strong>。</p><p>异步函数，会把 block 加入指定队列中，<strong>不会等待 block 执行，会立即返回。</strong>只负责向队列中添加任务。</p><p>串行队列：按照任务的添加顺序执行任务。并且保证在执行某个任务时，它前面进入队列的任务都执行完了。</p><p>并发队列：按照任务的添加顺序 <strong><em>开始</em></strong> 执行任务。任务执行的结束时间不确定，取决于每个任务的耗时。</p><p><strong>原因：主线程是串行的，在执行同步函数时被阻塞，同步函数要求 block 块执行完毕后才返回，这样主线程才能继续向下执行；由于在主线程中，执行 block 块要求同步函数执行完毕才进行，这样就造成了双方的</strong><em>互相等待</em><strong>，导致了死锁的发生。</strong></p><blockquote><p><strong><em>导致死锁的原因一定是：在某个串行队列中，同步地向这个队列添加任务。(在串行队列中，同步函数向相同串行队列中添加任务)</em></strong></p></blockquote><p><strong>注意：</strong>发生死锁要具体分析同步函数所在的队列是并发队列还是串行队列，并且 block 要添加到哪种队列。</p><ul><li>如果使用异步函数添加任务，无论任务是否添加到串行队列都不会发生死锁，因为异步函数不会阻塞线程。</li><li>只在解决数据竞争问题时使用串行队列。</li></ul><p>使用同步函数 + 串行队列的组合<strong>不一定</strong>会发生死锁。同步函数所在的串行队列和要添加任务的队列不同时，不会发生死锁。</p><h4 id="5-iOS中有哪些锁？"><a href="#5-iOS中有哪些锁？" class="headerlink" title="5.iOS中有哪些锁？"></a>5.iOS中有哪些锁？</h4><p>锁：一段代码在一段时间内只能被一个线程访问。</p><p>NSLock </p><p>NSCondition 条件锁</p><p>NSConditionLock 条件锁</p><p>NSRecursiveLock 递归锁</p><h4 id="6-iOS中线程安全有哪些情况？"><a href="#6-iOS中线程安全有哪些情况？" class="headerlink" title="6.iOS中线程安全有哪些情况？"></a>6.iOS中线程安全有哪些情况？</h4><p>死锁，数据竞争，优先级反转</p><h4 id="7-多线程操作对同一块资源发生数据竞争时能怎样做？"><a href="#7-多线程操作对同一块资源发生数据竞争时能怎样做？" class="headerlink" title="7.多线程操作对同一块资源发生数据竞争时能怎样做？"></a>7.多线程操作对同一块资源发生数据竞争时能怎样做？</h4><ul><li><p>互斥锁 <code>@synchronized</code></p><ul><li>优点：不需要在代码中显式地创建锁对象，就能实现锁的机制。</li><li>缺点：消耗大量CPU资源。</li></ul></li><li><p>串行队列：一个串行队列就会开一条子线程，多个串行队列并发执行，可以用<code>dispath_set_target_queue</code>设置执行阶层。将不同的串行队列设置到新的串行队列中串行执行。</p></li><li><p>栅栏函数：使用并发队列和栅栏函数能实现高效的数据库访问和文件访问。</p></li><li><p>信号量：当信号量为1时可以当做锁使用。控制同时访问特定资源的线程数量。优势在于等待时不会消耗CPU资源。</p><ul><li><p><code>dispatch_semaphore_create(long value)</code> 创建信号量，括号中的数字表示能允许同时操作的线程数量。</p></li><li><p><code>dispatch_semaphore_wait(dispatch_semaphore_t  _Nonnull dsema, dispatch_time_t timeout)</code></p><p>第一个参数：信号量</p><p>第二个参数：阻塞时间。表示如果信号量为0时阻塞线程的时间。DISPATCH_TIME_FOREVER 表示永久阻塞。</p><p>当信号量 = 0 时，函数返回1，表示需要等待，不允许操作。</p><p>当信号量 &gt;= 1是，函数返回0，表示不需要等待，继续执行操作。<strong>并把信号量 - 1</strong></p></li><li><p><code>dispatch_semaphore_signal(dispatch_semaphore_t  _Nonnull dsema)</code></p><p>执行完操作后调用，将信号量 + 1。</p></li><li><pre><code class="objective-c">NSMutableArray *array = [[NSMutableArray alloc] init];dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);for (int i = 0; i &lt; 100; i++) &#123;    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 信号量是0时等待，非0时，经过dispatch_semaphore_wait函数后信号量-1，其他线程等待        [array addObject:[NSNumber numberWithInteger:i]];        NSLog(@&quot;%d---%ld---%@&quot;, i, array.count, [NSThread currentThread]);        dispatch_semaphore_signal(semaphore); // 信号量+1    &#125;);&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- NSLock</span><br><span class="line"></span><br><span class="line">  - 通过 &#96;- (void)lock &#96;和 &#96;- (void)unlock &#96;配对使用实现代码的锁定，只能执行被锁定的代码。需要使用相同的锁对象才能实现互斥。</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;objective-c</span><br><span class="line">    &#x2F;&#x2F; 实例类person</span><br><span class="line">    Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 创建锁</span><br><span class="line">    NSLock *myLock &#x3D; [[NSLock alloc] init];</span><br><span class="line">    &#x2F;&#x2F; 线程A</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];&#x2F;&#x2F; 锁定</span><br><span class="line">        [person personA];</span><br><span class="line">        [NSThread sleepForTimeInterval:5];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; 线程B</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [myLock lock];  &#x2F;&#x2F; 锁定</span><br><span class="line">        [person personB];</span><br><span class="line">        [myLock unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></code></pre></li><li><p><code>- (BOOL)tryLock</code>：尝试锁定，如果加锁失败（已经被锁定）返回NO，不会阻塞线程。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p><p><code>- (BOOL)lockBeforeDate:(NSDate *)limit</code>：在date时间之前尝试锁定，如果在date时间内都不能完成锁定，返回NO。如果成功，同 <code>-lock</code>效果一样，用 <code>-unlock</code> 解锁。</p></li></ul></li><li><p>NSCondition：最基本的条件锁，手动控制线程 wait（等待）和 signal （继续）</p><ul><li><p><code>[condition lock]</code> 锁定代码，其他线程的命令需要在lock 外等待，只到unlock ，才可访问。</p></li><li><p><code>[condition unlock</code> 与lock 同时使用。</p></li><li><p><code>[condition wait]</code> 让当前线程处于等待状态。</p></li><li><p><code>[condition signal]</code> CPU发信号告诉线程不用在等待，可以继续执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NSCondition *condition &#x3D; [[NSCondition alloc] init];</span><br><span class="line"></span><br><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        if ([products count] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            NSLog(@&quot;wait for product&quot;);</span><br><span class="line">            [condition wait];  &#x2F;&#x2F; 线程等待</span><br><span class="line">        &#125;</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [condition lock];</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [condition signal];  &#x2F;&#x2F; 恢复线程</span><br><span class="line">        [condition unlock];  &#x2F;&#x2F; 解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p></li></ul></li><li><p>NSConditionLock：条件锁，可以设置加锁/解锁条件，只有满足条件时才能加锁/解锁。</p><ul><li><p><code>- (void)lockWhenCondition:(NSInteger)condition</code> 满足条件时才能加锁。</p></li><li><p><code>- (void)unlockWithCondition:(NSInteger)condition</code> 满足条件时才能解锁。</p></li><li><p><code>- (BOOL)tryLockWhenCondition:(NSInteger)condition</code> 满足条件尝试加锁。</p></li><li><p><code>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit</code> 满足条件在limit时间内尝试加锁。</p></li><li><p>同时 NSLock 的相关方法依旧能够使用，可以使用 <code>- lock</code>  和 <code>- unlock</code> 方法加锁或解锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *products &#x3D; [NSMutableArray array];</span><br><span class="line">NSInteger HAS_DATA &#x3D; 1;</span><br><span class="line">NSInteger NO_DATA &#x3D; 0;</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        [lock lockWhenCondition:NO_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products addObject:[[NSObject alloc] init]];</span><br><span class="line">        NSLog(@&quot;produce a product,总量:%zi&quot;,products.count);</span><br><span class="line">        [lock unlockWithCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        NSLog(@&quot;wait for product&quot;);</span><br><span class="line">        [lock lockWhenCondition:HAS_DATA];  &#x2F;&#x2F; 满足条件加锁</span><br><span class="line">        [products removeObjectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;custome a product&quot;);</span><br><span class="line">        [lock unlockWithCondition:NO_DATA];  &#x2F;&#x2F; 满足条件解锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>NSRecursiveLock：递归锁，这个锁可以被同一线程多次使用，而不会引起死锁。主要用在循环及递归操作中。递归锁会跟踪它被 lock 的次数。每次成功的 lock 都必须平衡调用 unlock 操作。只有这样锁才会被最终释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;NSLock *lock &#x3D; [[NSLock alloc] init];</span><br><span class="line">NSRecursiveLock *lock &#x3D; [[NSRecursiveLock alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    static void (^RecursiveMethod)(int);</span><br><span class="line"></span><br><span class="line">    RecursiveMethod &#x3D; ^(int value) &#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        if (value &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;value &#x3D; %d&quot;, value);</span><br><span class="line">            sleep(1);</span><br><span class="line">            RecursiveMethod(value - 1);&#x2F;&#x2F; 递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        [lock unlock];</span><br><span class="line">    &#125;;</span><br><span class="line">    RecursiveMethod(5);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里如果把锁对象换为 NSLock 类型的话，从第二次递归调用开始会发生死锁。因为每次进入 block 都会加一把锁，从第二次开始因为已经加了锁并且没有解锁， 所以要等待解锁，造成了死锁，造成线程阻塞而 crash。如果换成 NSRecursiveLock 类就不会造成死锁。</p></li></ul><h4 id="8-atomic实现原理"><a href="#8-atomic实现原理" class="headerlink" title="8.atomic实现原理"></a>8.atomic实现原理</h4><p>atomic为原子属性，为setter方法加互斥锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(atomic, assign)int age;</span><br><span class="line">- (void)setAge:(int)age &#123;</span><br><span class="line">@synchronized(self)&#123;</span><br><span class="line">        _age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>atomic 和 nonatomic 比较</p><ul><li><p>atomic：线程安全（并非真正安全），需要消耗大量CPU资源。</p><p>例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。</p></li><li><p>nonatomic: 非线程安全，适合移动设备。</p></li></ul></li></ul><h4 id="9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？"><a href="#9-在主线程调用-dispatch-sync-自定义串行队列-不会发生死锁的原因？" class="headerlink" title="9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？"></a>9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？</h4><p><code>dispatch_sync()</code> 向<strong>当前线程</strong>中添加一个任务到指定队列</p><ul><li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列是同一个串行队列。串行队列中的任务是上一个任务执行完毕才会执行下一个任务。<code>dispatch_sync()</code>会将Block任务添加到队列尾部，等队列中所有任务执行完毕后才会执行；<code>dispatch_sync()</code> 需要Block任务执行完毕才会返回，造成互相等待。</p><p><strong>在追加Block执行结束之前，<code>dispach_sync</code> 会一直等待，等待意味着线程停止。</strong></p></li><li><p>如果指定队列同调用<code>dispatch_sync()</code> 的队列不是同一个队列。系统会在当前线程中新开一条指定队列，并加入Block任务到新开队列中，Block任务被执行并返回，然后<code>dispatch_sync()</code> 返回。指定队列无论是串行和并行的，在<code>dispatch_sync()</code> 所在队列中串行执行任务，因为<code>dispatch_sync()</code>  是阻塞的。</p></li><li><p><code>dispatch_async()</code> 新开线程执行任务，不等Block执行完毕就返回。</p></li></ul><h4 id="10-为什么使用atomic关键字的对象不一定是线程安全的？"><a href="#10-为什么使用atomic关键字的对象不一定是线程安全的？" class="headerlink" title="10.为什么使用atomic关键字的对象不一定是线程安全的？"></a>10.为什么使用atomic关键字的对象不一定是线程安全的？</h4><p>使用atomic只能保证 setter 方法和 getter 方法是线程安全的。但是仍然可能出现线程不安全的情况：</p><p><code>@property(atomic, strong)NSMutableArray *array</code>一个线程循环读数据，另一个线程循环存数据，这时就不是线程安全的，因为跟 setter 和 getter 方法没有关系。比如使用<code>[array addObject:object]</code>向数组中添加对象，因为不涉及到 setter 和 getter 方法，故不是线程安全的。</p><ul><li><p>多线程数据为什么不安全？</p><p>每条线程都有自己独立的栈空间，但是它们公用堆空间，所以可能同时访问同一块内存空间，因此造成数据竞争。</p></li></ul><h3 id="三、UI"><a href="#三、UI" class="headerlink" title="三、UI"></a>三、UI</h3><h4 id="1-UITableView优化"><a href="#1-UITableView优化" class="headerlink" title="1.UITableView优化"></a>1.UITableView优化</h4><ol><li><p>使用 UITableViewCell 重用机制。</p></li><li><p>利用 RunLoop 空闲时间执行预缓存任务。</p><p>利用 RunLoopObserver 观察当前 RunLoop 的运行状态，并在状态切换时收到通知。</p><p>在 RunLoop 即将进入睡眠时使用。</p></li><li><p>将预缓存任务分解到多个 RunLoop 中执行。</p></li></ol><h4 id="2-UITableViewCell重用机制的原因和原理是什么？"><a href="#2-UITableViewCell重用机制的原因和原理是什么？" class="headerlink" title="2.UITableViewCell重用机制的原因和原理是什么？"></a>2.UITableViewCell重用机制的原因和原理是什么？</h4><ul><li><p>关键：</p><ul><li>==可变数组<code>NSMutableArray *visiableCells</code>  保存屏幕正在显示的cell。==</li><li>==可变字典<code>NSMutableDictionary *reusableTableCells</code> 保存可重复利用的cell, key是重用标识identifier。==</li><li>==<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 从<code>reusableTableCells</code>中根据identifier取可被重用的cell。==</li></ul></li><li><p>原因：设备内存有限，TableView中有许多cell，而屏幕只能显示有限个cell，如果根据数据将cell全部创建完毕，会造成很大的内存负担。屏幕外的cell不需要立即创建，当滑动屏幕浏览cell时再加载。</p></li><li><p>作用：<strong>只创建了屏幕可显示的最大cell数+1个cell</strong>，然后循环使用这些cell，同时改变cell显示的数据，达到节省空间的目的。</p></li><li><p>原理：</p><ul><li><p>第一次执行<code>-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</code> 方式时，<code>reusableTableCells</code>为空，<code>[tableView dequeueReusableCellWithIdentifier:idertifier forIdentifiter:identifiter]</code> 方法的返回值为nil。</p><p>此时通过<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifier:identifier]</code> 创建新的cell。</p></li><li><p>当数据很多，整个屏幕的cell显示不完全时</p><ol><li>调用<code>[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifiter:identifier]</code> <strong>创建整个屏幕能显示的cell个数+1个cell</strong>（滑动屏幕时，第一个cell还没移出，最后一个cell已经出现），并且制定标识符identifier。</li><li>将创建并显示除最后一个外的cell加入<code>visiableCells</code> 数组，此时<code>reusableTableCells</code>字典为空。</li><li>滑动屏幕时，顶端的cell移出屏幕，该cell从<code>visiableCells</code> 数组中移除，并加入到<code>reusableTableCells</code> 字典中，key为该cell的identifier。将最后一个cell加入到<code>visiableCells</code> 数组中。</li><li>继续滑动时，<code>reusableTableCells</code> 中已经有值。需要显示新的cell时，<code>cellForRowAtIndexPath</code> 再次被调用，执行<code>[tableView dequeueReusableCellWithIdentifier:identifier]</code> 方法，返回一个标识为identifier的cell。该cell从<code>reusableTableCells</code> 中移除，添加到<code>visableCells</code> 中，如果<code>resuableTableCells</code> 中没有identifier类型的cell，就会创建一个；同时，移出屏幕的cell从<code>visiableCells</code> 中移除，添加到<code>resuableTableCells</code> 中。</li></ol></li><li><p>iOS6中新方法</p><p><code>[self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier]</code></p><p>当从<code>reusableTableCells</code> 中取cell时，如果没有，系统会自动创建给定类型的cell；如果有，直接重用。</p><p>在<code>cellForRowAtIndexPath</code> 中只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (UITableViewCell *)table:(UITableView *)tableView cellForRowAtIdexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">  &#x2F;&#x2F; 系统会自动判断cell是否存在，不需要手动判断。</span><br><span class="line">    UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifiter:identifiter forIndexPath:indexPath];</span><br><span class="line">  return cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-怎样裁剪圆头像"><a href="#3-怎样裁剪圆头像" class="headerlink" title="3.怎样裁剪圆头像"></a>3.怎样裁剪圆头像</h4><h4 id="4-自定义控件的封装"><a href="#4-自定义控件的封装" class="headerlink" title="4.自定义控件的封装"></a>4.自定义控件的封装</h4><h4 id="5-viewController生命周期"><a href="#5-viewController生命周期" class="headerlink" title="5.viewController生命周期"></a>5.viewController生命周期</h4><p><img src="http://img.blog.csdn.net/20130614155652265" alt="viewController声明周期"></p><ol><li><code>viewWillAppear</code> 之后，<code>viewDidAppear</code> 之前会调用 <code>viewWillLayoutSubviews</code> 和<code>viewDidLayoutSubviews</code> ，可以修改subviews。</li><li><code>-loadView</code> 中初始化view, 由系统调用，==在 viewController 的 view 被访问并且为nil时调用==（<code>self.view = …</code>），可能被调用多次。</li></ol><h4 id="6-改变UIButton的点击面积"><a href="#6-改变UIButton的点击面积" class="headerlink" title="6.改变UIButton的点击面积"></a>6.改变UIButton的点击面积</h4><p>重写<code>UIButton</code>的<code>-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event</code>方法。</p><p>该方法返回<code>BOOL</code>值表示判断当前的点击或触摸事件是否在当前的UIView中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@inplementation NewButton</span><br><span class="line"></span><br><span class="line">-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">CGRect bounds &#x3D; self.bounds;</span><br><span class="line">bounds &#x3D; CGRectInset(bounds, -50, -50);  &#x2F;&#x2F; 该按钮上下左右范围各扩大了50.</span><br><span class="line">return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><code>bounds = CGRectInset(bounds, -50, -50)</code> 后两个参数是在左右方向和上下方向扩大或缩小的长度，正值表示缩小，负值表示扩大。该行代码表示在水平和竖直方向各扩大了100。</p><p>苹果要求：点击的热点区域不小于44*44 pt。</p><h4 id="7-UIView、UIButton-、UITableView的继承关系"><a href="#7-UIView、UIButton-、UITableView的继承关系" class="headerlink" title="7.UIView、UIButton 、UITableView的继承关系?"></a>7.UIView、UIButton 、UITableView的继承关系?</h4><p>UIView -&gt; UIResponder -&gt; NSObject</p><p>UIButton -&gt; UIControl -&gt; UIView - &gt; UIResponder -&gt; NSObject</p><p>UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject</p><h3 id="四、设计模式"><a href="#四、设计模式" class="headerlink" title="四、设计模式"></a>四、设计模式</h3><h4 id="1-KVO的原理？"><a href="#1-KVO的原理？" class="headerlink" title="1.KVO的原理？"></a>1.KVO的原理？</h4><p>KVO的实现依赖于Runtime，使用isa混写（isa-swizzling）实现。当观察对象A时，KVO机制动态的创建对象A当前类的子类，并为这个新类重写了被观察属性的setter方法，在setter方法中通知观察对象属性的改变情况。将对象A的isa指针的指向修改为创建的新类。</p><ul><li><p>具体实现</p><ul><li><p>当观察对象A时，KVO机制<strong>动态地创建一个名为<code>NSKVONotifying_A</code>的新类</strong>，该类继承自对象A原来的类，并<strong>重写了被观察属性值的setter方法</strong>。重写的setter方法负责在调用原setter方法<strong>之前</strong>和<strong>之后</strong>，通知所有观察对象：属性值得更改。最后通过<strong>isa混写（isa-swizzling）</strong>把这个对象的isa指针指向新创建的子类，对象变成了新创建子类的实例。</p></li><li><p>setter方法剖析：</p><p>KVO依赖于两个方法<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code>，在原setter方法之前和之后分别调用。重写setter方法的注入是在<strong>运行时</strong>而不是在编译时。</p><ul><li><code>-willChangeValueForKey:</code>在<strong>属性值发生改变之前</strong>即原setter方法之前调用，通知keyPath属性值即将发生改变。</li><li><code>-didChangeValueForKey:</code>在<strong>属性值发生改变之后</strong>即原setter方法之后调用，通知keyPath属性值已经发生改变。</li><li>之后<code>-observerValueForKeyPath:ofObject:change:context</code>也会被调用</li></ul></li><li><pre><code class="objective-c">- (void)setName:(NSString *)newName &#123;    [self willChangeValueForKey:@&quot;name&quot;];      [super setValue:newName forKey:@&quot;name&quot;];    // 调用父类的存取方法,KVC实现      [self didChangeValueForKey:@&quot;name&quot;];&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用前提</span><br><span class="line"></span><br><span class="line">  KVO被观察的是对象属性，只有__通过setter方法__或__KVC方法__修改对象属性时KVO才能被触发，使用KVO机制的__*前提是遵循KVO的属性设置方式来变更属性值*__。</span><br><span class="line"></span><br><span class="line">#### 2.手写KVO观察对象过程：</span><br><span class="line"></span><br><span class="line">1. 为__观察的对象__注册观察者</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;objective-c</span><br><span class="line">   &#x2F;* 第一个参数：观察者，负责处理监听事件的对象</span><br><span class="line">      第二个参数：被观察的属性</span><br><span class="line">      第三个参数：被观察属性新旧值得一些配置</span><br><span class="line">      第四个参数：上下文，可以为KVO回调方法传值 *&#x2F;</span><br><span class="line">   [self.person addObserver:self </span><br><span class="line">      forKeyPath:@&quot;name&quot; </span><br><span class="line">                    options:NSKeyValueObservingOptionNew |</span><br><span class="line">                            NSKeyValueObservingOptionOld </span><br><span class="line">                    context:nil];</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><ol start="2"><li><p>被观察的属性发生变化时，收到通知，调用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 第一个参数：被观察的属性</span><br><span class="line">   第二个参数：被观察的对象</span><br><span class="line">   第三个参数：改变的属性值，前后的变化都存在字典中</span><br><span class="line">   第四个参数：上下文，context传递的值 *&#x2F;</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath object:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if([keyPath isEqualToString:@&quot;name&quot;] &amp;&amp; object &#x3D;&#x3D; self.person) &#123;</span><br><span class="line">        &#x2F;&#x2F; 响应变化处理</span><br><span class="line">      NSLog(@&quot;new:%@, old:%@&quot;, [change valueForkey:@&quot;old&quot;], [change valueForKey:@&quot;new&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>-dealloc</code>方法中注销观察者 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-怎样手动触发KVO？"><a href="#3-怎样手动触发KVO？" class="headerlink" title="3. 怎样手动触发KVO？"></a>3. 怎样手动触发KVO？</h4><p>​    手动调用<code>-willChangeValueForKey:</code>和<code>-didChangeValueForKey:</code></p><p>​    场景：希望能控制”回调的调用时机时“（控制<code>-didiChangeValueForKey</code>调用）</p><h4 id="4-KVC中setValue-forKeyPath-复制过程？"><a href="#4-KVC中setValue-forKeyPath-复制过程？" class="headerlink" title="4.KVC中setValue: forKeyPath: 复制过程？"></a>4.KVC中<code>setValue: forKeyPath:</code> 复制过程？</h4><ol><li>调用 setter 方法。</li><li>如果没有对应的 setter 方法，判断是否有与 key 值同名的成员属性，如果有，直接赋值。</li><li>如果没有与 key 值同名的成员属性，判断是否有与 key 值同名带下划线的成员属性，如果有，直接赋值。</li><li>报错：找不到对应的成员属性。</li></ol><h4 id="5-对MVC的理解？"><a href="#5-对MVC的理解？" class="headerlink" title="5.对MVC的理解？"></a>5.对MVC的理解？</h4><h4 id="6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"><a href="#6-Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）" class="headerlink" title="6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）"></a>6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate）</h4><ul><li><p>delegate：一对一</p><ul><li>优点：<ol><li>语法严谨，所有收听到的事件都必须有清楚的定义。</li><li>delegate协议中的方法如果没有实现编译器会报错。</li><li>每个controller可以遵守多个协议，每个协议有不同的delegate。</li><li>能够接收调用协议的协议方法的返回值。delegate可以返回信息给controller。</li><li>没有第三方对象要求保持/监视通信过程。</li></ol></li><li>缺点：<ol><li>需要定义的代码多：协议的定义，controller的delegate属性，在delegate本身中实现delegate方法的定义。</li><li>释放代理对象的时候，需要将delegate改为nil，否则调用对象的方法会crash。</li></ol></li></ul></li><li><p>block：</p><ul><li><p>优点</p><p>代码量比delegate少，更轻型，使用方便。</p></li><li><p>缺点：</p><ol><li>需要注意循环引用的问题。</li><li>有多个方法时，假如每个方法设置一个block会更麻烦。</li></ol></li></ul></li><li><p>Notifaction：一对多</p><ul><li>优点：<ol><li>需要写的代码少。</li><li>一对多实现简单。</li><li>controller能传递context对象（NSDictionary），context对象携带了发送通知的自定义信息。</li></ol></li><li>缺点：<ol><li>编译期不会检查通知是否能被被观察者正确的处理。</li><li>释放注册的对象时，需要在通知中心取消注册。</li><li>需要第三方管理controller和观察者的关系。</li><li>通知发出后，发出通知的对象不能从观察者获得任何反馈。</li></ol></li></ul></li><li><p>KVO：可以一对多</p><ul><li>优点：<ol><li>能够提供观察的属性的新值和旧值。</li><li>通过keyPath观察属性，因此也可以嵌套对象。</li><li>能够对非我们创建的对象，即内部对象的状态改变做出相应，而且不需要改变内部对象的实现。</li><li>不需要额外的代码允许观察值能够被观察。</li></ol></li><li>缺点：<ol><li>被观察的属性必须用string定义，编译器不会对其进行检查，可能写错。</li><li>对属性的重构导致代码不可用。</li><li>所有的观察代码通过一个方法来指向，导致方法中复杂的if语句。</li><li>释放观察者时需要移除观察者。</li></ol></li></ul></li></ul><h3 id="五、网络请求"><a href="#五、网络请求" class="headerlink" title="五、网络请求"></a>五、网络请求</h3><h4 id="1-NSURLSession和NSURLConnection区别？"><a href="#1-NSURLSession和NSURLConnection区别？" class="headerlink" title="1.NSURLSession和NSURLConnection区别？"></a>1.NSURLSession和NSURLConnection区别？</h4><p>NSURLConnection从iOS 9废弃，NSURLSession在WWDC2013发布。</p><ul><li><p>普通任务和上传</p><p>NSURLSession 针对普通会话、上传、下载有三种不同的任务<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownnloadTask</code>。创建的会话都是挂起状态，需要<code>resume</code>才能启动。</p><ul><li>当服务器返回的数据较小时，<code>NSURLSession</code>和<code>NSURLConnection</code>执行普通任务的操作没有区别。</li><li>执行上传任务时，<code>NSURLSession</code>和<code>NSURLConnection</code>一样需要设置POST请求的<strong>请求体</strong>进行上传。</li></ul></li><li><p>请求方法的不同</p><ul><li><code>NSURLConnection</code>实例化对象，<ul><li>通过<code>-initWithRequest: delegate:</code>创建的请求被自动发送</li><li>通过<code>-initWithRequest: delegate: startImmediately:NO</code>创建的请求通过<code>[connect start]</code>发送请求，方法内部把connect对象作为一个source添加到当前线程的runloop的默认模式下执行。(如果runloop不存在会自动创建当前线程对应的runloop)</li></ul></li><li><code>NSURLSession</code>可以<code>cancel</code>(取消)、<code>suspend</code>(暂停)、<code>resume</code>(恢复)会话，暂停以后可以恢复继续请求。</li></ul></li><li><p>下载任务的方式不同</p><ul><li><code>NSURLConnection</code>下载文件时，<strong>先将文件下载到内存，再写入沙盒</strong>，如果文件比较大，会<strong>出现内存暴涨</strong>的情况。</li><li><code>NSURLSessionDownloadTask</code><ol><li>下载文件，<strong>默认下载到沙盒中的tem文件中</strong>，不会出现内存暴涨的情况。但是下载完成后会把tem中的临时文件删除，需要在<code>completionHandler</code>回调方法中将下载的文件移动到别的文件夹。</li><li>在代理方法中，能够方便地监听文件的下载进度。</li></ol></li></ul></li><li><p>断点续传方式不同（<code>NSURLSession</code>更加方便）</p><ul><li><code>NSURLConnection</code>实现断点续传需要通过设置请求头的<code>HTTPHeaderField</code>的range属性进行。</li><li><code>NSURLSessionDownloadTask</code>进行断点续传<ol><li>当Task暂停时，如果<code>downloadTask</code>非空，调用<code>-cancelByProducingResumeData:(void(^)(NSData *resumeData))completionHandler</code>接收<code>resumeData</code>参数，保存已下载文件。(注意block中的循环引用，定义self的属性_resumeData, <code>weakSelf.resumeData = resumeData</code>)</li><li>再次下载是，如果<code>self.resumeData != nil</code>那么调用<code>[[self.session downloadTaskWithResumeData:self.resumeData] rusume]</code>继续下载，否则创建会话和下载任务。</li></ol></li></ul></li><li><p><code>NSURLSession</code>可以设置配置信息Configuration。</p><ul><li><code>+(NSURLSession *)sessionWithConfiguration: delegate: delegateQueue:</code></li><li>可以设置缓存策略，是否在后台进行请求，最大主机连接数，网络超时等。</li></ul></li></ul><h4 id="2-AFN框架为什么封装NSURLSession？"><a href="#2-AFN框架为什么封装NSURLSession？" class="headerlink" title="2.AFN框架为什么封装NSURLSession？"></a>2.AFN框架为什么封装NSURLSession？</h4><h3 id="六、底层相关"><a href="#六、底层相关" class="headerlink" title="六、底层相关"></a>六、底层相关</h3><h4 id="1-iOS程序的加载过程是什么？"><a href="#1-iOS程序的加载过程是什么？" class="headerlink" title="1.iOS程序的加载过程是什么？"></a>1.iOS程序的加载过程是什么？</h4><ol><li>执行 <code>main</code> 函数。</li><li>执行 <code>UIApplicationMain</code> 函数。</li><li>创建 <code>UIApplication</code> 对象（是单例的）。</li><li>创建 <code>UIApplication</code> 的代理，并且设置 application 的代理。</li><li>开启 主<code>RunLoop</code>。</li><li>加载完毕后调用 <code>- application: didFinishLaunchingWithOptions:</code>。</li></ol><h4 id="2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？"><a href="#2-lt-UIApplicationDelegate-gt-中有哪些方法？有什么作用？" class="headerlink" title="2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？"></a>2.<code>&lt;UIApplicationDelegate&gt;</code> 中有哪些方法？有什么作用？</h4><ul><li><code>- application: didFinishLaunchingWithOptions:</code> 应用被加载完毕后被调用</li><li><code>- applicationWillResignActive:</code> 当应用即将变为不活动状态时调用，比如电话进入、退出应用程序或开始进入后台状态。</li><li><code>- applicationDidEnterBackground:</code> 当应用进入后台状态后调用。在后台状态中应用工作，但是不派发新的事件到响应器。</li><li><code>- applicationWillEnterForeground</code> 应用将要回到前台时调用。</li><li><code>- applicationDidBecomeActive:</code> 应用已经变为活动状态时调用。</li><li><code>- applicationWillTerminate:</code> 应用即将结束时调用。</li><li><code>- applicationDidReceiveMemoryWarning:</code> 收到内存警告时调用。</li></ul><h4 id="3-load-方法和-initialize-方法异同"><a href="#3-load-方法和-initialize-方法异同" class="headerlink" title="3.+load 方法和 +initialize 方法异同"></a>3.<code>+load</code> 方法和 <code>+initialize</code> 方法异同</h4><ul><li>相同：<ul><li>都在实例化对象==之前==调用。</li><li>内部都使用了锁，应该避免线程阻塞在方法中。</li></ul></li></ul><ul><li><p><code>+load</code> 方法</p><ul><li><p><code>+load</code> 方法在这个==文件被程序加载时==调用，程序启动时会调用<strong>所有</strong>类的<code>+load</code> 方法。与类的使用与否<strong>无关</strong>。</p></li><li><p><code>+load</code> 方法在<code>main</code>函数之==前==调用。</p></li><li><p>先调用父类的 <code>+load</code> 方法，再调用子类的 <code>+load</code> 方法。自动完成。</p><p>如果一个子类没有实现 <code>+load</code> 方法，那么也就<strong>不会</strong>调用父类的<code>+load</code> 方法。</p></li><li><p>使用场景：在<code>+load</code>方法中实现 Method swizzle。</p></li></ul></li><li><p><code>+initialize</code> 方法</p><ul><li><p>当第一次给一个类发送消息时，它的<code>+initiallze</code>方法会被调用。<strong><em>只会调用一次</em></strong>。</p><p>如果一个类一直没有被使用，它的<code>+initialize</code>方法不会被调用。</p></li><li><p>在<code>main</code>函数之==后==被调用。</p></li><li><p>先调用父类的<code>+initialize</code>方法，再调用子类的<code>+initialize</code>方法。</p><p>如果子类没有实现<code>+initialize</code>方法没有被实现，父类的<code>+initialize</code>方法也会被调用。</p></li><li><p>使用场景：初始化全局变量或静态变量。</p></li></ul></li></ul><h4 id="4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？"><a href="#4-消息转发，-objc-msgForward函数是做什么的？直接调用会发生什么？" class="headerlink" title="4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？"></a>4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？</h4><blockquote><ul><li><code>_objc_msgForward</code>是 IMP 类型(一个函数指针)，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，<code>_objc_msgForward</code>会尝试做消息转发。</li></ul></blockquote><p>IMP: 指向方法实现开头的指针。</p><ul><li>我们可以这样创建一个<code>_objc_msgForward</code>对象：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMP msgForwardIMP &#x3D; _objc_msgForward;</span><br></pre></td></tr></table></figure><ul><li><p><code>objc_msgSend</code>在“消息传递”中的作用：</p><p>在“消息传递”过程中，<code>objc_msgSend</code>的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用<code>_objc_msgForward</code>函数指针代替 IMP 。最后，执行这个 IMP 。</p></li><li><p>消息转发过程：</p><ol><li>调用<code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始<code>objc_msgSend</code>流程。这一次对象会响应这个选择器，一般是因为它已经调用过<code>class_addMethod</code>。如果仍没实现，继续下面的动作。</li><li>调用<code>forwardingTargetForSelector:</code>方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。</li><li>调用<code>methodSignatureForSelector:</code>方法，尝试获得一个方法签名。如果获取不到，则直接调用<code>doesNotRecognizeSelector</code>抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给<code>forwardInvocation:</code>。</li><li>调用<code>forwardInvocation:</code>方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。</li><li>调用<code>doesNotRecognizeSelector:</code> ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。</li></ol><ul><li>最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。</li></ul></li></ul><ul><li><code>_objc_msgForward</code>在进行消息转发的过程中会涉及以下这几个方法：<ol><li><code>resolveInstanceMethod:</code>方法 (或 <code>resolveClassMethod:</code>)。</li><li><code>forwardingTargetForSelector:</code>方法</li><li><code>methodSignatureForSelector:</code>方法</li><li><code>forwardInvocation:</code>方法</li><li><code>doesNotRecognizeSelector:</code> 方法</li></ol></li></ul><ul><li><p>直接调用<code>_objc_msgForward</code>是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。</p><p>一旦调用<code>_objc_msgForward</code>，将跳过查找 IMP 的过程，直接触发“消息转发”，</p><p>如果调用了<code>_objc_msgForward</code>，即使这个对象确实已经实现了这个方法，你也会告诉<code>objc_msgSend</code>：</p><blockquote><p>“我没有在这个对象里找到这个方法的实现”</p></blockquote><p>有哪些场景需要直接调用<code>_objc_msgForward</code>？最常见的场景是：你想获取某方法所对应的<code>NSInvocation</code>对象。</p></li></ul><h4 id="5-block为什么能够-block-在内部修改-blcok-外部变量？"><a href="#5-block为什么能够-block-在内部修改-blcok-外部变量？" class="headerlink" title="5.__block为什么能够 block 在内部修改 blcok 外部变量？"></a>5.<code>__block</code>为什么能够 block 在内部修改 blcok 外部变量？</h4><blockquote><p>我们都知道：<strong>Block不允许修改外部变量的值</strong>，这里所说的==<strong>外部变量的值，指的是栈中指针的内存地址</strong>。==<code>__block</code> 所起到的作用就是只要观察到该变量被 block 所持有，就<strong>将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</strong></p></blockquote><p>block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址</p><p> 变量在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 <code>__block</code> 关键字的真正作用。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="1-访问域名和访问IP地址的区别？"><a href="#1-访问域名和访问IP地址的区别？" class="headerlink" title="1.访问域名和访问IP地址的区别？"></a>1.访问域名和访问IP地址的区别？</h4><ul><li>IP地址是服务器的物理地址，一台服务器可能对应多个网站，访问IP地址可能不知道要访问哪个。</li><li>一个域名可能对应多个IP地址，通过域名访问自动选择速度最快的建立连接。</li></ul><h4 id="2-访问www-xxx-com的过程？"><a href="#2-访问www-xxx-com的过程？" class="headerlink" title="2.访问www.xxx.com的过程？"></a>2.访问<a href="http://www.xxx.com的过程？">www.xxx.com的过程？</a></h4><ol><li><p>首先找本机的HOSTS文件，映射为IP地址或客户端向 DNS 服务器请求解析该 URL 中域名对应的 IP 地址。<strong>(域名解析)</strong></p></li><li><p>根据 IP 地址和端口，客户端同服务器建立连接。<strong>(建立连接)</strong></p></li><li><p>客户端向服务器发送请求。<strong>(发送请求)</strong></p><p>该请求报文作为 TCP 三次握手第三个报文的数据发送给服务器。</p></li><li><p>服务器对请求做出响应，并把对应的数据发送给客户端。<strong>(作出相应)</strong></p></li><li><p>释放 TCP 连接。<strong>(释放连接)</strong></p></li><li><p>客户端对响应数据进行解析、处理。<strong>(解析数据)</strong></p></li></ol><h4 id="3-GET和POST请求的区别？POST一定安全么？"><a href="#3-GET和POST请求的区别？POST一定安全么？" class="headerlink" title="3.GET和POST请求的区别？POST一定安全么？"></a>3.GET和POST请求的区别？POST一定安全么？</h4><ul><li>请求形式<ul><li>GET 请求：请求的数据附在 URL 之后（数据在请求头中）。以？分割URL和传输数据，多个参数用&amp;相连。</li><li>POST 请求：请求的数据封装在请求体中。</li></ul></li><li>安全性<ul><li>GET 请求：请求的数据在地址栏中显示。</li><li>POST 请求：请求的数据虽然在请求体中，但也不安全，需要加密。</li></ul></li><li>传输数据的大小<ul><li>GET 请求：传输数据受URL长度限制，特定浏览器和服务器对URL的长度有限制。</li><li>POST 请求：理论上不受限制，实际服务器会对 POST 请求提交的数据大小进行限制。</li></ul></li><li>获取变量值的方式<ul><li>GET 请求：Request QueryString</li><li>POST 请求：Request Form</li></ul></li></ul><h4 id="4-HTTPS安全协议请求过程-HTTPS握手-是什么？"><a href="#4-HTTPS安全协议请求过程-HTTPS握手-是什么？" class="headerlink" title="4.HTTPS安全协议请求过程(HTTPS握手)是什么？"></a>4.HTTPS安全协议请求过程(HTTPS握手)是什么？</h4><p><img src="http://upload-images.jianshu.io/upload_images/449687-4e2ec739a1487779?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTTPS通信过程"></p><ul><li><p><strong>涉及密钥：</strong></p><p>对称加密密钥A 。</p><p>用于加密密钥A的非对称密钥B。公钥发送给客户端，私钥服务器持有。</p><p>用于加密密钥B公钥的CA证书密钥C。公钥保存在浏览器或系统中，私钥服务器持有。</p></li><li><p>请求过程(HTTPS握手)：</p><ol><li><p>客户端发送HTTPS请求，请求对称加密公钥B。</p></li><li><p>服务器响应客户端请求，发送CA数字证书。</p><p>证书中包括：密钥B的公钥，域名，服务器信息，数字签名，数字摘要算法等信息。</p></li><li><p>客户端验证CA数字证书的正确性。</p><ul><li>验证域名的正确性，比较CA证书中的域名和请求域名，可以验证证书是否是服务器发送的。</li><li>验证CA证书中数字签名，可以验证CA证书是否被第三方篡改。</li></ul></li><li><p>客户端用CA证书的公钥对密文解密，得到密钥B的公钥。</p></li><li><p>客户端生成密钥A，用密钥B的公钥进行加密，发送给服务器。</p></li><li><p>服务器用密钥B的私钥对密文进行解密，得到密钥A。</p></li><li><p>安全连接建立完成，双方用密钥A对信息进行对称加密传输。</p></li></ol></li><li><p>HTTPS加密在传输层</p><p>HTTPS报文在包装成TCP报文的时候完成加密过程，报文的header和body都会被加密。</p></li></ul><h4 id="5-HTTPS作用？"><a href="#5-HTTPS作用？" class="headerlink" title="5.HTTPS作用？"></a>5.HTTPS作用？</h4><ul><li>内容加密：建立一个信息安全通道，来保证数据传输的安全。</li><li>身份认证：认证用户或服务器，确保数据发送到正确的客户或服务器。</li><li>数据完整性：防止内容被第三方冒充或篡改。（原因：数字摘要）</li></ul><h4 id="6-HTTP和HTTPS区别？"><a href="#6-HTTP和HTTPS区别？" class="headerlink" title="6.HTTP和HTTPS区别？"></a>6.HTTP和HTTPS区别？</h4><ul><li><p>HTTPS需要到CA申请证书或自制证书。</p></li><li><p>HTTP直接进行明文传输。</p><p>HTTPS先经过具有安全性的SSL/TSL（表示层）加密，再传输密文。</p></li><li><p>HTTP端口：80。</p><p>HTTPS端口：443。</p></li></ul><h4 id="7-数字证书作用？"><a href="#7-数字证书作用？" class="headerlink" title="7.数字证书作用？"></a>7.数字证书作用？</h4><ul><li><p>确定得到公钥的正确性</p></li><li><p>确定目标主机的正确性</p><p>​</p></li><li><p>数字证书包括：</p><ul><li>用户个人信息、公钥信息、颁发机构名称、证书本身的数字签名、证书数字签名用的HASH算法。</li></ul></li></ul><h4 id="8-数字签名"><a href="#8-数字签名" class="headerlink" title="8.数字签名"></a>8.数字签名</h4><ul><li>数字签名 = 非对称加密 + 数字摘要</li><li>数字签名验证数据完整性过程：<ul><li>将摘要信息用发送者私钥加密后，与原文一起传送给接受者。<strong>(摘要+原文)</strong></li><li>接受者用发送者的公钥将被加密的摘要解密。<strong>(解密)</strong></li><li>接受者用与发送者相同的HASH算法对接收到的明文产生一个摘要信息。<strong>(产生摘要)</strong></li><li>将产生的摘要与解密得到的摘要进行对比，如果相同，则数据没有被修改。<strong>(比较摘要)</strong></li></ul></li></ul><h4 id="9-请求报文包括哪些？请求体和请求报文的关系？"><a href="#9-请求报文包括哪些？请求体和请求报文的关系？" class="headerlink" title="9.请求报文包括哪些？请求体和请求报文的关系？"></a>9.请求报文包括哪些？请求体和请求报文的关系？</h4><p>请求报文包括：请求行、请求头、空行、请求体。</p><p>请求报文包括请求体。</p><p>响应报文包括：状态行、响应头、空行，响应体。</p><h4 id="10-UDP和TCP的区别？"><a href="#10-UDP和TCP的区别？" class="headerlink" title="10.UDP和TCP的区别？"></a>10.UDP和TCP的区别？</h4><ul><li><p>TCP：面向连接，三次握手最低限度保证连接可靠性</p><p>UDP：无连接，传送数据前无需建立连接，数据到达后也无需确认。（发送端不知道数据是否到达接收端，也不知道数据是否被正确接受）</p></li><li><p>TCP：可靠交付。</p><p>UDP：不可靠交付。</p></li><li><p>TCP：报文头部长，传输开销大</p><p>UDP：报文头部短，传输开销小，时延较短，实用性更好。</p></li></ul><h4 id="11-TCP三次握手和四次挥手过程"><a href="#11-TCP三次握手和四次挥手过程" class="headerlink" title="11.TCP三次握手和四次挥手过程"></a>11.TCP三次握手和四次挥手过程</h4><ul><li><p>三次握手</p><p><img src="http://upload-images.jianshu.io/upload_images/1641067-8d52ca990ffbee0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三次握手"></p></li><li><p>四次挥手</p><p><img src="http://upload-images.jianshu.io/upload_images/1641067-5ed8bf6c24244b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="四次挥手"></p></li></ul><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><h4 id="1-strstr函数是什么？"><a href="#1-strstr函数是什么？" class="headerlink" title="1.strstr函数是什么？"></a>1.strstr函数是什么？</h4><h4 id="2-free-函数做了什么？"><a href="#2-free-函数做了什么？" class="headerlink" title="2.free() 函数做了什么？"></a>2.free() 函数做了什么？</h4><h4 id="3-strcpy和strnpy函数的区别？"><a href="#3-strcpy和strnpy函数的区别？" class="headerlink" title="3.strcpy和strnpy函数的区别？"></a>3.strcpy和strnpy函数的区别？</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swift3.0_协议(Protocal)和扩展(Extension)</title>
      <link href="2017-03-20/swift3-0-Protocol-And-Eextension/"/>
      <url>2017-03-20/swift3-0-Protocol-And-Eextension/</url>
      
        <content type="html"><![CDATA[<h2 id="协议-Protocal"><a href="#协议-Protocal" class="headerlink" title="协议(Protocal"></a>协议(Protocal</h2><h4 id="使用protocol-来声明一个协议。"><a href="#使用protocol-来声明一个协议。" class="headerlink" title="使用protocol 来声明一个协议。"></a>使用protocol 来声明一个协议。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ExampleProtocal&#123;</span><br><span class="line">    var simpleDesp:String&#123;get&#125;</span><br><span class="line">    mutating func adjust()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="类、枚举和结构体都可以实现协议。"><a href="#类、枚举和结构体都可以实现协议。" class="headerlink" title="类、枚举和结构体都可以实现协议。"></a>类、枚举和结构体都可以实现协议。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SimpleClass: ExampleProtocal&#123;</span><br><span class="line">    var simpleDesp: String &#x3D; &quot;A simple class&quot;</span><br><span class="line">    var anotherProperty:Int &#x3D; 45621</span><br><span class="line">    func adjust() &#123;</span><br><span class="line">        simpleDesp +&#x3D; &quot; NO 100% adjusted&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注意声明SimpleStructure-时候mutating-关键字用来标记一个会修改结构体的方法。SimpleClass-的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。"><a href="#注意声明SimpleStructure-时候mutating-关键字用来标记一个会修改结构体的方法。SimpleClass-的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。" class="headerlink" title="注意声明SimpleStructure 时候mutating 关键字用来标记一个会修改结构体的方法。SimpleClass 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。"></a>注意声明SimpleStructure 时候mutating 关键字用来标记一个会修改结构体的方法。SimpleClass 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。</h5><h2 id="使用extension"><a href="#使用extension" class="headerlink" title="使用extension"></a>使用extension</h2><h4 id="来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。"><a href="#来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。" class="headerlink" title="来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。"></a>来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var simple &#x3D; SimpleClass()</span><br><span class="line">simple.adjust()</span><br><span class="line"></span><br><span class="line">let aDesp &#x3D; simple.simpleDesp</span><br><span class="line"></span><br><span class="line">struct SimpleStructure:ExampleProtocal&#123;</span><br><span class="line">    var simpleDesp: String &#x3D; &quot;A simple structure&quot;</span><br><span class="line">    mutating func adjust() &#123;</span><br><span class="line">        simpleDesp +&#x3D; &quot;(adjusted)&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; SimpleStructure()</span><br><span class="line">b.adjust()</span><br><span class="line">let bDesp &#x3D; b.simpleDesp</span><br><span class="line"></span><br><span class="line">extension Int:ExampleProtocal &#123;</span><br><span class="line">    var simpleDesp :String &#123;</span><br><span class="line">        return &quot;The number\(self)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func adjust() &#123;</span><br><span class="line">        self +&#x3D; 42</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(7.simpleDesp)</span><br></pre></td></tr></table></figure><h4 id="你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。"><a href="#你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。" class="headerlink" title="你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。"></a>你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let protocolValue : ExampleProtocal &#x3D; simple</span><br><span class="line">print(protocolValue.simpleDesp)</span><br><span class="line">&#x2F;&#x2F;print(protocolValue.anotherProperty) &#x2F;&#x2F; 去掉注释可以看到错误</span><br></pre></td></tr></table></figure><h4 id="即使protocolValue-变量运行时的类型是simpleClass-，编译器会把它的类型当做ExampleProtocol-。这表示你不能调用类在它实现的协议之外实现的方法或者属性。"><a href="#即使protocolValue-变量运行时的类型是simpleClass-，编译器会把它的类型当做ExampleProtocol-。这表示你不能调用类在它实现的协议之外实现的方法或者属性。" class="headerlink" title="即使protocolValue 变量运行时的类型是simpleClass ，编译器会把它的类型当做ExampleProtocol 。这表示你不能调用类在它实现的协议之外实现的方法或者属性。"></a>即使protocolValue 变量运行时的类型是simpleClass ，编译器会把它的类型当做ExampleProtocol 。这表示你不能调用类在它实现的协议之外实现的方法或者属性。</h4>]]></content>
      
      
      <categories>
          
          <category> swift3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift3.0_类和对象</title>
      <link href="2017-03-19/swift3-0-Class-And-Object-study/"/>
      <url>2017-03-19/swift3-0-Class-And-Object-study/</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h3 id="和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。"><a href="#和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。" class="headerlink" title="和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。"></a>和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。</h3><span id="more"></span><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">    var numberOfSize &#x3D; 0</span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">      return&quot;A shape with \(numberOfSize) sides.&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func simpleDescription(str:String) -&gt; String &#123;</span><br><span class="line">        return&quot;A shape with \(numberOfSize) sides.&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。"><a href="#要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。" class="headerlink" title="要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。"></a>要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var shape &#x3D; Shape()</span><br><span class="line">shape.numberOfSize &#x3D; 7</span><br><span class="line">var shapeDescription &#x3D; shape.simpleDescription()</span><br><span class="line">class NameShape&#123;</span><br><span class="line">    var numberOfSides:Int &#x3D; 0</span><br><span class="line">    var name:String</span><br><span class="line">    init(name:String) &#123;</span><br><span class="line">        self.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return&quot;A shape with \(numberOfSides)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意self-被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides-）还是通过构造器（就像name-）。-如果你需要在删除对象之前进行一些清理工作，使用deinit-创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。"><a href="#注意self-被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides-）还是通过构造器（就像name-）。-如果你需要在删除对象之前进行一些清理工作，使用deinit-创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。" class="headerlink" title="注意self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides ）还是通过构造器（就像name ）。 如果你需要在删除对象之前进行一些清理工作，使用deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。"></a>注意self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides ）还是通过构造器（就像name ）。 如果你需要在删除对象之前进行一些清理工作，使用deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。</h3><h3 id="子类如果要重写父类的方法的话，需要用override-标记——如果没有添加override-就重写父类方法的话编译器会报错。编译器同样会检测override-标记的方法是否确实在父类中"><a href="#子类如果要重写父类的方法的话，需要用override-标记——如果没有添加override-就重写父类方法的话编译器会报错。编译器同样会检测override-标记的方法是否确实在父类中" class="headerlink" title="子类如果要重写父类的方法的话，需要用override 标记——如果没有添加override 就重写父类方法的话编译器会报错。编译器同样会检测override 标记的方法是否确实在父类中"></a>子类如果要重写父类的方法的话，需要用override 标记——如果没有添加override 就重写父类方法的话编译器会报错。编译器同样会检测override 标记的方法是否确实在父类中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Square:NameShape&#123;</span><br><span class="line"></span><br><span class="line">    var sideLength:Double &#x3D; 0.0;</span><br><span class="line"></span><br><span class="line">    init(sideLength:Double,name:String) &#123;</span><br><span class="line"></span><br><span class="line">        super.init(name: name)</span><br><span class="line">        self.sideLength &#x3D; sideLength</span><br><span class="line">        numberOfSides &#x3D; 4</span><br><span class="line">     &#125;</span><br><span class="line">    func area() -&gt; Double &#123;</span><br><span class="line">        return sideLength*sideLength</span><br><span class="line">    &#125;</span><br><span class="line">    override func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return &quot;A square with sides of length \(sideLength)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let test &#x3D; Square(sideLength: 5.2, name: &quot;my test square&quot;)</span><br><span class="line">test.area()</span><br><span class="line">test.simpleDescription()</span><br></pre></td></tr></table></figure><h3 id="除了储存简单的属性之外，属性可以有-getter-和-setter-。"><a href="#除了储存简单的属性之外，属性可以有-getter-和-setter-。" class="headerlink" title="除了储存简单的属性之外，属性可以有 getter 和 setter 。"></a>除了储存简单的属性之外，属性可以有 getter 和 setter 。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class EquilateralTriangle:NameShape&#123;</span><br><span class="line">    var sideLength: Double &#x3D; 0.0</span><br><span class="line">    init(sideLength:Double,name:String) &#123;</span><br><span class="line">        super.init(name: name)</span><br><span class="line">        self.sideLength &#x3D; sideLength;</span><br><span class="line">        numberOfSides &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">    var perimeter :Double&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return 3.0 * sideLength</span><br><span class="line">         &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            sideLength &#x3D; newValue&#x2F;3.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    override func simpleDescription() -&gt; String &#123;</span><br><span class="line">        return &quot;an equilateral triagle with sides of length \(sideLength).&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var triangle  &#x3D; EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)</span><br><span class="line">print(triangle.perimeter)</span><br><span class="line">triangle.perimeter &#x3D; 9.9</span><br><span class="line">print(triangle.sideLength)</span><br></pre></td></tr></table></figure><h3 id="在perimeter-的-setter-中，新值的名字是newValue-。你可以在set-之后显式的设置一个名字。注意EquilateralTriangle-类的构造器执行了三步："><a href="#在perimeter-的-setter-中，新值的名字是newValue-。你可以在set-之后显式的设置一个名字。注意EquilateralTriangle-类的构造器执行了三步：" class="headerlink" title="在perimeter 的 setter 中，新值的名字是newValue 。你可以在set 之后显式的设置一个名字。注意EquilateralTriangle 类的构造器执行了三步："></a>在perimeter 的 setter 中，新值的名字是newValue 。你可以在set 之后显式的设置一个名字。注意EquilateralTriangle 类的构造器执行了三步：</h3><ul><li><ol><li>设置子类声明的属性值</li></ol></li><li><ol start="2"><li>调用父类的构造器</li></ol></li><li><ol start="3"><li>改变父类定义的属性值。其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。<br>如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用willSet 和didSet 。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TriangleAndSquare &#123;</span><br><span class="line">    var triangle: EquilateralTriangle &#123;</span><br><span class="line">       willSet &#123;</span><br><span class="line">           square.sideLength &#x3D; newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var square:Square&#123;</span><br><span class="line">        willSet&#123;</span><br><span class="line">            triangle.sideLength &#x3D; newValue.sideLength</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(size:Double,name:String) &#123;</span><br><span class="line">        square &#x3D; Square(sideLength: size, name: name)</span><br><span class="line">        triangle &#x3D; EquilateralTriangle(sideLength: size, name: name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var triangleAndSquare &#x3D; TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)</span><br><span class="line">print(triangleAndSquare.square.sideLength)</span><br><span class="line">print(triangleAndSquare.triangle.sideLength)</span><br><span class="line">triangleAndSquare.square &#x3D; Square(sideLength: 50, name: &quot;larger square&quot;)</span><br><span class="line">print(triangleAndSquare.triangle.sideLength)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加-。如果-之前的值是nil-，-后面的东西都会被忽略，并且整个表达式返回nil-。否则，-之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。"><a href="#处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加-。如果-之前的值是nil-，-后面的东西都会被忽略，并且整个表达式返回nil-。否则，-之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。" class="headerlink" title="处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加? 。如果? 之前的值是nil ， ? 后面的东西都会被忽略，并且整个表达式返回nil 。否则， ? 之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。"></a>处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加? 。如果? 之前的值是nil ， ? 后面的东西都会被忽略，并且整个表达式返回nil 。否则， ? 之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let optionalSquare:Square? &#x3D; Square(sideLength: 2.5, name: &quot;optional Square&quot;)</span><br><span class="line"></span><br><span class="line">let sideLength &#x3D; optionalSquare?.sideLength</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> swift3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift3.0_枚举(Enum)和结构体(struct)</title>
      <link href="2017-03-19/swift3-0-Struct-and-Enum/"/>
      <url>2017-03-19/swift3-0-Struct-and-Enum/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举和结构体"><a href="#枚举和结构体" class="headerlink" title="枚举和结构体"></a>枚举和结构体</h1><h3 id="使用enum-来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。"><a href="#使用enum-来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。" class="headerlink" title="使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。"></a>使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。</h3><span id="more"></span><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Rank: Int&#123;</span><br><span class="line">    case Ace &#x3D; 1</span><br><span class="line">    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten</span><br><span class="line">    case Jack, Queen, King</span><br><span class="line"></span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Ace:</span><br><span class="line">            return &quot;ace&quot;</span><br><span class="line">        case.Jack:</span><br><span class="line">            return &quot;jack&quot;</span><br><span class="line">        case.Queen:</span><br><span class="line">            return &quot;queen&quot;</span><br><span class="line">        case.King:</span><br><span class="line">            return &quot;king&quot;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            return String(self.rawValue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let ace &#x3D; Rank.Ace</span><br><span class="line">let aceRawValue &#x3D; ace.rawValue</span><br><span class="line">let kingRawValue &#x3D; Rank.King.rawValue</span><br><span class="line"></span><br><span class="line">let queenString &#x3D; Rank.simpleDescription(.Jack)</span><br><span class="line">print(queenString())</span><br></pre></td></tr></table></figure><h3 id="默认情况下，Swift-按照从-0-开始每次加-1-的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中，-Ace-被显式赋值为-1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为-枚举的原始值。使用rawValue-属性来访问一个枚举成员的原始值。使用init-rawValue-初始化构造器在原始值和枚举值之间进行转换。"><a href="#默认情况下，Swift-按照从-0-开始每次加-1-的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中，-Ace-被显式赋值为-1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为-枚举的原始值。使用rawValue-属性来访问一个枚举成员的原始值。使用init-rawValue-初始化构造器在原始值和枚举值之间进行转换。" class="headerlink" title="默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中， Ace 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为 枚举的原始值。使用rawValue 属性来访问一个枚举成员的原始值。使用init?(rawValue:) 初始化构造器在原始值和枚举值之间进行转换。"></a>默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中， Ace 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为 枚举的原始值。使用rawValue 属性来访问一个枚举成员的原始值。使用init?(rawValue:) 初始化构造器在原始值和枚举值之间进行转换。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if let convertedRank &#x3D; Rank(rawValue: 3)&#123;</span><br><span class="line">    let threeDescription &#x3D; convertedRank.simpleDescription()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。"><a href="#枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。" class="headerlink" title="枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。"></a>枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Suit &#123;</span><br><span class="line">    case Spades, Hearts, Diamonds, Clubs</span><br><span class="line">    func simpleDescription() -&gt; String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Spades:</span><br><span class="line">            return &quot;spades&quot;</span><br><span class="line">        case .Hearts:</span><br><span class="line">            return &quot;hearts&quot;</span><br><span class="line">        case .Diamonds:</span><br><span class="line">            return &quot;diamonds&quot;</span><br><span class="line">        case .Clubs:</span><br><span class="line">            return &quot;clubs&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    func color() -&gt; String &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Spades:</span><br><span class="line">            return &quot;balck&quot;</span><br><span class="line">        case .Hearts:</span><br><span class="line">            return &quot;red&quot;</span><br><span class="line">        case .Diamonds:</span><br><span class="line">            return &quot;red&quot;</span><br><span class="line">        case .Clubs:</span><br><span class="line">            return &quot;black&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let hearts &#x3D; Suit.Hearts</span><br><span class="line">let heartsDescription &#x3D; hearts.simpleDescription()</span><br><span class="line"></span><br><span class="line">let heartsColor &#x3D; hearts.color()</span><br><span class="line">let shapeColor &#x3D; Suit.Clubs.color()</span><br></pre></td></tr></table></figure><ul><li>注意，有两种方式可以引用Hearts 成员：给hearts 常量赋值时，枚举成员Suit.Hearts 需要用全名来引用，因为常量没有显式指定类型。在switch 里，枚举成员使用缩写.Hearts 来引用，因为self 的值已经知道是一个suit 。已知变量类型的情况下你可以使用缩写。</li><li>一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值<br>和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。</li></ul><h3 id="例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。"><a href="#例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。" class="headerlink" title="例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。"></a>例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ServerResponse&#123;</span><br><span class="line">    case Reasult(String,String)</span><br><span class="line">    case Failure(String)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let success &#x3D; ServerResponse.Reasult(&quot;6:00pm&quot;, &quot;8:09pm&quot;)</span><br><span class="line">let failure &#x3D; ServerResponse.Failure(&quot;Out of cheese&quot;)</span><br><span class="line"></span><br><span class="line">switch success &#123;</span><br><span class="line">case let .Reasult(sunrise,sunset):</span><br><span class="line">    let serRepsonse &#x3D; &quot;Sunrise is at\(sunrise) and sunset is at\(sunset)&quot;</span><br><span class="line"></span><br><span class="line">case let .Failure(message):</span><br><span class="line">    print(&quot;Failure....\(message)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意日升和日落时间是如何从ServerResponse 中提取到并与switch 的case 相匹配的。</li></ul><h3 id="使用struct-来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。"><a href="#使用struct-来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。" class="headerlink" title="使用struct 来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。"></a>使用struct 来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Card&#123;</span><br><span class="line">    var rank :Rank</span><br><span class="line">    var suit :Suit</span><br><span class="line">    func sampleDesp() -&gt; String&#123;</span><br><span class="line">        return &quot;The \(rank.simpleDescription()) of \(suit.simpleDescription())&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let threeOfSpades &#x3D; Card(rank: .Three, suit: .Spades)</span><br><span class="line"></span><br><span class="line">let  threeOfSpadesDesp &#x3D; threeOfSpades.sampleDesp()</span><br><span class="line"></span><br><span class="line">let threeOfRank &#x3D; threeOfSpades.rank.hashValue</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> swift3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift3.0_函数和闭包</title>
      <link href="2017-03-19/swift3-0-func-study/"/>
      <url>2017-03-19/swift3-0-func-study/</url>
      
        <content type="html"><![CDATA[<h1 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h1><h3 id="使用func-来声明一个函数，使用名字和参数来调用函数。使用-gt-来指定函数返回值的类型"><a href="#使用func-来声明一个函数，使用名字和参数来调用函数。使用-gt-来指定函数返回值的类型" class="headerlink" title="使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型"></a>使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func great( person:String,day :String) -&gt;String&#123;</span><br><span class="line">    return &quot;Hello \(person),today is \(day)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用-表示不使用参数标签。"><a href="#默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用-表示不使用参数标签。" class="headerlink" title="默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用_表示不使用参数标签。"></a>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用_表示不使用参数标签。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func greaton(_ person:String,on day :String) -&gt;String&#123;</span><br><span class="line">    return &quot;Hello \(person),today is \(day)&quot;</span><br><span class="line">&#125;</span><br><span class="line">great(person: &quot;&quot;, day: &quot;&quot;)</span><br><span class="line"></span><br><span class="line">greaton(&quot;John&quot;, on: &quot;Sunday&quot;)</span><br></pre></td></tr></table></figure><h3 id="使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。"><a href="#使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。" class="headerlink" title="使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。"></a>使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func calculateStatistics(scores:[Int]) -&gt;(min:Int,max:Int,sum:Int)&#123;</span><br><span class="line">    var minInt &#x3D; scores[0]</span><br><span class="line">    var maxInt &#x3D; scores[0]</span><br><span class="line">    var sum &#x3D; 0</span><br><span class="line"></span><br><span class="line">    for score in scores &#123;</span><br><span class="line">        if score&gt;maxInt &#123;</span><br><span class="line">            maxInt &#x3D; score</span><br><span class="line">        &#125;else if score&lt;minInt&#123;</span><br><span class="line">            minInt &#x3D; score</span><br><span class="line">        &#125;</span><br><span class="line">        sum+&#x3D;score</span><br><span class="line">    &#125;</span><br><span class="line">    return(minInt,maxInt,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let statistics &#x3D; calculateStatistics(scores: [3,4,567,89,99])</span><br><span class="line"></span><br><span class="line">print(statistics.sum)</span><br><span class="line"></span><br><span class="line">print(statistics.max)</span><br><span class="line"></span><br><span class="line">print(statistics.min)</span><br><span class="line"></span><br><span class="line">print(statistics.2)</span><br></pre></td></tr></table></figure><h3 id="函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式："><a href="#函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：" class="headerlink" title="函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式："></a>函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func sumOf(numbers:Int...)-&gt;Int&#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        sum+&#x3D;number</span><br><span class="line">    &#125;</span><br><span class="line">    return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumOf(numbers: 34,56,78)</span><br><span class="line"></span><br><span class="line">sumOf()</span><br></pre></td></tr></table></figure><h3 id="函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。"><a href="#函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。" class="headerlink" title="函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。"></a>函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func returnFifteen()-&gt;Int&#123;</span><br><span class="line">    var y &#x3D; 10</span><br><span class="line">    func add()&#123;</span><br><span class="line">        y+&#x3D;10</span><br><span class="line">    &#125;</span><br><span class="line">    add();</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line">returnFifteen()</span><br></pre></td></tr></table></figure><h3 id="函数是第一等类型，这意味着函数可以作为另一个函数的返回值。"><a href="#函数是第一等类型，这意味着函数可以作为另一个函数的返回值。" class="headerlink" title="函数是第一等类型，这意味着函数可以作为另一个函数的返回值。"></a>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func makeIncrementer()-&gt;((Int) -&gt;Int)&#123;</span><br><span class="line">    func addOne(number:Int)-&gt;Int&#123;</span><br><span class="line">        return 1+number</span><br><span class="line">    &#125;</span><br><span class="line">    return addOne</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var increment &#x3D; makeIncrementer()</span><br><span class="line"></span><br><span class="line">increment(10)</span><br></pre></td></tr></table></figure><h3 id="函数也可以当做参数传入另一个函数"><a href="#函数也可以当做参数传入另一个函数" class="headerlink" title="函数也可以当做参数传入另一个函数"></a>函数也可以当做参数传入另一个函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hasAnyMatches(list:[Int],condition:(Int) -&gt;Bool)-&gt;Bool&#123;</span><br><span class="line">    for item in list &#123;</span><br><span class="line">        if condition(item) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func lessThanTen(number:Int)-&gt;Bool&#123;</span><br><span class="line">    return number&lt;10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var numbers &#x3D; [20,19,6,12]</span><br><span class="line"></span><br><span class="line">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure><h3 id="函数实际上是一种特殊的闭包-它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的-你已经在嵌套函数例子中所看到。你可以使用-来创建一个匿名闭包。使用in-将参数和返回值类型声明与闭包函数体进行分离。"><a href="#函数实际上是一种特殊的闭包-它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的-你已经在嵌套函数例子中所看到。你可以使用-来创建一个匿名闭包。使用in-将参数和返回值类型声明与闭包函数体进行分离。" class="headerlink" title="函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{} 来创建一个匿名闭包。使用in 将参数和返回值类型声明与闭包函数体进行分离。"></a>函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{} 来创建一个匿名闭包。使用in 将参数和返回值类型声明与闭包函数体进行分离。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">numbers.map &#123; (number :Int) -&gt; Int in</span><br><span class="line">    let result &#x3D; 3*number;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(numbers)</span><br></pre></td></tr></table></figure><h3 id="有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。"><a href="#有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。" class="headerlink" title="有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。"></a>有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let mappedNumbers &#x3D; numbers.map(&#123;number in 3*number&#125;)</span><br><span class="line"></span><br><span class="line">print(mappedNumbers)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。"><a href="#你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。" class="headerlink" title="你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。"></a>你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sortedNumbers &#x3D; numbers.sort&#123;$0&gt;$1&#125;</span><br><span class="line">print(sortedNumbers)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> swift3.0 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift3.0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 解决蓝牙音箱输出App播放的音频问题</title>
      <link href="2016-09-16/IPhone-Bluetooth-speaker-output-audio/"/>
      <url>2016-09-16/IPhone-Bluetooth-speaker-output-audio/</url>
      
        <content type="html"><![CDATA[<p>App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。<br>添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。</p><span id="more"></span><h2 id="AVAudioSession的设置"><a href="#AVAudioSession的设置" class="headerlink" title="AVAudioSession的设置"></a>AVAudioSession的设置</h2><p>   如果app需要支持蓝牙外设输出及耳机 的控制需要添加 对OverrideAudioRoute OverrideCategoryEnableBluetoothInput的支持<br>   同时还要设置AVAudioSession的Category为AVAudioSessionCategoryPlayback.</p>   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVAudioSession</span> * session = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line">[session setCategory:<span class="built_in">AVAudioSessionCategoryPlayback</span> error:<span class="literal">nil</span>];</span><br><span class="line">[session setActive:<span class="literal">YES</span> error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UInt32</span> audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;</span><br><span class="line">AudioSessionSetProperty (kAudioSessionProperty_OverrideAudioRoute,</span><br><span class="line">                             <span class="keyword">sizeof</span> (audioRouteOverride),</span><br><span class="line">                         &amp;audioRouteOverride);</span><br><span class="line"></span><br><span class="line"><span class="comment">//kAudioSessionProperty_OverrideCategoryDefaultToSpeaker</span></span><br><span class="line"><span class="built_in">UInt32</span> allowBluetoothInput = <span class="number">1</span>;</span><br><span class="line">AudioSessionSetProperty (</span><br><span class="line">                         kAudioSessionProperty_OverrideCategoryEnableBluetoothInput,</span><br><span class="line">                         <span class="keyword">sizeof</span> (allowBluetoothInput),</span><br><span class="line">                         &amp;allowBluetoothInput</span><br><span class="line">                         );</span><br><span class="line"><span class="comment">//[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;];</span></span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] beginReceivingRemoteControlEvents];</span><br><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] becomeFirstResponder];</span><br></pre></td></tr></table></figure><h2 id="处理输出路径的变换的通知-AVAudioSessionRouteChangeNotification-的监听"><a href="#处理输出路径的变换的通知-AVAudioSessionRouteChangeNotification-的监听" class="headerlink" title="处理输出路径的变换的通知 AVAudioSessionRouteChangeNotification 的监听"></a>处理输出路径的变换的通知 AVAudioSessionRouteChangeNotification 的监听</h2><p>   注册通知后 要对监听做处理</p>  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">AVAudioSession</span> *audioSession = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line"><span class="built_in">NSInteger</span> changeReason = [[notification.userInfo objectForKey:<span class="built_in">AVAudioSessionRouteChangeReasonKey</span>] integerValue];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAudioSessionRouteDescription</span> *oldRoute = [notification.userInfo objectForKey:<span class="built_in">AVAudioSessionRouteChangePreviousRouteKey</span>];</span><br><span class="line"><span class="built_in">NSString</span> *oldOutput = [[oldRoute.outputs objectAtIndex:<span class="number">0</span>] portType];</span><br><span class="line"><span class="built_in">AVAudioSessionRouteDescription</span> *newRoute = [audioSession currentRoute];</span><br><span class="line"><span class="built_in">NSString</span> *newOutput = [[newRoute.outputs objectAtIndex:<span class="number">0</span>] portType];</span><br></pre></td></tr></table></figure><p>  具体实现请看代码</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - (<span class="keyword">void</span>)currentRouteChanged:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AVAudioSession</span> *audioSession = [<span class="built_in">AVAudioSession</span> sharedInstance];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSInteger</span> changeReason = [[notification.userInfo objectForKey:<span class="built_in">AVAudioSessionRouteChangeReasonKey</span>] integerValue];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVAudioSessionRouteDescription</span> *oldRoute = [notification.userInfo objectForKey:<span class="built_in">AVAudioSessionRouteChangePreviousRouteKey</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *oldOutput = [[oldRoute.outputs objectAtIndex:<span class="number">0</span>] portType];</span><br><span class="line">    <span class="built_in">AVAudioSessionRouteDescription</span> *newRoute = [audioSession currentRoute];</span><br><span class="line">    <span class="built_in">NSString</span> *newOutput = [[newRoute.outputs objectAtIndex:<span class="number">0</span>] portType];</span><br><span class="line">    <span class="built_in">NSLogDebug</span>(<span class="string">@&quot;changeReason - ------------------ %d&quot;</span>,(<span class="keyword">int</span>)changeReason);</span><br><span class="line">    <span class="keyword">switch</span> (changeReason) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAudioSessionRouteChangeReasonOldDeviceUnavailable</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([oldOutput isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">self</span>.headsetDeviceAvailable = <span class="literal">NO</span>;</span><br><span class="line">                <span class="comment">// Special Scenario:</span></span><br><span class="line">                <span class="comment">// when headphones are plugged in before the call and plugged out during the call</span></span><br><span class="line">                <span class="comment">// route will change to &#123;input: MicrophoneBuiltIn, output: Receiver&#125;</span></span><br><span class="line">                <span class="comment">// manually refresh session and support all devices again.</span></span><br><span class="line"><span class="comment">//                [audioSession setActive:NO error:nil];</span></span><br><span class="line"><span class="comment">//                [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionAllowBluetooth error:nil];</span></span><br><span class="line"><span class="comment">//                [audioSession setMode:AVAudioSessionModeVoiceChat error:nil];</span></span><br><span class="line"><span class="comment">//                [audioSession setActive:YES error:nil];</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                     [WawaAudioBookListView pauseCurrentAudio];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:oldOutput]) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">BOOL</span> showBluetooth = <span class="literal">NO</span>;</span><br><span class="line">                <span class="comment">// Additional checking for iOS7 devices (more accurate)</span></span><br><span class="line">                <span class="comment">// when multiple blutooth devices connected, one is no longer available does not mean no bluetooth available</span></span><br><span class="line">                <span class="keyword">if</span> ([audioSession respondsToSelector:<span class="keyword">@selector</span>(availableInputs)]) &#123;</span><br><span class="line">                    <span class="built_in">NSArray</span> *inputs = [audioSession availableInputs];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">AVAudioSessionPortDescription</span> *input <span class="keyword">in</span> inputs)&#123;</span><br><span class="line">                        <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:[input portType]])&#123;</span><br><span class="line">                            showBluetooth = <span class="literal">YES</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!showBluetooth) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.bluetoothDeviceAvailable = <span class="literal">NO</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAudioSessionRouteChangeReasonNewDeviceAvailable</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:newOutput]) &#123;</span><br><span class="line">                <span class="keyword">self</span>.bluetoothDeviceAvailable = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([newOutput isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line">                <span class="keyword">self</span>.headsetDeviceAvailable = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAudioSessionRouteChangeReasonCategoryChange</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:newOutput]) &#123;</span><br><span class="line">                <span class="keyword">self</span>.bluetoothDeviceAvailable = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([newOutput isEqualToString:<span class="built_in">AVAudioSessionPortHeadphones</span>]) &#123;</span><br><span class="line">                <span class="keyword">self</span>.headsetDeviceAvailable = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSUserDefaults</span> *defaults =[<span class="built_in">NSUserDefaults</span> standardUserDefaults];</span><br><span class="line">            [defaults setObject:<span class="string">@&quot;YES&quot;</span> forKey:<span class="string">@&quot;WawaAVAudioSessionRouteChangeReasonCategoryChange&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAudioSessionRouteChangeReasonOverride</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:oldOutput]) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([audioSession respondsToSelector:<span class="keyword">@selector</span>(availableInputs)]) &#123;</span><br><span class="line">                    <span class="built_in">BOOL</span> showBluetooth = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="built_in">NSArray</span> *inputs = [audioSession availableInputs];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">AVAudioSessionPortDescription</span> *input <span class="keyword">in</span> inputs)&#123;</span><br><span class="line">                        <span class="keyword">if</span> ([<span class="keyword">self</span> isBluetoothDevice:[input portType]])&#123;</span><br><span class="line">                            showBluetooth = <span class="literal">YES</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!showBluetooth) &#123;</span><br><span class="line">                        <span class="keyword">self</span>.bluetoothDeviceAvailable = <span class="literal">NO</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([newOutput isEqualToString:<span class="built_in">AVAudioSessionPortBuiltInReceiver</span>]) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">self</span>.bluetoothDeviceAvailable = <span class="literal">NO</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isBluetoothDevice:(<span class="built_in">NSString</span>*)portType &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ([portType isEqualToString:<span class="built_in">AVAudioSessionPortBluetoothA2DP</span>] ||</span><br><span class="line">            [portType isEqualToString:<span class="built_in">AVAudioSessionPortBluetoothHFP</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                             selector:<span class="keyword">@selector</span>(currentRouteChanged:)</span><br><span class="line">                                                 name:<span class="built_in">AVAudioSessionRouteChangeNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="处理RemoteControl"><a href="#处理RemoteControl" class="headerlink" title="处理RemoteControl"></a>处理RemoteControl</h2><p>   音频蓝牙音箱的外设可以进行下一首 等操作 所以对RemoteControl做处理<br>   来控制音频的播放</p> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.subtype) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPlay</span>:</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">                [<span class="keyword">self</span> postNotification:kRemoteControlPlayTapped];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPause</span>:</span><br><span class="line">            [<span class="keyword">self</span> postNotification:kRemoteControlPauseTapped];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlNextTrack</span>:</span><br><span class="line">            [<span class="keyword">self</span> postNotification:kRemoteControlNextTapped];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UIEventSubtypeRemoteControlPreviousTrack</span>:</span><br><span class="line">            [<span class="keyword">self</span> postNotification:kRemoteControlPreviousTapped];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)postNotification:(<span class="keyword">const</span> <span class="built_in">NSString</span> *)notificationName</span><br><span class="line">&#123;</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">     postNotificationName:(<span class="built_in">NSString</span> *)notificationName object:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeRemoteControl:(<span class="keyword">id</span>)observer selector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNotificationCenter</span> * center = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line"></span><br><span class="line">    [center addObserver:observer selector:selector name:(<span class="built_in">NSString</span> *)kRemoteControlNextTapped object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [center addObserver:observer selector:selector name:(<span class="built_in">NSString</span> *)kRemoteControlPauseTapped object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [center addObserver:observer selector:selector name:(<span class="built_in">NSString</span> *)kRemoteControlPlayTapped object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    [center addObserver:observer selector:selector name:(<span class="built_in">NSString</span> *)kRemoteControlPreviousTapped object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 处理事件<br> <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)onRemoteControlNotification:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;changeReason - ------------------ kRemoteControlPlayTapped&quot;</span>);</span><br><span class="line">    <span class="comment">//[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;];</span></span><br><span class="line">    <span class="keyword">if</span> ([notification.name isEqualToString:kRemoteControlPlayTapped]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.audioSteamSate == kFsAudioStreamRetrievingURL || <span class="keyword">self</span>.audioSteamSate == kFsAudioStreamStopped) &#123;   <span class="comment">// 当前选中的 audio 处于准备中则播放此 url</span></span><br><span class="line">            <span class="keyword">self</span>.needResume = <span class="literal">YES</span>;</span><br><span class="line">            [<span class="keyword">self</span> playFromUrl:<span class="keyword">self</span>.currentPlayAduio];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则暂停或者播放</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.audioSteamSate ==kFsAudioStreamPlaying) &#123;</span><br><span class="line">                 <span class="keyword">self</span>.needResume = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只在当前播放状态为播放时处理蓝牙设备的接入</span></span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span>.audioStream pause];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([notification.name isEqualToString:kRemoteControlPauseTapped]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.audioStream pause];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([notification.name isEqualToString:kRemoteControlNextTapped]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> next];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([notification.name isEqualToString:kRemoteControlPreviousTapped]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> previous];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> iOS Project Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> AVAudioSession </tag>
            
            <tag> AudioSessionProperty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 解决支付宝SDK在没有安装支付宝时不能启动网页支付</title>
      <link href="2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/"/>
      <url>2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/</url>
      
        <content type="html"><![CDATA[<p>在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。</p><span id="more"></span><h2 id="配置plist-文件"><a href="#配置plist-文件" class="headerlink" title="配置plist 文件"></a>配置plist 文件</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">配置 LSApplicationQueriesSchemes</span><br><span class="line"> <span class="tag">&lt;<span class="name">key</span>&gt;</span>LSApplicationQueriesSchemes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>alipayauth<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>alipay<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>alipayshare<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>safepay<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>aliminipayauth<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>cydia<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"></span><br><span class="line">配置NSAppTransportSecurity ，添加NSExceptionDomains支持</span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>alipay.com<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSIncludesSubdomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSTemporaryExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSTemporaryExceptionMinimumTLSVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>TLSv1.1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionRequiresForwardSecrecy<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄"><a href="#在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄" class="headerlink" title="在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄"></a>在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection canAuthenticateAgainstProtectionSpace:(<span class="built_in">NSURLProtectionSpace</span> *)protectionSpac</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveAuthenticationChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *trustedHosts = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;alipay&quot;</span>,<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span> ([trustedHosts containsObject:challenge.protectionSpace.host]) &#123;</span><br><span class="line">            [challenge.sender useCredential:[<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [challenge.sender continueWithoutCredentialForAuthenticationChallenge:challenge];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="我们的项目是通过storyboard启动的，所以需要将第一个Window-的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View-移除掉。"><a href="#我们的项目是通过storyboard启动的，所以需要将第一个Window-的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View-移除掉。" class="headerlink" title="我们的项目是通过storyboard启动的，所以需要将第一个Window 的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View 移除掉。"></a>我们的项目是通过storyboard启动的，所以需要将第一个Window 的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View 移除掉。</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="built_in">UIWindow</span>* window = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSURL</span> * app_Alipay_URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;alipay:&quot;</span>];</span><br><span class="line"><span class="built_in">UIView</span> *bgView = [[<span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, Main_Screen_Width, Main_Screen_Height)];</span><br><span class="line">bgView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (![[<span class="built_in">UIApplication</span> sharedApplication] canOpenURL:app_Alipay_URL]) &#123;</span><br><span class="line">    <span class="comment">//如果没有安装支付宝</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array = [[<span class="built_in">UIApplication</span> sharedApplication] windows];</span><br><span class="line">    window = [array firstObject];</span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">        [window.rootViewController.view addSubview:bgView];</span><br><span class="line">        [window setHidden:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(<span class="built_in">NSDictionary</span> *resultDic) &#123;</span><br><span class="line">    <span class="keyword">if</span> (window) &#123;</span><br><span class="line">        [window setHidden:<span class="literal">YES</span>];</span><br><span class="line">        [bgView removeFromSuperview];</span><br><span class="line">        window = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_callBack) &#123;</span><br><span class="line">        _callBack([<span class="keyword">self</span> requestFromResultDic:resultDic]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS Project Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 支付宝SDK </tag>
            
            <tag> 支付宝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 多线程同时访问数组出现was mutated while being enumerated</title>
      <link href="2016-08-13/was_mutated_while_being_enumerated/"/>
      <url>2016-08-13/was_mutated_while_being_enumerated/</url>
      
        <content type="html"><![CDATA[<p>错误：iOS 多线程同时访问数组出现was mutated while being enumerated<br>__NSArrayM: 0x96be3e0 was mutated while being enumerated.<br>意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。<br>原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突</p><span id="more"></span><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)getAudioPlayArray:(<span class="built_in">NSArray</span> *)array playingId:(<span class="keyword">long</span> <span class="keyword">long</span>)playingId</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> * targetArray = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> * tempArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> * model <span class="keyword">in</span> array) &#123;</span><br><span class="line"></span><br><span class="line">        AudioPlayModel * playModel = [[AudioPlayModel alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ([model isKindOfClass:[GenBookListDTO <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            GenBookListDTO * picBook = (GenBookListDTO *)model;</span><br><span class="line">            playModel.playId = picBook.bookId;</span><br><span class="line">            playModel.playName = picBook.name;</span><br><span class="line">            playModel.playCover = picBook.cover;</span><br><span class="line">            playModel.publisher = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">            playModel.audioType = PlayAudioType_PictureBook;</span><br><span class="line">            <span class="keyword">if</span> (playModel.playId == playingId) &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([model isKindOfClass:[GenSongListDTO <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            GenSongListDTO * songRes = (GenSongListDTO *)model;</span><br><span class="line">            playModel.playId = songRes.songId;</span><br><span class="line">            playModel.playName = songRes.name;</span><br><span class="line">            playModel.playCover = songRes.audioCover;</span><br><span class="line">            playModel.publisher = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">            playModel.audioType = PlayAudioType_Song;</span><br><span class="line">            <span class="keyword">if</span> (playModel.playId == playingId) &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([model isKindOfClass:[AudioPlayModel <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            AudioPlayModel * audioModel = (AudioPlayModel *)model;</span><br><span class="line">            playModel.playId = audioModel.playId;</span><br><span class="line">            playModel.playName = audioModel.playName;</span><br><span class="line">            playModel.playCover = audioModel.playCover;</span><br><span class="line">            playModel.publisher = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">            playModel.audioType = audioModel.audioType;</span><br><span class="line">            <span class="keyword">if</span> (playModel.playId == playingId) &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([model isKindOfClass:[PictureBook <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            PictureBook * picBookModel = (PictureBook *)model;</span><br><span class="line">            playModel.playId = (<span class="keyword">long</span> <span class="keyword">long</span>)picBookModel.bookId;</span><br><span class="line">            playModel.playName = picBookModel.title;</span><br><span class="line">            playModel.playCover = picBookModel.cover;</span><br><span class="line">            playModel.publisher = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">            playModel.audioType = PlayAudioType_PictureBook;</span><br><span class="line">            <span class="keyword">if</span> (playModel.playId == playingId) &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([model isKindOfClass:[GenBookBorrowedDTO <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            GenBookBorrowedDTO * borrowBookModel = (GenBookBorrowedDTO *)model;</span><br><span class="line">            playModel.playId = borrowBookModel.bookId;</span><br><span class="line">            playModel.playName = borrowBookModel.name;</span><br><span class="line">            playModel.playCover = borrowBookModel.cover;</span><br><span class="line">            playModel.publisher = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">            playModel.audioType = PlayAudioType_PictureBook;</span><br><span class="line">            <span class="keyword">if</span> (playModel.playId == playingId) &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                playModel.isPlaying = <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [tempArray addObject:playModel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tempArray.count) &#123;</span><br><span class="line">        [AudioPlayModel saveAudioPlayList:tempArray];</span><br><span class="line">    &#125;</span><br><span class="line">    targetArray = tempArray;</span><br><span class="line">    <span class="keyword">return</span> targetArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。"><a href="#解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。" class="headerlink" title="解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。"></a>解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。</h2><p>　　NSArray* array=[NSArray arrayWithArray:b];</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Xcode开发组件失效的命令</title>
      <link href="2016-07-30/solve-Xcode-development-component-failure-of-the-command/"/>
      <url>2016-07-30/solve-Xcode-development-component-failure-of-the-command/</url>
      
        <content type="html"><![CDATA[<p>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add <code>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</code></p>]]></content>
      
      
      <categories>
          
          <category> xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发--多线程 NSThread GCD 学习</title>
      <link href="2016-07-28/iOS-multithreading-NSThread-GCD/"/>
      <url>2016-07-28/iOS-multithreading-NSThread-GCD/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><ul><li><p>1.1 进程</p><p>  进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p><span id="more"></span></li><li><p>1.2 线程</p></li></ul><p>（1）基本概念</p><pre><code>1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。</code></pre><p>（2）线程的串行</p><pre><code>1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。</code></pre><ul><li>1.3 多线程</li></ul><p>（1）基本概念</p><pre><code>即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。</code></pre><p>（2）线程的并行</p><pre><code>并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C。</code></pre><p>（3）多线程并发执行的原理</p><pre><code>在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</code></pre><p>（4）多线程优缺点</p><pre><code>优点    1）能适当提高程序的执行效率。    2）能适当提高资源利用率（CPU、内存利用率）缺点    1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。    2）线程越多，CPU在调度线程上的开销就越大。    3）程序设计更加复杂：比如线程之间的通信、多线程的数据共享</code></pre><ul><li>1.4 多线程在iOS开发中的应用</li></ul><p>（1）主线程</p><pre><code>1）一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。2）作用。刷新显示UI,处理UI事件。</code></pre><p>（2）使用注意</p><pre><code>1）不要将耗时操作放到主线程中去处理，会卡住线程。</code></pre><ul><li>1.5 iOS中多线程的实现方案</li></ul><p>（1）<code>pthread</code></p><pre><code>01 特点：（1）一套通用的多线程API（2）适用于Unix\Linux\Windows等系统（3）跨平台\可移植（4）使用难度大02 使用语言：c语言03 使用频率：几乎不用04 线程生命周期：由程序员进行管理</code></pre><p>（2） <code>NSThread</code></p><pre><code>01 特点：（1）使用更加面向对象（2）简单易用，可直接操作线程对象02 使用语言：OC语言03 使用频率：偶尔使用04 线程生命周期：由程序员进行管理</code></pre><p>（3）<code>GCD</code></p><pre><code>01 特点：（1）旨在替代NSThread等线程技术（2）充分利用设备的多核(自动)02 使用语言：OC语言03 使用频率：经常使用04 线程生命周期：自动管理</code></pre><p>(4) <code>NSOperation</code></p><pre><code>01 特点：（1）基于GCD（底层是GCD）（2）比GCD多了一些更简单实用的功能（3）使用更加面向对象02 使用语言：OC语言03 使用频率：经常使用04 线程生命周期：自动管理</code></pre><hr><h3 id="2-pthread"><a href="#2-pthread" class="headerlink" title="2.pthread"></a>2.pthread</h3><p>（1）pthread的基本使用（需要包含头文件）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使用pthread创建线程</span></span><br><span class="line">pthread_t thread;</span><br><span class="line"> <span class="built_in">NSString</span> *name = <span class="string">@&quot;wendingding&quot;</span>;</span><br><span class="line"> <span class="comment">//使用pthread创建线程</span></span><br><span class="line"> <span class="comment">//第一个参数：线程对象地址</span></span><br><span class="line"> <span class="comment">//第二个参数：线程属性</span></span><br><span class="line"> <span class="comment">//第三个参数：指向函数的执行</span></span><br><span class="line"> <span class="comment">//第四个参数：传递给该函数的参数</span></span><br><span class="line"> pthread_create(&amp;thread, <span class="literal">NULL</span>, run, (__bridge <span class="keyword">void</span> *)(name));</span><br></pre></td></tr></table></figure><hr><h3 id="3-NSThread"><a href="#3-NSThread" class="headerlink" title="3.NSThread"></a>3.NSThread</h3><p>（1）NSThread的基本使用</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种创建线程的方式：alloc init.</span></span><br><span class="line"><span class="comment">//特点：需要手动开启线程，可以拿到线程对象进行详细设置</span></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一个参数：目标对象</span></span><br><span class="line"><span class="comment">     第二个参数：选择器，线程启动要调用哪个方法</span></span><br><span class="line"><span class="comment">     第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run:) object:<span class="string">@&quot;wendingding&quot;</span>];</span><br><span class="line">     <span class="comment">//启动线程</span></span><br><span class="line">    [thread start];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种创建线程的方式：分离出一条子线程</span></span><br><span class="line"><span class="comment">//特点：自动启动线程，无法对线程进行更详细的设置</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     第一个参数：线程启动调用的方法</span></span><br><span class="line"><span class="comment">     第二个参数：目标对象</span></span><br><span class="line"><span class="comment">     第三个参数：传递给调用方法的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@&quot;我是分离出来的子线程&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种创建线程的方式：后台线程</span></span><br><span class="line"><span class="comment">//特点：自动启动县城，无法进行更详细设置</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run:) withObject:<span class="string">@&quot;我是后台线程&quot;</span>];</span><br></pre></td></tr></table></figure><p>（2）设置线程的属性</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置线程的属性</span></span><br><span class="line"> <span class="comment">//设置线程的名称</span></span><br><span class="line"> thread.name = <span class="string">@&quot;线程A&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5</span></span><br><span class="line"> thread.threadPriority = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><p>（3）线程的状态（了解）</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程的各种状态：新建-就绪-运行-阻塞-死亡</span></span><br><span class="line"><span class="comment">//常用的控制线程状态的方法</span></span><br><span class="line">[<span class="built_in">NSThread</span> exit];<span class="comment">//退出当前线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2.0</span>];<span class="comment">//阻塞线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">2.0</span>]];<span class="comment">//阻塞线程</span></span><br><span class="line"><span class="comment">//注意：线程死了不能复生</span></span><br></pre></td></tr></table></figure><p>（4）线程安全</p><pre><code>01 前提：多个线程访问同一块资源会发生数据安全问题02 解决方案：加互斥锁03 相关代码：@synchronized(self)&#123;&#125;04 专业术语-线程同步05 原子和非原子属性（是否对setter方法加锁）</code></pre><p>（5）线程间通信</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="keyword">nonnull</span> <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    [self download2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启一条子线程来下载图片</span></span><br><span class="line">    [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(downloadImage) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)downloadImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.根据url地址下载图片数据到本地（二进制数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.把下载到本地的二进制数据转换成图片</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.回到主线程刷新UI</span></span><br><span class="line">    <span class="comment">//4.1 第一种方式</span></span><br><span class="line"><span class="comment">//    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.2 第二种方式</span></span><br><span class="line"><span class="comment">//    [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.3 第三种方式</span></span><br><span class="line">    [<span class="keyword">self</span>.imageView performSelector:<span class="keyword">@selector</span>(setImage:) onThread:[<span class="built_in">NSThread</span> mainThread] withObject:image waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）如何计算代码段的执行时间</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line">    <span class="built_in">NSDate</span> *start = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="comment">//2.根据url地址下载图片数据到本地（二进制数据）</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDate</span> *end = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二步操作花费的时间为%f&quot;</span>,[end timeIntervalSinceDate:start]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> start = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CFTimeInterval</span> end = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;第二步操作花费的时间为%f&quot;</span>,end - start);</span><br></pre></td></tr></table></figure><p>###4.GCD</p><p>（1）GCD基本知识</p><pre><code>01 两个核心概念-队列和任务02 同步函数和异步函数</code></pre><p>（2）GCD基本使用【重点】</p><pre><code>01 异步函数+并发队列：开启多条线程，并发执行任务02 异步函数+串行队列：开启一条线程，串行执行任务03 同步函数+并发队列：不开线程，串行执行任务04 同步函数+串行队列：不开线程，串行执行任务05 异步函数+主队列：不开线程，在主线程中串行执行任务06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生）07 注意同步函数和异步函数在执行顺序上面的差异</code></pre><p>（3）GCD线程间通信</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.获取一个全局的队列</span></span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1.先开启一个线程，把下载图片的操作放在子线程中处理</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.下载图片</span></span><br><span class="line">       <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;</span>];</span><br><span class="line">       <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">       <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;下载操作所在的线程--%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.回到主线程刷新UI</span></span><br><span class="line">       <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">          <span class="comment">//打印查看当前线程</span></span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;刷新UI---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>（4）GCD其它常用函数</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">01</span> 栅栏函数（控制任务的执行顺序）</span><br><span class="line">   dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;--dispatch_barrier_async-&quot;</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="number">02</span> 延迟执行（延迟·控制在哪个线程执行）</span><br><span class="line">     dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="number">03</span> 一次性代码（注意不能放到懒加载）</span><br><span class="line">   -(<span class="keyword">void</span>)once</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//整个程序运行过程中只会执行一次</span></span><br><span class="line">       <span class="comment">//onceToken用来记录该部分的代码是否被执行过</span></span><br><span class="line">       <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">       <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">NSLog</span>(<span class="string">@&quot;-----&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">04</span> 快速迭代（开多个线程并发完成迭代操作）</span><br><span class="line">      dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="number">05</span> 队列组（同栅栏函数）</span><br><span class="line">   <span class="comment">//创建队列组</span></span><br><span class="line">   dispatch_group_t group = dispatch_group_create();</span><br><span class="line">   <span class="comment">//队列组中的任务执行完毕之后，执行该函数</span></span><br><span class="line">   dispatch_group_notify(dispatch_group_t group,</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue,</span><br><span class="line">dispatch_block_t block);</span><br></pre></td></tr></table></figure><ul><li>学习<br><a href="http://520it.com">小马哥·文顶顶</a>）</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS多线程 </tag>
            
            <tag> NSThread </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 轻量级播放器</title>
      <link href="2016-07-24/wawa-mediaplayer/"/>
      <url>2016-07-24/wawa-mediaplayer/</url>
      
        <content type="html"><![CDATA[<p>公司项目 <a href="http://www.wawachina.cn/app">娃娃</a> 中播放小视频的播放器控件抽取出来，分享一下。<br>WaWaVideoPlayer是一款轻量级视频播放器组件,利用原生MPMoviePlayerController参考kr-video-player编写的一款视频控件。解决项目中微视频播放问题。</p><span id="more"></span><h2 id="WaWaVideoPlayer使用说明"><a href="#WaWaVideoPlayer使用说明" class="headerlink" title="WaWaVideoPlayer使用说明"></a>WaWaVideoPlayer使用说明</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视频播放</span></span><br><span class="line">WawaVideoPlayViewController *vc= [[WawaVideoPlayViewController alloc] init];</span><br><span class="line">vc.videoURL =[<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;</span>];</span><br><span class="line">vc.content = <span class="string">@&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;</span>;</span><br><span class="line"><span class="built_in">UINavigationController</span> *rootVedioVc = [[<span class="built_in">UINavigationController</span> alloc]initWithRootViewController:vc];</span><br><span class="line">rootVedioVc.navigationBarHidden = <span class="literal">YES</span>;</span><br><span class="line">[<span class="keyword">self</span> presentViewController:rootVedioVc animated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><h3 id="下载视频核心方法"><a href="#下载视频核心方法" class="headerlink" title="下载视频核心方法"></a>下载视频核心方法</h3><p>  播放器使用 <code>AFNetworking</code> 进行视频文件的下载，用<code>MBProgressHD</code>实现了下载进度</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  -(<span class="keyword">void</span>)downloadVideo :(<span class="built_in">NSURL</span> *)video andMsgContent:(<span class="built_in">NSString</span> *)content isOnlyDown:(<span class="built_in">BOOL</span> )isOnlyDown&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *videoPath = [<span class="keyword">self</span> getVideoSaveFolderPathString];<span class="comment">//文件名</span></span><br><span class="line">    <span class="built_in">NSString</span> *file = [videoPath stringByAppendingPathComponent:[content stringByReplacingOccurrencesOfString:<span class="string">@&quot;/&quot;</span> withString:<span class="string">@&quot;_&quot;</span>]];</span><br><span class="line">    <span class="keyword">if</span> (![file hasSuffix:<span class="string">@&quot;.mp4&quot;</span>]) &#123;</span><br><span class="line">        file = [file stringByAppendingString:<span class="string">@&quot;.mp4&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.currentVideoFile = file;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="keyword">if</span>(![fileManager fileExistsAtPath:file]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> createVideoFolderIfNotExist];<span class="comment">//创建文件file</span></span><br><span class="line">        <span class="comment">//初始化进度条</span></span><br><span class="line">        MBProgressHUD *HUD = [MBProgressHUD showMessag:<span class="literal">nil</span> toView:<span class="keyword">self</span>.view];</span><br><span class="line">        HUD.tag = <span class="number">1000</span>;</span><br><span class="line">        HUD.mode = MBProgressHUDModeAnnularDeterminate;</span><br><span class="line">        HUD.labelFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</span><br><span class="line">        HUD.detailsLabelText = <span class="string">@&quot;正在下载...&quot;</span>;</span><br><span class="line">        HUD.detailsLabelFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">14</span>];</span><br><span class="line">        HUD.square = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc ]init];</span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="comment">//保存路径</span></span><br><span class="line">        AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc]initWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:video]];</span><br><span class="line">        op.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:file append:<span class="literal">NO</span>];</span><br><span class="line">        <span class="comment">// 根据下载量设置进度条的百分比</span></span><br><span class="line">        [op setDownloadProgressBlock:^(<span class="built_in">NSUInteger</span> bytesRead, <span class="keyword">long</span> <span class="keyword">long</span> totalBytesRead, <span class="keyword">long</span> <span class="keyword">long</span> totalBytesExpectedToRead) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> precent = (<span class="built_in">CGFloat</span>)totalBytesRead / totalBytesExpectedToRead;</span><br><span class="line">            HUD.progress = precent;</span><br><span class="line">            HUD.labelText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%0.0f%%&quot;</span>,precent*<span class="number">100</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        [op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">            <span class="comment">//NSLog(@&quot;下载成功&quot;);</span></span><br><span class="line">            [responseObject writeToFile:file atomically:<span class="literal">YES</span>];</span><br><span class="line">            <span class="keyword">if</span> (!isOnlyDown) &#123;</span><br><span class="line">                 [weakSelf playVideoWithURL:[<span class="built_in">NSURL</span> fileURLWithPath:file]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (weakSelf.currentVideoFile &amp;&amp; weakSelf.currentVideoFile.length &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    [weakSelf.videoController reloadLocalVideo:[<span class="built_in">NSURL</span> fileURLWithPath:weakSelf.currentVideoFile]];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            [HUD removeFromSuperview];</span><br><span class="line">        &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">            <span class="comment">//NSLog(@&quot;下载失败&quot;);</span></span><br><span class="line">            HUD.labelText = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;下载失败&quot;</span>];</span><br><span class="line">            [HUD removeFromSuperview];</span><br><span class="line">            <span class="keyword">if</span> (!isOnlyDown) &#123;</span><br><span class="line">               [weakSelf dismissViewControllerAnimated:<span class="literal">NO</span> completion:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//开始下载</span></span><br><span class="line">        [queue addOperation:op];</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOnlyDown) &#123;</span><br><span class="line">             [<span class="keyword">self</span> playVideoWithURL:[<span class="built_in">NSURL</span> fileURLWithPath:file]];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             [<span class="keyword">self</span>.videoController reloadLocalVideo:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.currentVideoFile]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更多具体实现请下载工程实例"><a href="#更多具体实现请下载工程实例" class="headerlink" title="更多具体实现请下载工程实例"></a>更多具体实现请下载工程实例</h3><p><a href="https://github.com/fangliquan/iOS-Technology-development">源码下载</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS Project Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS视频播放器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo和github pages搭建博客</title>
      <link href="2016-07-24/%E4%BD%BF%E7%94%A8Hexo-%E5%92%8Cgithub-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2016-07-24/%E4%BD%BF%E7%94%A8Hexo-%E5%92%8Cgithub-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows/MAC/Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo</p><span id="more"></span><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2. 配置环境"></a>2. 配置环境</h2><h3 id="2-1-安装git"><a href="#2-1-安装git" class="headerlink" title="2.1 安装git"></a>2.1 安装git</h3><p>作者用的是mac，可以使用<a href="http://brew.sh/">brew</a>下面命令安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install git</span></span><br></pre></td></tr></table></figure><p>也可以直接上<a href="https://git-scm.com/download/">git官网</a>下载安装</p><h3 id="2-2-安装node-js"><a href="#2-2-安装node-js" class="headerlink" title="2.2 安装node.js"></a>2.2 安装node.js</h3><p>同样的，mac可以使用brew安装，新版的node.js已经包含npm工具，不需要再另外安装了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install node</span></span><br></pre></td></tr></table></figure><p>可以通过下面命令检查是否已安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br></pre></td></tr></table></figure><p>如果是windows用户可以通过官网下载 <a href="http://nodejs.org">jode.js</a></p><h3 id="2-3-Hexo安装"><a href="#2-3-Hexo安装" class="headerlink" title="2.3 Hexo安装"></a>2.3 Hexo安装</h3><p>上面的安装完成后，接下来安装hexo</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g   #-g表示全局安装, npm默认为当前项目安装</span><br><span class="line">hexo init blog            #在当前目录下新建blog目录初始化博客</span><br><span class="line">cd blog                   #进入blog目录</span><br><span class="line"><span class="meta">#</span><span class="bash">npm install</span>               </span><br><span class="line">hexo generate             #根据当前配置生成静态页面</span><br><span class="line">hexo server               #启动本地服务，默认为：[http://localhost:4000/](http://localhost:4000/)</span><br></pre></td></tr></table></figure><p>接下来就可以通过<a href="http://localhost:4000/">http://localhost:4000/</a>查看效果了<br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-18/1497950.jpg" alt="hello hexo"></p><h2 id="3-配置github-pages"><a href="#3-配置github-pages" class="headerlink" title="3. 配置github pages"></a>3. 配置github pages</h2><p>每个github账户都可以有一个外部空间/Responsitory，可以直接通过<code>用户名.github.io</code>访问到该仓库的内容</p><ul><li>在github上新增一个responsitory，仓库名为 <code>用户名.github.io</code> 或 <code>用户名.github.com</code></li><li>创建完成后，github会自动将 用户名.github.io指向该仓库，默认访问根目录下的<code>index.html</code>页面</li><li>可以进入Responsitory的Setting页查看</li></ul><p>github会提供几个模板搭建站点，我们可以不用他提供的模板，可以在仓库里面，添加一个简单的index.html文件，如果能通过<code>用户名.github.com</code>访问，则表明创建成功了</p><h2 id="4-写博客"><a href="#4-写博客" class="headerlink" title="4. 写博客"></a>4. 写博客</h2><p>hexo的文章存放在source目录下</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── <span class="built_in">source</span>  </span><br><span class="line">|   ├── _posts    <span class="comment">#存放文章  </span></span><br><span class="line">|   └── _drafts   <span class="comment">#存放草稿</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new post <span class="string">&quot;postName&quot;</span>        <span class="comment"># 在source/_posts 目录下创建postName.md文件</span></span></span><br></pre></td></tr></table></figure><p>创建文件的命名格式可以在_config.yml文件配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year-:month-:day-:title.md</span></span><br></pre></td></tr></table></figure><p>文件创建完成后会自动生成以下格式（可以自己添加）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 使用Hexo和github pages搭建博客</span><br><span class="line">date: 2016-04-18 19:50:26</span><br><span class="line">categories: blog                  # 分类</span><br><span class="line">tags: [blogs, hexo]               # 标签，格式：[标签, 标签2]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>关与写作的各种参数可以参见：<a href="https://hexo.io/docs/writing.html">https://hexo.io/docs/writing.html</a></p><p>写完后预览的时候发现，文章在首页就全部显示出来了，如果不想全部显示，可以在文章中间添加下面标记，在首页列表就会出现<code>Read More</code>的标记</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure><p>Hexo支持使用Markdown语法写文章，我比较习惯用Atom写Markdown，Atom有个hexo插件</p><h2 id="5-主题"><a href="#5-主题" class="headerlink" title="5. 主题"></a>5. 主题</h2><p>官方自带主题基本够用，有能力可以自己改造，当然，网上已经有很多人做了一些很好看的主题了，我们可以直接拿来用，下面是官方列出的一些主题，找到喜欢的可以直接用</p><blockquote><p><a href="https://github.com/hexojs/hexo/wiki/Themes">https://github.com/hexojs/hexo/wiki/Themes</a><br><a href="https://hexo.io/themes/">https://hexo.io/themes</a></p></blockquote><p>在hexo上，主题放在themes目录下，我们只需要把别人做好的主题clone下来就好了，然后在<code>_config.yml</code>修改一下配置<br>例如：我们可以<a href="https://github.com/xiangming/landscape-plus">https://github.com/xiangming/landscape-plus</a>这个主题clone下来</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:xiangming&#x2F;landscape-plus.git themes&#x2F;landscape-plus</span><br></pre></td></tr></table></figure><p>修改设置<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">landscape-plus</span></span><br></pre></td></tr></table></figure><p><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-18/53534541.jpg" alt=""></p><h2 id="6-添加多说评论插件"><a href="#6-添加多说评论插件" class="headerlink" title="6. 添加多说评论插件"></a>6. 添加多说评论插件</h2><p>到<a href="http://duoshuo.com/">多说官网</a>注册和创建一个站点</p><p>修改配置<br>到<code>themes/landscape-plus/_config.yml</code>添加多说的配置，shortname即注册的站点名称</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Duoshuo</span></span><br><span class="line"><span class="attr">duoshuo_shortname:</span> <span class="string">bomo</span></span><br></pre></td></tr></table></figure><p>参见官方说明，替换评论相关的代码<a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9">http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9</a></p><p>完成，如下图评论有了<br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-18/61189510.jpg" alt="评论"></p><h2 id="7-部署到github上"><a href="#7-部署到github上" class="headerlink" title="7. 部署到github上"></a>7. 部署到github上</h2><p>修改配置<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">https://github.com/zhengbomo/zhengbomo.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><p>部署hexo到git上</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy</span></span><br></pre></td></tr></table></figure><p>部署过程需要输入账号密码，然后会push到github上，参考：<a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a></p><blockquote><p>hexo部署时会把最终生成的博客文件（public目录下的文件）push到git远程仓库，而博客程序还是在本地，当我们切换电脑的时候，无法对博客进行重新编辑和发布，这个时候我们可以在git添加一个分支<code>hexo</code>用来存放博客程序和编写的内容，详情可以参见： <a href="/2016-04-19/hexo-branch/">git创建分支hexo存放博客程序</a></p></blockquote><h2 id="8-域名绑定"><a href="#8-域名绑定" class="headerlink" title="8. 域名绑定"></a>8. 域名绑定</h2><blockquote><p>通常域名在<a href="https://www.godaddy.com/">godaddy</a>注册比较靠谱，这个是最大的域名提供商，而且不需要备案，支持支付宝付款，购买的时候可以使用优惠码会便宜一些，网上有很多优惠码，可以自行搜索，购买过程很简单，这里就不贴了</p></blockquote><ol><li><p>注册和配置DNS服务器<br><a href="https://www.godaddy.com/">Godaddy</a>自带的域名解析服务器比较慢，在国内推荐使用<a href="https://www.dnspod.cn/">DNSpod</a>：快，免费，稳定。</p><ul><li><p>到DNSpod注册登陆，然后到用户中心，添加域名，例如我的域名为<code>bomobox.org</code><br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-29/12170815.jpg" alt=""></p></li><li><p>进入设置<br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-29/72132532.jpg" alt=""><br>添加两个A记录指向github提供的ip，参见<a href="https://help.github.com/articles/setting-up-an-apex-domain/">这里</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.30.252.153</span><br><span class="line">192.30.252.154</span><br></pre></td></tr></table></figure><p>添加一个CNAME记录指向自己的github域名：<code>username.github.io</code><br>把其他的删除</p></li></ul></li><li><p>注册域名和配置DNS</p><ul><li><p>到<a href="https://www.godaddy.com/">Godaddy</a>购买域名完成后完成后进入<a href="https://mya.godaddy.com/">MyAccount</a><br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-29/12984808.jpg" alt=""></p></li><li><p>进入<code>DNS Manager</code>修改DNS服务器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure><p><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-29/60235109.jpg" alt=""></p></li></ul></li><li><p>到github仓库的根目录添加CNAME文件，文件内添加自己的域名，否则会出现404访问错误，也可以在hexo的<code>source</code>目录下添加，然后不熟到github<br><img src="http://7xqzvt.com1.z0.glb.clouddn.com/16-4-29/76622961.jpg" alt=""></p></li></ol><p>上面步骤设置完成后可能会有几个小时的延迟，才能生效，总的来说还是比较简单的</p><h2 id="9-问题"><a href="#9-问题" class="headerlink" title="9. 问题"></a>9. 问题</h2><p>在使用别人的主题的时候可能会报错或者有些功能用不了，原因可能是部分插件没有安装，例如RSS用不了，那可能是<code>hexo-generator-feed</code>没安装，下面列举一些常用的插件，建议都安装，没有用到也没有关系，需要先到hexo程序目录下在执行命令，插件位于<code>node_modules</code>目录下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-feed --save                  <span class="comment">#支持RSS</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-sitemap --save               <span class="comment">#生成站点地图</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-baidu-sitemap --save         <span class="comment">#生成百度站点地图</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-html-minifier --save                   <span class="comment">#HTML 压缩</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-uglify --save                          <span class="comment">#JavaScript 压缩</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-clean-css --save                       <span class="comment">#CSS 压缩插件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-seo-friendly-sitemap --save  <span class="comment">#SEO优化</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save                    <span class="comment">#git部署插件</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并在博客配置文件<code>_config.yml</code>配置plugin</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Plugins:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-feed</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure><blockquote><p>更多插件可以在<a href="https://hexo.io/plugins/">https://hexo.io/plugins/</a>找到</p></blockquote><h2 id="10-Atom插件"><a href="#10-Atom插件" class="headerlink" title="10. Atom插件"></a>10. Atom插件</h2><p>由于我编写md使用的是Atom，这里推荐几个Atom上的插件</p><ul><li><a href="https://atom.io/packages/markdown-scroll-sync">markdown-scroll-sync</a>：Markdown预览实时滚动，自带的预览不支持实时滚动</li><li><a href="https://atom.io/packages/markdown-writer">markdown-writer</a>：Markdown协作工具</li><li><a href="https://atom.io/packages/date">Date</a>：快速插入当前时间的工具</li><li><a href="https://atom.io/packages/atom-hexo">atom-hexo</a>：快速添加draft，post，publish，deploy</li></ul><h2 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h2><p>使用hexo搭建博客环境还是非常方便的，基本上都是自动的，当然还有一些详细的配置，例如分页，分类，评论等，Hexo支持的插件也相当多的，接下来可以好好写博客了，以后再慢慢完善了，今天先到这里</p><h2 id="12-参考链接"><a href="#12-参考链接" class="headerlink" title="12. 参考链接"></a>12. 参考链接</h2><blockquote><p><a href="https://hexo.io">https://hexo.io</a></p></blockquote><p>转自 <a href="http://blog.bomobox.org/2016-04-18/hexo-for-blog/">bomo大神的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blogs </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS开发--图文混排</title>
      <link href="2016-07-24/iOS-multi-graphic-solution-Frame-model/"/>
      <url>2016-07-24/iOS-multi-graphic-solution-Frame-model/</url>
      
        <content type="html"><![CDATA[<p>iOS开发中会遇到页面展示多图文的问题，尤其是新闻等图文混排，而且是图片不知道到宽高的情况。</p><p>此时就需要先异步下载图片然后根据得到的image通过 <code>宽高比</code>来更新对应ImageView的Frame。最后通过每个ImageView的Frame变化在重新更新多图文UI的Frame。</p><span id="more"></span><h3 id="根据页面设计得出页面的Frame模型"><a href="#根据页面设计得出页面的Frame模型" class="headerlink" title="根据页面设计得出页面的Frame模型"></a>根据页面设计得出页面的Frame模型</h3><p>   例：</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span> ,<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> noticeTitleF;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span> ,<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> noticeTimeF;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span> ,<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> noticeSenderF;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">assign</span> ,<span class="keyword">readonly</span>) <span class="built_in">CGRect</span> noticecontentF;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span> ,<span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *noticeImagesF;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span> ,<span class="keyword">strong</span> ,<span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *noticeImagesDespF;</span><br></pre></td></tr></table></figure><h3 id="给通过Frame模型中setModel方法来计算对应的Rect值"><a href="#给通过Frame模型中setModel方法来计算对应的Rect值" class="headerlink" title="给通过Frame模型中setModel方法来计算对应的Rect值"></a>给通过Frame模型中setModel方法来计算对应的Rect值</h3><ul><li>项目中的图文和标题内容是分开的 以AttachModel集合的方式返回过来，先假设集合中的每一项都有image和对应的描述来计算对应的Attach的ViewModelFrame，<br>例：<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i];</span><br><span class="line">ViewFrameModel *imageRect = [[ViewFrameModel alloc]init];</span><br><span class="line">imageRect.x = rightAndLeftMargin;</span><br><span class="line">imageRect.y = offsetY + upImageDespH;</span><br><span class="line">imageRect.width = contentWidth;</span><br><span class="line">imageRect.height = <span class="number">300</span>;</span><br><span class="line">[imagesF addObject:imageRect];  </span><br><span class="line"><span class="built_in">CGFloat</span> imageDespH = [BabyScheduleTaskHeaderFrame textFrameWithString:pictureTopicPost.desp width:contentWidth fontSize:WAWA_TEXTFONT_FLOAT_TITLE].height + <span class="number">2</span>;</span><br><span class="line">ViewFrameModel *imageDespRect = [[ViewFrameModel alloc]init];</span><br><span class="line">imageDespRect.x = rightAndLeftMargin;</span><br><span class="line">imageDespRect.y = offsetY + upImageDespH + <span class="number">300</span>;</span><br><span class="line">imageDespRect.width = contentWidth;</span><br><span class="line">imageDespRect.height = imageDespH;</span><br><span class="line">[imagesDespF addObject:imageDespRect];</span><br><span class="line">upImageDespH += (imageDespH +topAndBottomMargin + <span class="number">300</span>);</span><br></pre></td></tr></table></figure></li><li>根据集合下载对应的Image并更新Frame<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;attachs.count; i++) &#123;</span><br><span class="line">    HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i];</span><br><span class="line">    [<span class="keyword">self</span> getClassWeeklyTaskAttachPictureFrame:pictureTopicPost andIndex:i completion:^(<span class="built_in">NSInteger</span> index, <span class="built_in">CGFloat</span> imageH)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *imagesOldF = [<span class="built_in">NSMutableArray</span> arrayWithArray:_noticeImagesF];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *imagesDespOldF = [<span class="built_in">NSMutableArray</span> arrayWithArray:_noticeImagesDespF];</span><br><span class="line">        <span class="comment">//更新imageHeight</span></span><br><span class="line">        ViewFrameModel *pictureF = imagesOldF [index];</span><br><span class="line">        pictureF.height = imageH;</span><br><span class="line">        [imagesOldF replaceObjectAtIndex:index withObject:pictureF];</span><br><span class="line">        ViewFrameModel *oldpictureFM = [imagesOldF firstObject];</span><br><span class="line">        <span class="built_in">CGRect</span> oldpictureR = <span class="built_in">CGRectMake</span>(oldpictureFM.x, oldpictureFM.y, oldpictureFM.width, oldpictureFM.height);</span><br><span class="line"></span><br><span class="line">        ViewFrameModel *oldpictureDespFM = [imagesDespOldF firstObject];</span><br><span class="line">        oldpictureDespFM.y = <span class="built_in">CGRectGetMaxY</span>(oldpictureR) + topAndBottomMargin;</span><br><span class="line">        [imagesDespOldF replaceObjectAtIndex:<span class="number">0</span> withObject:oldpictureDespFM];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGFloat</span> oldOffsetY = offsetY + oldpictureFM.height + topAndBottomMargin + oldpictureDespFM.height + topAndBottomMargin;</span><br><span class="line">        <span class="comment">//遍历集合 重新赋值frame</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;imagesOldF.count; m++) &#123;</span><br><span class="line">            oldOffsetY = oldOffsetY;</span><br><span class="line">            ViewFrameModel *uppictureF = imagesOldF [m];</span><br><span class="line">            uppictureF.y = oldOffsetY;</span><br><span class="line">            [imagesOldF replaceObjectAtIndex:m withObject:uppictureF];</span><br><span class="line">            oldOffsetY = oldOffsetY + uppictureF.height + topAndBottomMargin;</span><br><span class="line">            ViewFrameModel *uppictureDespF = imagesDespOldF [m];</span><br><span class="line">            uppictureDespF.y = oldOffsetY;</span><br><span class="line">            [imagesDespOldF replaceObjectAtIndex:m withObject:uppictureDespF];</span><br><span class="line">            oldOffsetY = oldOffsetY + uppictureDespF.height + topAndBottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        _noticeFooterF = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, oldOffsetY + topAndBottomMargin*<span class="number">4</span>, Main_Screen_Width, <span class="number">1</span>);</span><br><span class="line">        _noticeHeaderHeight = <span class="built_in">CGRectGetMaxY</span>(_noticeFooterF);</span><br><span class="line">        _noticeImagesF = imagesOldF;</span><br><span class="line">        _noticeImagesDespF = imagesDespOldF;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.reloadNoticeHeaderFrameBlock) &#123;</span><br><span class="line">          <span class="comment">//更新页面Frame回调Block</span></span><br><span class="line">            <span class="keyword">self</span>.reloadNoticeHeaderFrameBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="根据设计编写多图文的UIView代码"><a href="#根据设计编写多图文的UIView代码" class="headerlink" title="根据设计编写多图文的UIView代码"></a>根据设计编写多图文的UIView代码</h3><p>   有多图文对象的个数来绘制页面并保存到数组中<br>   <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_imageArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:_momentPicturesCount];</span><br><span class="line">_imageDespArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:_momentPicturesCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; _momentPicturesCount;i++) &#123;</span><br><span class="line">    <span class="built_in">UIImageView</span> *picView = [[<span class="built_in">UIImageView</span> alloc]init];</span><br><span class="line">    picView.tag = i;</span><br><span class="line">    picView.image = [<span class="built_in">UIImage</span> imageNamed: (<span class="string">@&quot;childshow_placeholder&quot;</span>)];</span><br><span class="line">    picView.userInteractionEnabled = <span class="literal">YES</span>;</span><br><span class="line">    [picView addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc]initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(showPicture:)]];</span><br><span class="line">    [_imageArray addObject:picView];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:picView];</span><br><span class="line"></span><br><span class="line">    AutoLinkLabel *imageDespLabel = [[AutoLinkLabel alloc]init];</span><br><span class="line">    imageDespLabel.font = [<span class="built_in">UIFont</span> systemFontOfSize:WAWA_TEXTFONT_FLOAT_CONTENT_BIG];</span><br><span class="line">    imageDespLabel.textColor = WAWA_TEXTCOLOR_DARKGRAY;</span><br><span class="line">    imageDespLabel.aDelegate = <span class="keyword">self</span>;</span><br><span class="line">    imageDespLabel.numberOfLines = <span class="number">0</span>;</span><br><span class="line">    [_imageDespArray addObject:imageDespLabel];</span><br><span class="line">    [<span class="keyword">self</span> addSubview:imageDespLabel];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在UIView的setModel中给页面控件赋值Frame和Content"><a href="#在UIView的setModel中给页面控件赋值Frame和Content" class="headerlink" title="在UIView的setModel中给页面控件赋值Frame和Content"></a>在UIView的setModel中给页面控件赋值Frame和Content</h3><p> 由计算好的Frame在重新给已保存好的多图文集合赋值并替换</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs.count; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = <span class="keyword">self</span>.imageArray[i];</span><br><span class="line">    ViewFrameModel *frameModel = babyScheduleTaskHeaderFrame.noticeImagesF[i];</span><br><span class="line">    imageView.frame = <span class="built_in">CGRectMake</span>(frameModel.x, frameModel.y, frameModel.width, frameModel.height);</span><br><span class="line">    <span class="comment">//NSLog(@&quot;image%ld, offsetY:%ld,height :%ld&quot;,i,frameModel.y,frameModel.height);</span></span><br><span class="line"></span><br><span class="line">    AutoLinkLabel *imageDespL = <span class="keyword">self</span>.imageDespArray[i];</span><br><span class="line">    ViewFrameModel *despframeModel = babyScheduleTaskHeaderFrame.noticeImagesDespF[i];</span><br><span class="line">    imageDespL.frame = <span class="built_in">CGRectMake</span>(despframeModel.x, despframeModel.y, despframeModel.width, despframeModel.height);</span><br><span class="line">    <span class="comment">//NSLog(@&quot;imageDesp%ld, offsetY:%ld,height :%ld&quot;,i,despframeModel.y,despframeModel.height);</span></span><br><span class="line"></span><br><span class="line">    HedoneAttachDTO *pictureTopicPost = babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs[i];</span><br><span class="line">    [imageView setImageWithURLStr:pictureTopicPost.addr placeholder:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@&quot;childshow_placeholder&quot;</span>]];</span><br><span class="line">    imageDespL.autoLinkText = pictureTopicPost.desp?pictureTopicPost.desp:<span class="string">@&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.imageArray replaceObjectAtIndex:i withObject:imageView];</span><br><span class="line">    [<span class="keyword">self</span>.imageDespArray replaceObjectAtIndex:i withObject:imageDespL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将UIView赋值给TableViewHeader"><a href="#将UIView赋值给TableViewHeader" class="headerlink" title="将UIView赋值给TableViewHeader"></a>将UIView赋值给TableViewHeader</h3><p>定义多图文frameModel对象并设置detailModel</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">BabyScheduleTaskHeaderFrame *detailHeaderFrame = [[BabyScheduleTaskHeaderFrame alloc]init];</span><br><span class="line">detailHeaderFrame.hedoneClassWeeklyTaskResponse = model;</span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) selfVc = <span class="keyword">self</span>;</span><br><span class="line">detailHeaderFrame.reloadNoticeHeaderFrameBlock = ^()&#123;</span><br><span class="line">  <span class="comment">//回调更新Frame</span></span><br><span class="line">    selfVc.babyScheduleTaskHeaderView.babyScheduleTaskHeaderFrame = selfVc.babyScheduleTaskHeaderFrame;</span><br><span class="line">    <span class="built_in">CGRect</span> oldHeaderF = selfVc.babyScheduleTaskHeaderView.frame;</span><br><span class="line">    oldHeaderF.size.height = selfVc.babyScheduleTaskHeaderFrame.noticeHeaderHeight;</span><br><span class="line">    selfVc.babyScheduleTaskHeaderView.frame = oldHeaderF;</span><br><span class="line">    selfVc.tableView.tableHeaderView = selfVc.babyScheduleTaskHeaderView;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">self</span>.babyScheduleTaskHeaderFrame = detailHeaderFrame;</span><br><span class="line">BabyScheduleTaskHeaderView *detailHeaderView = [[BabyScheduleTaskHeaderView alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, Main_Screen_Width, detailHeaderFrame.noticeHeaderHeight) andMomentPicturesCount:(<span class="keyword">int</span>)model.attachs.count];</span><br><span class="line">detailHeaderView.babyScheduleTaskHeaderFrame = detailHeaderFrame;</span><br><span class="line"><span class="keyword">self</span>.babyScheduleTaskHeaderView = detailHeaderView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.tableView.tableHeaderView = <span class="keyword">self</span>.babyScheduleTaskHeaderView;</span><br></pre></td></tr></table></figure><h3 id="更多具体实现请下载源码"><a href="#更多具体实现请下载源码" class="headerlink" title="更多具体实现请下载源码"></a>更多具体实现请下载源码</h3><ul><li><a href="https://github.com/fangliquan/iOS-Technology-development">下载源码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS Project Practice </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS多图文 </tag>
            
            <tag> 图文混排 </tag>
            
            <tag> Frame模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS新特性学习--泛型</title>
      <link href="2016-07-23/iOS9-new-feature-generic/"/>
      <url>2016-07-23/iOS9-new-feature-generic/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型：限制类型"><a href="#泛型：限制类型" class="headerlink" title="泛型：限制类型"></a>泛型：限制类型</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>在集合（数组，字典，NSSet)中使用泛型比较常见</li><li>当声明一个类，类里面的某些书写的类型不确定，这时候我们才使用泛型。<br>z<span id="more"></span></li></ol><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><ol><li>在类型后面定义泛型，<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *mutableArray</span><br></pre></td></tr></table></figure></li></ol><h2 id="修饰："><a href="#修饰：" class="headerlink" title="修饰："></a>修饰：</h2><p>只能修饰方法的调用</p><h2 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h2><ol><li>提高规范，减少交流</li><li>通过集合取出来对象，直接当做泛型对象使用，可以直接使用点语法<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.mutableArray[<span class="number">0</span>].temp;</span><br></pre></td></tr></table></figure></li></ol><h2 id="子类想给父类赋值使用协变"><a href="#子类想给父类赋值使用协变" class="headerlink" title="子类想给父类赋值使用协变"></a>子类想给父类赋值使用协变</h2><p><code>__covariant</code>(协变）:用于数据强转类型，可以向上强转，子类，可以转成 父类，例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="父类强转成子类-逆变"><a href="#父类强转成子类-逆变" class="headerlink" title="父类强转成子类 逆变"></a>父类强转成子类 逆变</h2><p><code>__contravariant</code>（逆变）：用于泛型数据强转类型，可以向下强转，父类可以转成子类 例:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>&lt;<span class="title">__contravariant</span> <span class="title">ObjectType</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>&lt;<span class="title">__covariant</span> <span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) ObjectType language;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> runtime </tag>
            
            <tag> iOS9新特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2016-07-22/hello-world/"/>
      <url>2016-07-22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>世界上的第一个程序就是Hello World！！</p><p>I am a  programmer.</p><p> I like programming.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>swift学习笔记</title>
      <link href="2016-06-28/swift-start/"/>
      <url>2016-06-28/swift-start/</url>
      
        <content type="html"><![CDATA[<p>一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性<br>swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子</p><span id="more"></span><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><ul><li>swift语句结束不需要分号（写了也没有问题），有一种情况需要分号，如果一行代码中有多条语句，这时候就必须要分号隔开</li><li>swift字符串，数组语法糖，字典语法糖不需要<code>@</code>标示</li><li>swift是类型安全的语言，所有的类型都不会自动转换（如：Int和UInt类型不能直接运算），同事swift具有强大的类型推测，所以很多时候我们不需要声明类型</li><li>swift的多行注释支持嵌套<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是第一个多行注释的开头</span></span><br><span class="line"><span class="comment"><span class="comment">/* 这是第二个被嵌套的多行注释 */</span></span></span><br><span class="line"><span class="comment">这是第一个多行注释的结尾 */</span></span><br></pre></td></tr></table></figure></li><li>swift的布尔值使用小写true和false，判断语句只能使用Bool类型</li></ul><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><ul><li>与objc一样，swift支持以前（objc）使用的所有数据类型，swift的类型名字首字母大写，如Int, Float, NSInteger</li><li>swift支持可选类型（Optionals）类型，相当于C#中的可空类型，标识变量可能为空，基础数据类型也可为空，可选类型不能直接赋非可选类型<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span>? <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span> <span class="operator">=</span> a          <span class="comment">// 报错，不同类型不能赋值</span></span><br></pre></td></tr></table></figure></li><li>swift的布尔类型使用<code>true/false</code>，而不用<code>YES/NO</code></li><li>swift支持使用<code>_</code>来分割数值来增强可读性而不影响值，如一亿可以表示为下面形式<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMillion <span class="operator">=</span> <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure></li><li>swift数值类型进行运算符计算的时候不会自动进行类型转换，通常可以通过类型的构造方法进行类型转换<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Float</span> <span class="operator">=</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">var</span> c <span class="operator">=</span> a <span class="operator">+</span> b           <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> <span class="type">Float</span>(a) <span class="operator">+</span> b    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li>swift的基础数据类型与对象类型一视同仁，可以混用，不需要装箱和拆箱</li></ul><h3 id="TODO：Any-AnyObject"><a href="#TODO：Any-AnyObject" class="headerlink" title="TODO：Any, AnyObject,"></a>TODO：Any, AnyObject,</h3><h2 id="三、常量变量"><a href="#三、常量变量" class="headerlink" title="三、常量变量"></a>三、常量变量</h2><ul><li>与<code>C/Obj-C</code>不同，swift的常量更为广义，支持<strong>任意类型</strong>，常量只能赋值一次</li><li>swift的变量和常量在声明的时候类型就已经确定（由编译器自动识别或开发者指定）</li><li>使用let声明的集合为可变集合，使用var声明的集合为不可变集合</li><li>如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。这样可以尽量数据安全，并且常量是线程安全</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量：使用let声明，赋值后就不能再修改</span></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">NSMutableArray</span>()</span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="type">Float</span> <span class="operator">=</span> <span class="number">12</span>       <span class="comment">// 类型标注(type annotation)</span></span><br><span class="line"><span class="keyword">let</span> d <span class="operator">=</span> b <span class="operator">+</span> <span class="number">12</span></span><br><span class="line">a.addObject(<span class="number">11</span>)         <span class="comment">// str == [11]</span></span><br><span class="line"><span class="keyword">let</span> e <span class="operator">=</span> a               <span class="comment">// str == [11], d == [11]</span></span><br><span class="line">a.addObject(<span class="number">12</span>)         <span class="comment">// str == [11, 12], d == [11, 12]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量：使用var声明</span></span><br><span class="line"><span class="keyword">var</span> f: <span class="type">Double</span>? <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">var</span> g <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="类型标注"><a href="#类型标注" class="headerlink" title="类型标注"></a>类型标注</h3><p>在声明变量和常量的时候可以如果可以由编译器自动识别，可以不用制定类型，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">12</span>    <span class="comment">//常量a会编译为Int类型</span></span><br><span class="line"><span class="keyword">var</span> b <span class="operator">=</span> <span class="number">1.3</span>   <span class="comment">//变量b会编译为Double类型</span></span><br></pre></td></tr></table></figure><p>我们也可以指定类型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Double</span> <span class="operator">=</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Float</span> <span class="operator">=</span> <span class="number">1.3</span></span><br></pre></td></tr></table></figure><p>可以在一行声明多个变量/常量，在最后一个声明类型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> red, green, blue: <span class="type">UInt</span></span><br></pre></td></tr></table></figure><h2 id="四、序列和集合"><a href="#四、序列和集合" class="headerlink" title="四、序列和集合"></a>四、序列和集合</h2><h3 id="1-数组Array"><a href="#1-数组Array" class="headerlink" title="1. 数组Array"></a>1. 数组Array</h3><p>swift的数组可以是有类型的（泛型），存放同类型的数据，如果添加一个错误的类型会报编译错误，默认情况下编译器会自动识别</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 数组的写法为：Array&lt;Int&gt;，也可以简写成[Int]</span></span><br><span class="line"><span class="comment">//2. 数组初始化与NSArray类似，直接用中括号括起来，里面值用逗号隔开</span></span><br><span class="line"><span class="keyword">var</span> array0 <span class="operator">=</span> [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> array1: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">var</span> array2: <span class="type">Array</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> array1</span><br><span class="line"></span><br><span class="line">array1.append(<span class="number">11</span>)             <span class="comment">// [1, 3, 5, 7, 9, 11]</span></span><br><span class="line">array1.insert(<span class="number">0</span>, atIndex: <span class="number">0</span>)  <span class="comment">// [0, 1, 3, 5, 7, 9, 11]</span></span><br><span class="line">array1.isEmpty                <span class="comment">// False</span></span><br><span class="line">array1.count                  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果初始化时不指定类型，而编译器也不能识别出类型，这时候，会被当成NSArray处理</span></span><br><span class="line"><span class="keyword">var</span> array3 <span class="operator">=</span> []                       <span class="comment">// array3 为 NSArray类型的空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果声明的时候使用不同的类型，编译器会把数组识别为NSObject类型</span></span><br><span class="line"><span class="keyword">var</span> array4 <span class="operator">=</span> [<span class="string">&quot;fdsa&quot;</span>, <span class="number">121</span>]            <span class="comment">// array4 为 Array&lt;NSObject&gt; 类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 集合支持加法运算，相当于NSMutableArray的addObjectsFromArray</span></span><br><span class="line">array1 <span class="operator">+=</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]    <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 使用let声明的数组不可变，不能修改数组array3</span></span><br><span class="line"><span class="keyword">let</span> array5: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">//array5.append(2)              // 报编译错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 集合使用下标索引，支持区间索引，区间不可越界</span></span><br><span class="line"><span class="keyword">var</span> array6: [<span class="type">Int</span>] <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">array6[<span class="number">1</span>] <span class="operator">=</span> <span class="number">4</span>                       <span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line">array6[<span class="number">1</span><span class="operator">...</span><span class="number">3</span>] <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]           <span class="comment">// [1, 2, 3, 4, 9]</span></span><br><span class="line">array6[<span class="number">0</span><span class="operator">...</span><span class="number">2</span>] <span class="operator">=</span> array6[<span class="number">1</span><span class="operator">...</span><span class="number">3</span>]       <span class="comment">// [2, 3, 4, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 迭代数组的时候，如果需要索引，可以用enumerate方法</span></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> array4.enumerated() &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-字典Dictionary"><a href="#2-字典Dictionary" class="headerlink" title="2. 字典Dictionary"></a>2. 字典Dictionary</h3><p>与数组类型一样，字典也支持泛型，其键值类型都可以指定或有编译器识别，其中Key的类型，必须是可Hash的，swift中基础数据类型都是可hash的（String、Int、Double和Bool）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 用法与oc类似，初始化不需要@</span></span><br><span class="line"><span class="keyword">var</span> dict1 <span class="operator">=</span> [<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>: <span class="number">2</span>, <span class="string">&quot;key3&quot;</span>: <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 声明方式</span></span><br><span class="line"><span class="keyword">var</span> dict2: <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt; <span class="operator">=</span> dict1        <span class="comment">//dict2与dict1不是一个对象</span></span><br><span class="line"><span class="keyword">var</span> dict3: [<span class="type">String</span>: <span class="type">Int</span>] <span class="operator">=</span> dict1                  <span class="comment">//通常采用这种方式声明类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 不声明类型，编译器又无法识别，则为NSDictionary</span></span><br><span class="line"><span class="keyword">var</span> dict4 <span class="operator">=</span> [:]</span><br><span class="line"><span class="keyword">var</span> dict5: [<span class="type">Int</span>: <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 修改或添加键值对</span></span><br><span class="line">dict1[<span class="string">&quot;key3&quot;</span>] <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 删除键</span></span><br><span class="line">dict1[<span class="string">&quot;key3&quot;</span>] <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. key不存在不报错，返回可空类型nil</span></span><br><span class="line"><span class="keyword">let</span> value4 <span class="operator">=</span> dict1[<span class="string">&quot;key4&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 字典迭代返回key/value元组，类似python</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dict1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(key)</span> = <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组（Array）或字典（Dictionary），如果声明为变量（var），则为可变，如果为常量（let），则为不可变<br>常量数组或字典编译器会对其进行优化，所以尽量把不可变的数组定义为常量数组</p></blockquote><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h3><p>Set集合用于存放无序不重复的对象，用法与数组类似，重复的项会被忽略</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s: <span class="type">Set</span>&lt;<span class="type">Int</span>&gt; <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>]    <span class="comment">// [1, 3, 4, 5, 6, 7]</span></span><br><span class="line">s.count</span><br><span class="line">s.isEmpty</span><br><span class="line">s.insert(<span class="number">3</span>)</span><br><span class="line">s.remove(<span class="number">3</span>)</span><br><span class="line">s.contains(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>集合操作</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oddDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> evenDigits: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> singleDigitPrimeNumbers: <span class="type">Set</span> <span class="operator">=</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//合操作</span></span><br><span class="line">oddDigits.union(evenDigits).sort()                <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交操作</span></span><br><span class="line">oddDigits.intersection(evenDigits).sorted()       <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//减操作</span></span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()           <span class="comment">// [1, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不重叠集合</span></span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()   <span class="comment">// [1, 2, 9]</span></span><br></pre></td></tr></table></figure><ul><li>使用“是否相等”运算符( == )来判断两个 合是否包含全部相同的值。</li><li>使用 isSubset(of:) 方法来判断一个 合中的值是否也被包含在另外一个 合中。</li><li>使用 isSuperset(of:) 方法来判断一个 合中包含另一个 合中所有的值。</li><li>使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。</li><li>使用 isDisjoint(with:) 方法来判断两个 合是否不含有相同的值(是否没有交 )</li></ul><h3 id="4-元组Tuple"><a href="#4-元组Tuple" class="headerlink" title="4. 元组Tuple"></a>4. 元组Tuple</h3><p>与python类似，swift也支持元组，可以很方便的使用元组包装多个值，也使得函数返回多个值变得更加方便，特别是临时组建值得时候</p><ul><li>支持任意类型</li><li>支持同时赋值</li><li>支持自定义key，支持索引</li><li><strong>元组不是对象，不是<code>AnyObject</code>类型，由于swift是强类型的，所以元组有时不能当做普通的对象使用，例如不能把元组加到数组里面，元组内的所有类型必须是明确的</strong></li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 声明一个元组，元组支持任意类型</span></span><br><span class="line"><span class="keyword">let</span> httpError1 <span class="operator">=</span> (<span class="number">404</span>, <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> point <span class="operator">=</span> (<span class="number">100</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可以分别赋值</span></span><br><span class="line"><span class="keyword">let</span> (x, y) <span class="operator">=</span> point</span><br><span class="line"><span class="built_in">print</span>(x)      <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">print</span>(y)      <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用下标取元组元素，下标从0开始</span></span><br><span class="line"><span class="built_in">print</span>(httpError1.<span class="number">0</span>)      <span class="comment">// 404</span></span><br><span class="line"><span class="built_in">print</span>(httpError1.<span class="number">1</span>)      <span class="comment">// Not Found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 可以给数组元素取名</span></span><br><span class="line"><span class="keyword">let</span> httpError2 <span class="operator">=</span> (code: <span class="number">404</span>, errorMessage: <span class="string">&quot;Not Found&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(httpError2.code)               <span class="comment">// 404</span></span><br><span class="line"><span class="built_in">print</span>(httpError2.errorMessage)       <span class="comment">// Not Found</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 可以用下划线表示忽略部分值</span></span><br><span class="line"><span class="keyword">let</span> (a, <span class="keyword">_</span>) <span class="operator">=</span> point</span><br></pre></td></tr></table></figure><blockquote><p>元组在临时组织值得时候很有用，可以不用重新定义数据结构</p></blockquote><h3 id="5-字符串String"><a href="#5-字符串String" class="headerlink" title="5. 字符串String"></a>5. 字符串String</h3><p>swift字符串是由Character字符组成的集合，支持<code>+</code>操作符，可以与NSString无缝桥接，swift的字符串完全兼容unicode<br>字符串与值类型（与Int, Float）一样，是值类型，在传值的时候都会进行拷贝，当然这回带来一定的性能损耗，<em>swift编译器在编译的时候会进行优化，保证只在必要的情况下才进行拷贝</em></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 与NSString不同，声明不需要@前缀，支持转移字符</span></span><br><span class="line"><span class="keyword">let</span> name1 <span class="operator">=</span> <span class="string">&quot;bomo<span class="subst">\n</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 空串（下面两种方式等价）</span></span><br><span class="line"><span class="keyword">let</span> name2 <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">let</span> name3 <span class="operator">=</span> <span class="type">String</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 字符串由字符Character组成，定义字符</span></span><br><span class="line"><span class="keyword">let</span> character1: <span class="type">Character</span> <span class="operator">=</span> <span class="string">&quot;!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 常见属性，方法</span></span><br><span class="line">name1.isEmpty                   <span class="comment">// 判空</span></span><br><span class="line">name1.characters.count          <span class="comment">// 获取字符串的字符数</span></span><br><span class="line">name1.uppercaseString</span><br><span class="line">name1.lowercaseString</span><br><span class="line">name1.hasPrefix(<span class="string">&quot;bo&quot;</span>)</span><br><span class="line">name1.hasSuffix(<span class="string">&quot;mo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 加法运算</span></span><br><span class="line"><span class="keyword">let</span> hello <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> <span class="operator">+</span> name1   <span class="comment">// hello bomo\n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 比较（比较值，而不是地址）</span></span><br><span class="line"><span class="keyword">let</span> name4 <span class="operator">=</span> <span class="string">&quot;b&quot;</span> <span class="operator">+</span> <span class="string">&quot;omo<span class="subst">\n</span>&quot;</span></span><br><span class="line">name4 <span class="operator">==</span> name1                 <span class="comment">// True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 字符串插值（使用反斜杠和括号站位）</span></span><br><span class="line"><span class="keyword">let</span> city <span class="operator">=</span> <span class="string">&quot;广州&quot;</span></span><br><span class="line"><span class="keyword">let</span> hello2 <span class="operator">=</span> <span class="string">&quot;I&#x27;m <span class="subst">\(name1)</span> from <span class="subst">\(city)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 格式化字符串</span></span><br><span class="line"><span class="keyword">let</span> f <span class="operator">=</span> <span class="number">123.3233</span></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">String</span>(format: <span class="string">&quot;%.2f&quot;</span>, f)     <span class="comment">//123.32</span></span><br></pre></td></tr></table></figure><h3 id="6-集合的赋值和拷贝行为"><a href="#6-集合的赋值和拷贝行为" class="headerlink" title="6. 集合的赋值和拷贝行为"></a>6. 集合的赋值和拷贝行为</h3><p>swift的集合通常有Array和Dictionary，他们在赋值或传递的时候，行为上有所不同，字典类型Dictionary或数组类型Array在赋值给变量或常量的时候，只要有做修改，就会进行值拷贝，并且不会作用到原来变量上</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dict1 <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>]</span><br><span class="line"><span class="keyword">var</span> dict2 <span class="operator">=</span> dict1</span><br><span class="line"><span class="built_in">print</span>(dict1 <span class="operator">==</span> dict2)         <span class="comment">// true</span></span><br><span class="line">dict2[<span class="string">&quot;a&quot;</span>] <span class="operator">=</span> <span class="number">3</span>                <span class="comment">// 修改dict2</span></span><br><span class="line"><span class="built_in">print</span>(dict1 <span class="operator">==</span> dict2)         <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr1 <span class="operator">=</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 <span class="operator">=</span> arr1</span><br><span class="line"><span class="built_in">print</span>(arr1 <span class="operator">==</span> arr2)           <span class="comment">// true</span></span><br><span class="line">arr1[<span class="number">0</span>] <span class="operator">=</span> <span class="string">&quot;c&quot;</span>                 <span class="comment">// 修改arr1</span></span><br><span class="line"><span class="comment">// arr1.append(&quot;c&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(arr1 <span class="operator">==</span> arr2)           <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>当数组或字典作为参数传递给函数的时候，由于在Swift3中不推荐使用变量参数，故所有函数参数不可变，故也不进行拷贝</p><h2 id="五、可选类型（可空类型）"><a href="#五、可选类型（可空类型）" class="headerlink" title="五、可选类型（可空类型）"></a>五、可选类型（可空类型）</h2><p>swift加入了可空类型让我们使用数据的时候更为安全，我们需要在可空的地方使用可选类型声明该变量可为空，不能给非可选类型设值<code>nil</code>值，在使用的时候可以明确的知道对象是否可能为nil，有点像ObjC的对象，对象可以为nil，也可以不为nil，而swift得可选类型范围更广可以作用于任何类型（基础类型，类，结构体，枚举）</p><h3 id="1-声明"><a href="#1-声明" class="headerlink" title="1. 声明"></a>1. 声明</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 声明可选类型，在类型后面加上?</span></span><br><span class="line"><span class="keyword">var</span> obj1: <span class="type">NSObject</span>?</span><br><span class="line">obj1 <span class="operator">=</span> <span class="type">NSObject</span>()</span><br><span class="line">obj1 <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 不能给一个可选类型赋nil，下面会报错，</span></span><br><span class="line"><span class="keyword">var</span> obj <span class="operator">=</span> <span class="type">NSObject</span>()</span><br><span class="line">obj <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果声明可选变量时没有赋值，则默认为nil</span></span><br><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>?</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 一个函数返回一个可选类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getdog</span>()</span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;wangcai&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 不能把可选类型赋值给非可选类型，下面会报错</span></span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog</span><br></pre></td></tr></table></figure><h3 id="2-强制解析"><a href="#2-强制解析" class="headerlink" title="2. 强制解析"></a>2. 强制解析</h3><p>可选类型不能直接使用，需要通过取值操作符<code>!</code>取得变量的值，才能使用，如果变量有值，则返回该值，如果变量为空，则会运行时错误</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b: <span class="type">Int</span>?</span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Int</span></span><br><span class="line">a <span class="operator">=</span> <span class="number">12</span></span><br><span class="line">b <span class="operator">=</span> <span class="number">13</span></span><br><span class="line"><span class="keyword">let</span> c <span class="operator">=</span> a <span class="operator">+</span> b<span class="operator">!</span>              <span class="comment">// 先对b取值，再运算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> b<span class="operator">!</span> &#123;                     <span class="comment">// b为空，编译不报错，运行时报错</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-可选绑定"><a href="#3-可选绑定" class="headerlink" title="3. 可选绑定"></a>3. 可选绑定</h3><p>使用可选绑定可以判断一个可选类型是否有值，如果有值，则绑定到变量上，如果没有值，返回false，使用<code>if-let</code>组合实现</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number <span class="operator">=</span> i &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(number)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选绑定还支持绑定条件</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i: <span class="type">Int</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> number <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">10</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i不为空且大于10 <span class="subst">\(number)</span>&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选绑定还支持多个绑定，不许所有的绑定都满足才返回true</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="number">1</span>, <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 &quot;4 &lt; 42 &lt; 100&quot;</span></span><br><span class="line"> <span class="keyword">if</span> <span class="keyword">let</span> firstNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;4&quot;</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">let</span> secondNumber <span class="operator">=</span> <span class="type">Int</span>(<span class="string">&quot;42&quot;</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> firstNumber <span class="operator">&lt;</span> secondNumber <span class="operator">&amp;&amp;</span> secondNumber <span class="operator">&lt;</span> <span class="number">100</span> &#123;</span><br><span class="line">             <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(firstNumber)</span> &lt; <span class="subst">\(secondNumber)</span> &lt; 100&quot;</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-隐式解析"><a href="#4-隐式解析" class="headerlink" title="4. 隐式解析"></a>4. 隐式解析</h3><p>声明类型的时候可以使用隐式解析，即在使用可选变量的时候自动取值，不需要调用<code>!</code>操作符，</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个函数返回一个可选类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getdog</span>()</span> -&gt; <span class="type">String</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;wangcai&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假定我们通过getdog方法返回的值一定不为空</span></span><br><span class="line"><span class="keyword">var</span> dog: <span class="type">String</span>? <span class="operator">=</span> getdog()</span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog<span class="operator">!</span>          <span class="comment">// 使用前需要通过!强制取值</span></span><br></pre></td></tr></table></figure><p>使用dog的时候都需要取值我们觉得太麻烦了，可以声明成隐式可选类型，使用的时候自动取值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dog: <span class="type">String</span>! <span class="operator">=</span> getdog()     <span class="comment">// 实际上dog还是可选类型，只是使用的时候回自动取值</span></span><br><span class="line"><span class="keyword">let</span> cat: <span class="type">String</span> <span class="operator">=</span> dog           <span class="comment">// 在使用dog的时候会自动进行取值，不需要取值操作符</span></span><br></pre></td></tr></table></figure><h3 id="5-可选类型自判断链接"><a href="#5-可选类型自判断链接" class="headerlink" title="5. 可选类型自判断链接"></a>5. 可选类型自判断链接</h3><p>在使用可选类型之前，需要进行判断其是否有值，才能使用，通过<code>!</code>操作符取值后使用（保证有值的情况下），或通过<code>if-let</code>可选绑定的方式，swift提供了一种类似C#语言的语法糖可以让代码更为简洁，可以自动判断值，如果有值，则操作，无值则不操作，并返回nil，在使用前加上<code>?</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> favDog: <span class="type">Dog</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">var</span> d <span class="operator">=</span> <span class="type">Dog</span>()</span><br><span class="line"><span class="comment">// p.favDog = d</span></span><br><span class="line">p.favDog<span class="operator">?</span>.name <span class="operator">=</span> <span class="string">&quot;tobi&quot;</span>   <span class="comment">// 如果p.favDog为空，不设置name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> name <span class="operator">=</span> p.favDog<span class="operator">?</span>.name &#123;</span><br><span class="line">    <span class="comment">// p.favDog不为空且p.favDog.name不为空</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// p.favDog为空或p.favDog.name为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自判断链接还支持多连接如</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> identifier <span class="operator">=</span> john.residence<span class="operator">?</span>.address<span class="operator">?</span>.buildingIdentifier</span><br></pre></td></tr></table></figure><h3 id="6-可选关联运算符"><a href="#6-可选关联运算符" class="headerlink" title="6. 可选关联运算符"></a>6. 可选关联运算符</h3><p>可选关联运算符可对可选类型进行拆包，如果可选类型对象为nil，返回第二个操作数，第二个操作数类型必须和第一个操作数同类型（可选或不可选）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultColorName <span class="operator">=</span> <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> userDefinedColorName: <span class="type">String</span>?   <span class="comment">// defaults to nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colorNameToUse <span class="operator">=</span> userDefinedColorName <span class="operator">??</span> defaultColorName</span><br></pre></td></tr></table></figure><ul><li>defaultColorName和userDefinedColorName必须是同类型（String或String?）</li><li>如果userDefinedColorName不为空，返回其值，如果userDefinedColorName为空，返回defaultColorName</li><li>返回值colorNameToUse的类型同<code>??</code>的第二个操作数的类型，为<code>String</code></li></ul><h2 id="六、运算符"><a href="#六、运算符" class="headerlink" title="六、运算符"></a>六、运算符</h2><p>swift运算符在原有的基础上做了一些改进，还添加了一下更高级的用法，还有新的运算符</p><ul><li><p><code>=</code>运算符不返回值</p></li><li><p>符合运算符<code>+=</code>, <code>-=</code>等不返回值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面语句会报错</span></span><br><span class="line"><span class="keyword">let</span> b <span class="operator">=</span> a <span class="operator">*=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>比较运算符可以用于元组的比较（逐个比较，如果遇到不等的元素，则返回，默认最多只能比较7个元素的元组，超过则需要自定义）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="string">&quot;zebra&quot;</span>) <span class="operator">&lt;</span> (<span class="number">2</span>, <span class="string">&quot;apple&quot;</span>)     <span class="comment">// true，因为 1 小于 2</span></span><br></pre></td></tr></table></figure></li><li><p>字符串String，字符Character支持<code>+</code>运算符</p></li><li><p>浮点数支持<code>%</code>求余运算</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="operator">%</span> <span class="number">2.5</span> <span class="comment">// 等于 0.5</span></span><br></pre></td></tr></table></figure></li><li><p><code>++/--</code>运算在swift3被抛弃，用<code>+=/-=</code>代替</p></li><li><p>支持溢出运算符（<code>&amp;+</code>, <code>&amp;-</code>, <code>&amp;*</code>），可以在溢出时进行(高位)截断</p></li><li><p>支持位运算符（<code>&gt;&gt;</code>, <code>&lt;&lt;</code>）</p></li><li><p>支持三目运算符（<code>a ? b : c</code>）</p></li><li><p>支持逻辑运算符（<code>&amp;&amp;</code>, <code>||</code>, <code>!</code>）</p></li><li><p>与其他高级语言类似，swift运算符支持重载，可以为类添加自定义的运算符逻辑，后面会讲到</p></li><li><p><code>!=</code>, <code>==</code>, <code>===</code>, <code>!==</code>（恒等于/不恒等于）</p><pre><code>`===`：这两个操作符用于引用类型，用于判断两个对象是否指向同一地址`!===`：与`===`相反，表示两个变量/常量指向的的地址不同`==`：表示两个对象逻辑相等，可以通过重载运算符实现相等的逻辑，两个值相等的对象可以是不同地址的对象`!=`：与`==`相反，表示两个对象逻辑不等</code></pre></li><li><p>区间运算符<br>  可以使用<code>a...b</code>表示一个范围，有点类似于Python的<code>range(a, b)</code></p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)          <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>a...b</code>: 从a到b并包含a和b<br>  <code>a..&lt;b</code>: 包含a不包含b</p><blockquote><p><code>a..b</code>表示半闭区间的用法已经被放弃</p></blockquote><p>  范围运算符也可以作用于字符串</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> az <span class="operator">=</span> <span class="string">&quot;a&quot;</span><span class="operator">...</span><span class="string">&quot;z&quot;</span>      <span class="comment">// 返回的是CloseInteval或HalfOpenInterval</span></span><br><span class="line">az.contains(<span class="string">&quot;e&quot;</span>)        <span class="comment">// True</span></span><br></pre></td></tr></table></figure></li><li><p>空合运算符<code>??</code>（与C#类似）<br>  对于可选类型取值，如果不为空则返回该值，如果为空则去第二个操作数</p>  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result <span class="operator">=</span> a <span class="operator">??</span> b</span><br></pre></td></tr></table></figure></li></ul><h2 id="七、流程控制"><a href="#七、流程控制" class="headerlink" title="七、流程控制"></a>七、流程控制</h2><p>swift使用三种语句控制流程：<code>for-in</code>、<code>for</code>、<code>switch-case</code>、<code>while</code>和<code>repeat-while</code>，且判断条件的括号可以省略</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names <span class="operator">=</span> [<span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;Alex&quot;</span>, <span class="string">&quot;Brian&quot;</span>, <span class="string">&quot;Jack&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, <span class="subst">\(name)</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不需要使用到迭代的值，使用下划线`_`忽略该值</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>流程控制语句的条件返回值必须是Bool，下面会报错</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dd: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> dd &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断可以与<code>let</code>结合使用，当值为nil时，视为false（即：<code>可选绑定</code>）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dd: <span class="type">Bool</span>? <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> ee <span class="operator">=</span> dd &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Swift2.0以后，不支持<code>do-while</code>语句，使用<code>repeat-while</code>代替，用法与<code>do-while</code>一样</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> &#123;  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;repeat while : <span class="subst">\(j)</span>&quot;</span>)  </span><br><span class="line">    j<span class="operator">++</span>  </span><br><span class="line">&#125; <span class="keyword">while</span> j <span class="operator">&lt;</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="guard-else"><a href="#guard-else" class="headerlink" title="guard-else"></a>guard-else</h3><p>翻译为保镖模式，在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的<code>if-else</code>模式</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="params">i</span>: <span class="type">Int</span>?)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> i <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 符合条件的处理</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不符合条件的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="params">i</span>: <span class="type">Int</span>?)</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> i <span class="operator">=</span> i <span class="keyword">where</span> i <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里拦截，处理不符合条件的情况</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性</p><blockquote><p>保镖模式<code>guard-else</code>内的代码块必须包含<code>break</code>, <code>return</code>等跳出代码块的关键字</p></blockquote><h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><ul><li>switch语句支持更多数据类型（String，Int, Float, 元组, 枚举），理论上switch支持任意类型的对象（需要实现<code>~=</code>方法或<code>Equatable</code>协议，详情参见<a href="http://www.jianshu.com/p/ff660a3e3d8a">这里</a>）</li><li>case可以带多个值，用逗号隔开</li><li>case可以支持区间（<code>a...b</code>），支持元组，区间可以嵌套在元组内使用</li><li>case多条语句不需要用大括号包起来</li><li>case语句不需要break，除了空语句，如果需要执行下面的case，可以使用<code>fallthrough</code></li><li>如果case不能命中所有的情况，必须要<code>default</code>，如Int，String类型，否则编译会失败</li><li>可以用<code>fallthrough</code>关键字声明接着执行下一条case语句，注意，如果case语句有赋值语句（<code>let</code>），则<code>fallthrough</code>无效</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HttpStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ServerError</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NetworkError</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Redirect</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> status <span class="operator">=</span> <span class="type">HttpStatus</span>.<span class="type">Redirect</span></span><br><span class="line"><span class="keyword">switch</span> status &#123;</span><br><span class="line"><span class="comment">// case可以接收多个值</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">HttpStatus</span>.<span class="type">ServerError</span>, <span class="type">HttpStatus</span>.<span class="type">NetworkError</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line">    <span class="comment">// case语句结束显式写break，除非是空语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> .<span class="type">Redirect</span>:             <span class="comment">// 如果编译器可以识别出枚举类型，可以省略枚举名</span></span><br><span class="line">    print (<span class="string">&quot;redirect&quot;</span>)</span><br><span class="line">    <span class="keyword">fallthrough</span>             <span class="comment">// 像C语言一样，继续执行下一条case</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">HttpStatus</span>.<span class="type">Success</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元组，区间</span></span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> (<span class="number">0</span>, <span class="string">&quot;https://baidu.com&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> request &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> a):                  <span class="comment">// 支持绑定</span></span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (a, b) <span class="keyword">where</span> a <span class="operator">==</span> <span class="number">1</span>:      <span class="comment">// 绑定可以卸载元组外面，支持where判断</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cancel <span class="subst">\(b)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (<span class="number">2</span><span class="operator">...</span><span class="number">10</span>, <span class="keyword">_</span>):                 <span class="comment">// 支持区间，支持忽略值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// case可以与where进行进一步判断</span></span><br><span class="line"><span class="keyword">let</span> request2 <span class="operator">=</span> (<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">switch</span> request2 &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y) <span class="keyword">where</span> y <span class="operator">&lt;</span> <span class="number">5</span>:</span><br><span class="line"><span class="string">&quot;success&quot;</span>   <span class="comment">//被输出</span></span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>, <span class="keyword">let</span> y) <span class="keyword">where</span> y <span class="operator">&gt;=</span> <span class="number">5</span>:</span><br><span class="line"><span class="string">&quot;error&quot;</span>   <span class="comment">//被输出</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="string">&quot;unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case除了和swift一起使用外，还支持与if语句结合使用，用法与switch一样</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bb <span class="operator">=</span> (<span class="number">12</span>, <span class="string">&quot;bomo&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> (<span class="number">1</span><span class="operator">...</span><span class="number">20</span>, <span class="keyword">let</span> cc) <span class="operator">=</span> bb <span class="keyword">where</span> cc <span class="operator">==</span> <span class="string">&quot;bomo&quot;</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(cc)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h3><p>如果有多层嵌套的情况下，有时候我们需要在某处直接退出多层循环，在objc下并没有比较好的方式实现，需要添加退出标识，然后一层一层退出，而在swift可以很方便的退出多层循环，首先需要使用标签标识不通的循环体，形式如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">labelName : <span class="keyword">while</span> condition &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>看下面例子</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">outerLoop1 : <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">    outerLoop2 : <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">        outerLoop3 : <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span><span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> j <span class="operator">&gt;</span> <span class="number">5</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 跳出一层循环（默认）继续outerLoop2的循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 跳出两层循环，继续outerLoop1的循环</span></span><br><span class="line">                <span class="comment">// break outerLoop2</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 跳出三层循环，退出整个循环，继续后面的语句</span></span><br><span class="line">                <span class="comment">// break outerLoop1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、函数"><a href="#八、函数" class="headerlink" title="八、函数"></a>八、函数</h2><h3 id="1-基本形式"><a href="#1-基本形式" class="headerlink" title="1. 基本形式"></a>1. 基本形式</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">函数名</span>(<span class="params">参数名1</span>:参数类型<span class="number">1</span>, <span class="params">参数名2</span>:参数类型<span class="number">2</span>)</span> -&gt; 返回值类型 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个返回值（元组）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPoint</span>()</span> -&gt; (x: <span class="type">Int</span>, y: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p <span class="operator">=</span> getPoint()</span><br><span class="line">p.x</span><br><span class="line"></span><br><span class="line"><span class="comment">//无参数无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//egg</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">add(<span class="number">12</span>, b: <span class="number">232</span>)</span><br></pre></td></tr></table></figure><p>函数调用除了第一个参数，后面所有的参数必须带上参数名（符合Objc的函数命名规则）如果是调用构造器，第一个参数也需要显示声明</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span>(<span class="params">msg</span>: <span class="type">String</span>, <span class="params">count</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span><span class="operator">...</span>count &#123;</span><br><span class="line">            print (msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="type">A</span>(name: <span class="string">&quot;bomo&quot;</span>)               <span class="comment">// 构造器所有参数都必须显示声明参数名</span></span><br><span class="line">a.sayHello(<span class="string">&quot;hello&quot;</span>, count: <span class="number">2</span>)         <span class="comment">// 函数参数除了第一个其他都需要显示声明参数名</span></span><br></pre></td></tr></table></figure><h3 id="2-可变参数"><a href="#2-可变参数" class="headerlink" title="2. 可变参数"></a>2. 可变参数</h3><p>可变参数只能作为最后一个参数，一个方法最多只有一个可变参数</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span>(<span class="params">numbers</span>: <span class="type">Int</span>...)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">        sum <span class="operator">+=</span> number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-外部参数名"><a href="#3-外部参数名" class="headerlink" title="3. 外部参数名"></a>3. 外部参数名</h3><p>默认情况下，如果不指定外部参数名，swift编译器会自动为函数参数声明与内部参数名同名的外部参数名（格式为：<code>外部参数名 内部参数名: 类型名</code>）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认情况下，外部参数名与内部参数名一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">first</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">second</span> <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">add(first: <span class="number">10</span>, second: <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>如果函数在第一个参数定义外部参数名，必须显示指定，当然我们还可以通过下划线<code>_</code>让函数忽略参数名</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="keyword">_</span> <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="4-函数默认值"><a href="#4-函数默认值" class="headerlink" title="4. 函数默认值"></a>4. 函数默认值</h3><p>函数还支持声明默认值，（格式为：<code>外部参数名 内部参数名: 类型名 = 默认值</code>）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>(<span class="params">msg</span>: <span class="type">String</span>, <span class="params">isDebug</span>: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">true</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isDebug &#123;</span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">log(<span class="string">&quot;success&quot;</span>, isDebug: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>如果使用默认值并且默认值不是出现在最后，那调用的时候必须写全所有参数</p><blockquote><p>建议把默认参数放到最后面，这样可以确保非默认参数的赋值顺序，减少参数混乱的情况</p></blockquote><h3 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h3><ul><li>函数作为变量</li><li>函数作为函数参数</li><li>函数作为函数返回值</li><li>闭包函数声明<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为变量，函数hello赋给somefunc，并调用</span></span><br><span class="line"><span class="keyword">let</span> somefunc: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="operator">=</span> add</span><br><span class="line">somefunc(<span class="number">10</span>, <span class="number">20</span>)      <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logAdd</span>(<span class="params">a</span>:<span class="type">Int</span>, <span class="params">b</span>:<span class="type">Int</span>, <span class="params">function</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">    function(a, b)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">logAdd(<span class="number">12</span>, b: <span class="number">23</span>, function: add)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作为返回值（包装一个函数，在执行前后输出信息），函数作为参数又作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addWrapper</span>(<span class="params">addFunc</span>: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>)</span> -&gt; ((<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数内容</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapper</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin&quot;</span>)</span><br><span class="line">        <span class="keyword">let</span> res <span class="operator">=</span> addFunc(a, b)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newAdd <span class="operator">=</span> addWrapper(add)</span><br><span class="line">newAdd(<span class="number">12</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></li></ul><p>闭包函数声明形式</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&#123; (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">    statements      <span class="comment">// 可以有多行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包函数</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个函数变量</span></span><br><span class="line"><span class="keyword">var</span> addfunc: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包的写法</span></span><br><span class="line"><span class="comment">// 1. 完整写法</span></span><br><span class="line">addfunc <span class="operator">=</span> &#123;(a: <span class="type">Int</span>, b: <span class="type">Int</span>) -&gt; (<span class="type">Int</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//var c = a + 1       //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略</span></span><br><span class="line">addfunc <span class="operator">=</span> &#123;(a, b) <span class="keyword">in</span> <span class="keyword">return</span> a <span class="operator">+</span> b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略</span></span><br><span class="line">addfunc <span class="operator">=</span> &#123;a, b <span class="keyword">in</span> a <span class="operator">+</span> b&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 参数和in可以省去，通过$和索引取得参数</span></span><br><span class="line">addfunc <span class="operator">=</span> &#123;<span class="variable">$0</span> <span class="operator">+</span> <span class="variable">$1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号</span></span><br><span class="line">addfunc <span class="operator">=</span> (<span class="operator">+</span>)</span><br></pre></td></tr></table></figure><h3 id="6-Trailing-尾行-闭包"><a href="#6-Trailing-尾行-闭包" class="headerlink" title="6. Trailing(尾行)闭包"></a>6. Trailing(尾行)闭包</h3><p>如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionThatTakesAClosure</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">closure</span>: () -&gt; ())</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 一般形式</span></span><br><span class="line">someFunctionThatTakesAClosure(<span class="number">10</span>, closure: &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Trainling闭包的方式</span></span><br><span class="line">someFunctionThatTakesAClosure(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 如果没有其他参数时，可以省略括号</span></span><br><span class="line">someFunctionThatTakesAClosure &#123;</span><br><span class="line">    <span class="comment">// 闭包主体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Escaping（逃逸）闭包"><a href="#7-Escaping（逃逸）闭包" class="headerlink" title="7. Escaping（逃逸）闭包"></a>7. Escaping（逃逸）闭包</h3><p>如果一个闭包/函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加<code>@escaping</code>声明，来声明该闭包/函数允许从函数中”逃逸”，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span>(<span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>逃逸闭包只是一个声明，以增强函数的意图</p></blockquote><h3 id="8-自动闭包"><a href="#8-自动闭包" class="headerlink" title="8. 自动闭包"></a>8. 自动闭包</h3><p>对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）</span></span><br><span class="line"><span class="keyword">let</span> sayHello <span class="operator">=</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用闭包函数</span></span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure><blockquote><p>自动闭包只是闭包的一种简写方式</p></blockquote><p>如果一个函数接受一个不带参数的闭包</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span>(<span class="params">predicate</span>: () -&gt; <span class="type">Bool</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候可以使用自动闭包</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">logIfTrue(predicate: &#123; <span class="keyword">return</span> <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简化return</span></span><br><span class="line">logIfTrue(predicate: &#123; <span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><p>上面代码看起来可读性不是很好，swift引入了一个关键字<code>@autoclosure</code>，简化自动闭包的大括号，在闭包类型前面添加该关键字声明</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logIfTrue</span>(<span class="params">predicate</span>: <span class="keyword">@autoclosure</span> () -&gt; <span class="type">Bool</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> predicate() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">logIfTrue(predicate:<span class="number">1</span> <span class="operator">&lt;</span> <span class="number">2</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>@autoclosure</code> 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：<a href="http://swifter.tips/autoclosure/">@AUTOCLOSURE 和 ??</a></p></blockquote><h3 id="9-常量参数和变量参数"><a href="#9-常量参数和变量参数" class="headerlink" title="9. 常量参数和变量参数"></a>9. 常量参数和变量参数</h3><p>默认情况下所有函数参数都是常量，意味着参数是不可变的，我们可以显式的声明参数为变量</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>(<span class="params">msg</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">    msg <span class="operator">=</span> <span class="string">&quot;begin &quot;</span> <span class="operator">+</span> msg <span class="operator">+</span> <span class="string">&quot; end&quot;</span>       <span class="comment">// 会报错，因为msg为常量</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>(<span class="params">var</span> <span class="params">msg</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">    msg <span class="operator">=</span> <span class="string">&quot;begin &quot;</span> <span class="operator">+</span> msg <span class="operator">+</span> <span class="string">&quot; end&quot;</span>       <span class="comment">// 变量参数正常运行</span></span><br><span class="line">    <span class="built_in">print</span>(msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：变量参数在swift3被抛弃</p></blockquote><h3 id="10-输入输出参数"><a href="#10-输入输出参数" class="headerlink" title="10. 输入输出参数"></a>10. 输入输出参数</h3><p>在c语言里有指针，可以通过传址直接修改外部变量的值，在swift通过<code>inout</code>关键字声明函数内部可直接修改外部变量，外部通过<code>&amp;</code>操作符取得变量地址</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span>(<span class="params">inout</span> <span class="params">a</span>: <span class="type">Int</span>, <span class="params">inout</span> <span class="params">b</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a <span class="operator">=</span> <span class="number">19</span>, b <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="operator">&amp;</span>a, <span class="operator">&amp;</span>b)</span><br></pre></td></tr></table></figure><h3 id="11-嵌套函数"><a href="#11-嵌套函数" class="headerlink" title="11. 嵌套函数"></a>11. 嵌套函数</h3><p>swift的函数还支持嵌套，默认情况下，嵌套函数对外部不可见，只能在函数内部使用</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chooseStepFunction</span>(<span class="params">backward</span>: <span class="type">Bool</span>)</span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个内部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepForward</span>(<span class="params">input</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">+</span> <span class="number">1</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stepBackward</span>(<span class="params">input</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123; <span class="keyword">return</span> input <span class="operator">-</span> <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> backward <span class="operator">?</span> stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套函数相当于objc函数内的block</p><h3 id="12-defer"><a href="#12-defer" class="headerlink" title="12. defer"></a>12. defer</h3><p>在swift2.0之后添加了<code>defer</code>关键字，可以定义代码块在函数执行完成之前的完成一些操作，<strong>并且在函数抛出错误的时候也可以执行</strong></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;             <span class="comment">// 入栈</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;begin2&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;             <span class="comment">// 入栈</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;end2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin4&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;end4&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin5&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;end5&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do balabala&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出结果为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin1</span><br><span class="line">begin2</span><br><span class="line">begin4</span><br><span class="line">begin5</span><br><span class="line">end5</span><br><span class="line">end4</span><br><span class="line">do balabala</span><br><span class="line">end2</span><br><span class="line">end1</span><br></pre></td></tr></table></figure><p>通常可以用在需要成对操作的逻辑中（如：<code>open/close</code>）</p><h2 id="九、枚举"><a href="#九、枚举" class="headerlink" title="九、枚举"></a>九、枚举</h2><p>swift的枚举比C语言的枚举更为强大，支持更多特性，swift的枚举更像类和结构体，支持类和结构体的一些特性，与<code>ObjC</code>不同，如果不声明枚举的值，编译器不会给枚举设置默认值</p><blockquote><p>枚举与结构体一样，是值类型</p></blockquote><h3 id="1-声明和使用"><a href="#1-声明和使用" class="headerlink" title="1. 声明和使用"></a>1. 声明和使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 可以把枚举值定义在一行，用逗号隔开</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 像对象一样使用枚举，代码结构更为清晰，枚举更为简短</span></span><br><span class="line"><span class="keyword">let</span> direction <span class="operator">=</span> <span class="type">CompassPoint</span>.<span class="type">East</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果编译器可以识别出枚举的类型，可以省略枚举名</span></span><br><span class="line"><span class="keyword">let</span> direction2: <span class="type">CompassPoint</span></span><br><span class="line">direction2 <span class="operator">=</span> .<span class="type">East</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果编译器能确定case命中所有的情况，可以不需要default</span></span><br><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;west&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;south&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;north&quot;</span>)</span><br><span class="line">    <span class="comment">//所有值都被枚举，则不需要default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-嵌套枚举"><a href="#2-嵌套枚举" class="headerlink" title="2. 嵌套枚举"></a>2. 嵌套枚举</h3><p>swift的枚举定义支持嵌套，在使用的时候一层一层引用</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Weapon</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Bow</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sword</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lance</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dagger</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Helmet</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Wooden</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Iron</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Diamond</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Thief</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Warrior</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Knight</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> character <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Thief</span></span><br><span class="line"><span class="keyword">let</span> weapon <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Weapon</span>.<span class="type">Bow</span></span><br><span class="line"><span class="keyword">let</span> helmet <span class="operator">=</span> <span class="type">Character</span>.<span class="type">Helmet</span>.<span class="type">Iron</span></span><br></pre></td></tr></table></figure><h3 id="3-递归枚举"><a href="#3-递归枚举" class="headerlink" title="3. 递归枚举"></a>3. 递归枚举</h3><p>枚举的关联值的类型可以设为枚举自身，这样的枚举称为递归枚举</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带递归类型的枚举需要在case前面添加关键字声明<code>indirect</code>，也可以在enum前面加上声明，表示所有的成员是可以递归的</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> number(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> addition(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> multiplication(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用递归枚举取值的时候可以使用递归函数</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span>(<span class="keyword">_</span> <span class="params">expression</span>: <span class="type">ArithmeticExpression</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">   <span class="keyword">switch</span> expression &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .number(value):</span><br><span class="line">       <span class="keyword">return</span> value</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .addition(left, right):</span><br><span class="line">       <span class="keyword">return</span> evaluate(left) <span class="operator">+</span> evaluate(right)</span><br><span class="line">   <span class="keyword">case</span> <span class="keyword">let</span> .multiplication(left, right):</span><br><span class="line">       <span class="keyword">return</span> evaluate(left) <span class="operator">*</span> evaluate(right)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> five <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.number(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.addition(five, four)</span><br><span class="line"></span><br><span class="line"><span class="comment">// (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> product <span class="operator">=</span> <span class="type">ArithmeticExpression</span>.multiplication(sum, <span class="type">ArithmeticExpression</span>.number(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))</span><br></pre></td></tr></table></figure><blockquote><p>其实感觉这种嵌套多层的用法可读性并不是特别好，而且在取值的时候还需要递归，通常来说，嵌套一层就够了</p></blockquote><h3 id="4-原始值"><a href="#4-原始值" class="headerlink" title="4. 原始值"></a>4. 原始值</h3><p>与C语言一样，可以为每个枚举指定值，并且可以支持更多类型（<code>Int</code>, <code>Float</code>, <code>Character</code>, <code>String</code>）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义枚举，并初始化原始值</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\t</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\n</span>&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> <span class="operator">=</span> <span class="string">&quot;<span class="subst">\r</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过两个属性获得原始值</span></span><br><span class="line"><span class="keyword">var</span> ch <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>.<span class="type">Tab</span></span><br><span class="line">ch.hashValue    <span class="comment">// 获取是否有原始值</span></span><br><span class="line">ch.rawValue     <span class="comment">// 获得原始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过原始值构造枚举，如果不存在，则返回nil</span></span><br><span class="line"><span class="keyword">var</span> tab <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>.<span class="keyword">init</span>(rawValue: <span class="string">&quot;<span class="subst">\t</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果是原始值是整形值，后面的值默认自增1，如果不指定，则默认为空，而不是从0开始</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> <span class="operator">=</span> <span class="number">1</span>, <span class="type">Venus</span>         <span class="comment">// Venus = 2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Neptune</span>                    <span class="comment">// Neptune = 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果没有指定枚举原始值的类型，则默认为空，而不是整型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//swift 不会为North, South, East, West设置为0,1,2,3，并且CompassPoint没有原始值（rawValue）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 有原始值的枚举可以通过原始值构造（构造器返回可选类型）</span></span><br><span class="line"><span class="keyword">let</span> lineFeed <span class="operator">=</span> <span class="type">ASCIIControlCharacter</span>(rawValue: <span class="string">&quot;<span class="subst">\n</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="5-关联值"><a href="#5-关联值" class="headerlink" title="5. 关联值"></a>5. 关联值</h3><p>上面我们说到，枚举与类和结构体类似，swift的枚举可以给不同的枚举值绑定关联值，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)        <span class="comment">//条形码，关联一个元组</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)             <span class="comment">//二维码，关联一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> productBarcode <span class="operator">=</span> <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">85909_51226</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// var productBarcode = .QRCode(&quot;http://www.baidu.com&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> a, <span class="keyword">let</span> b, <span class="keyword">let</span> c):        <span class="comment">//在枚举的时候可以取得关联值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;barcode: <span class="subst">\(a)</span><span class="subst">\(b)</span><span class="subst">\(c)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(value):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;qrcode: <span class="subst">\(value)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面这种轻量的数据，在OC上一般我们可能需要定义两个类实现，而swift的枚举可以轻松的处理这种轻量数据，而减少项目中类的定义和维护</p><h2 id="十、类与结构体"><a href="#十、类与结构体" class="headerlink" title="十、类与结构体"></a>十、类与结构体</h2><p>先来看看结构体和类的一些差异</p><ul><li>类是引用类型，结构体为值类型</li><li>类使用引用计数管理内存，结构体分配在栈上，有系统管理内存，变量传递的时候，结构体整个拷贝，而类默认只传递引用地址（有些类会进行一些额外的拷贝，详见<a href="">深拷贝和浅拷贝</a>）</li><li>结构体不支持继承，类支持继承</li><li>与ObjC不同，swift的结构体可以定义方法</li><li>类支持运行时类型检查，而结构体不支持</li><li>类有构造器和析构器，结构体只有构造器</li><li>常量结构体的成员的值不能改变</li></ul><blockquote><p>实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。</p></blockquote><h3 id="1-结构体，类定义"><a href="#1-结构体，类定义" class="headerlink" title="1. 结构体，类定义"></a>1. 结构体，类定义</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printPoint</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;x=<span class="subst">\(x)</span>, y=<span class="subst">\(y)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> someObj <span class="operator">=</span> <span class="type">NSObject</span>()          <span class="comment">// 定义属性，并初始化</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>                  <span class="comment">// 定义属性，并指定类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>)</span> &#123;              <span class="comment">// 构造函数</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello <span class="subst">\(<span class="keyword">self</span>.name)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dealloc&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swift中，许多基本类型如<code>String</code>, <code>Array</code>和<code>Dictionary</code>都是用结构体实现的，意味着在传递的时候都会进行值拷贝，当然swift也对这些类型进行了优化，只有在需要的时候进行拷贝</p><h3 id="2-静态属性，静态方法"><a href="#2-静态属性，静态方法" class="headerlink" title="2. 静态属性，静态方法"></a>2. 静态属性，静态方法</h3><p>swift中有两个<code>static</code>和<code>class</code>声明静态变量或方法，其中<code>class</code>只能用在类的方法和计算属性上，其他的都使用<code>static</code>，由于类支持继承，所以使用<code>class</code>声明的静态方法可以被继承，而static声明的静态方法不能被继承</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> instanceCount: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>       <span class="comment">// 声明一个类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span> ()</span> &#123;</span><br><span class="line">        <span class="type">Person</span>.instanceCount <span class="operator">+=</span> <span class="number">1</span>           <span class="comment">// 通过类名引用类属性，子类可以访问基类的类属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用class声明的静态方法可以被继承</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">overrideableComputedTypeProperty</span>() </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(Person.instanceCount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用static声明的静态方法不能被继承</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">printInstanceCount</span>()</span> &#123;      <span class="comment">// 声明一个静态方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(Person.instanceCount)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类和结构体的声明和用法与类类似，使用<code>static</code></p><blockquote><p>注意：<code>class</code>只能用来声明计算属性和方法，不能用来声明普通属性</p></blockquote><h3 id="3-构造器和析构器"><a href="#3-构造器和析构器" class="headerlink" title="3. 构造器和析构器"></a>3. 构造器和析构器</h3><p>swift的构造器规则和限制比较多，关于构造器可以参见：<a href="/2016-07-07/swift-constructor/">这里</a></p><p>析构器相当于objc里面的<code>dealloc</code>方法，做一些需要手动释放资源的操作，析构器与构造器不同，没有参数，定义的时候不需要括号，类在释放的之前会自动调用父类的析构器，不需要主动调用</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;释放额外的资源，如通知&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-类型判断"><a href="#4-类型判断" class="headerlink" title="4. 类型判断"></a>4. 类型判断</h3><p>在objc中，我们通常使用<code>isKindOfClass</code>, <code>isMemberOfClass</code>, <code>isSubclassOfClass</code>等方法进行类型判断，swift使用<code>is</code>和<code>as</code>判断类型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="operator">=</span> <span class="type">Son</span>()</span><br><span class="line"><span class="comment">// isKindOfClass</span></span><br><span class="line">son <span class="keyword">is</span> <span class="type">Son</span>                <span class="comment">// true</span></span><br><span class="line">son <span class="keyword">is</span> <span class="type">Parent</span>             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isMemberOfClass</span></span><br><span class="line">son.dynamicType <span class="operator">==</span> <span class="type">Son</span>.<span class="keyword">self</span>         <span class="comment">// true</span></span><br><span class="line">son.dynamicType <span class="operator">==</span> <span class="type">Parent</span>.<span class="keyword">self</span>      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isSubclassOfClass 暂时没找到相关的API</span></span><br></pre></td></tr></table></figure><p>//TODO: swift动态性，反射</p><h3 id="5-弱引用"><a href="#5-弱引用" class="headerlink" title="5. 弱引用"></a>5. 弱引用</h3><p>与<code>ObjC</code>一样，swift的内存管理也使用引用计数管理，也使用weak声明弱引用变量</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> person: <span class="type">Person</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-访问级别"><a href="#6-访问级别" class="headerlink" title="6. 访问级别"></a>6. 访问级别</h3><p>在swift中，framework和bundle都被处理成模块</p><pre><code>* public：公开，可以被外部访问* internal：内部，在模块（framework）内部使用，模块外访问不到* private：只能在当前源文件中使用</code></pre><p>swift默认的访问级别为Internal，使用的时候只需要在类/变量/函数前面加上访问级别即可</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">public</span> <span class="title">var</span> <span class="title">peopleCount</span>: <span class="title">Int</span> = 0    // 类变量，通过<span class="title">class</span>声明，类变量使用时使用类名引用</span></span><br><span class="line"><span class="class">    <span class="title">internal</span> <span class="title">var</span> <span class="title">age</span>: <span class="title">Int</span>                    // 实例变量</span></span><br><span class="line"><span class="class">    <span class="title">var</span> <span class="title">name</span>: <span class="title">String</span>                         // 不声明，则为<span class="title">internal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">init</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="type">Person</span>.peopleCount<span class="operator">++</span>              <span class="comment">// 使用静态变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层访问级别的必须是比成员更高，下面会报警告</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;                      <span class="comment">// 默认为internal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span>         <span class="comment">// 为public，比类访问级别高，会有警告</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> gender: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span>()</span> &#123;</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的访问级别要比参数(或泛型类型)的访问级别低，否则会报警告</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivatePerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> gender: <span class="type">Int</span> <span class="operator">=</span> <span class="number">10</span>          <span class="comment">// 报警告</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHello</span>()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">test</span>(<span class="params">person</span>:<span class="type">PrivatePerson</span>)</span> &#123;    <span class="comment">//报编译错误：这里参数访问级别为private，所以函数访问级别不能高于private，则只能为private</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>枚举类型</code>的成员访问级别跟随枚举类型，嵌套类型默认最高访问级别为internal（外层为public，内层默认为internal）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>            <span class="comment">// 四个枚举成员访问级别都为public</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类访问级别不能高于父类（包括泛型类型），协议继承也同理，子协议访问级别不能高于父协议</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Parent</span> </span>&#123;       <span class="comment">// 报编译错误：Son访问级别必须低于Parent，应该为internal或private</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>元组</code>的访问级别为元组内所有类型访问级别中最低级的</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> sometuple <span class="operator">=</span> (<span class="type">Son</span>(), <span class="type">Parent</span>())  <span class="comment">// 报编译错误：sometuple的访问级别不能高于成员类型的访问级别，由于Son为private，故sometuple必须为private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的访问级别不能高于类型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">PrivateClass</span>        <span class="comment">// 报编译错误：变量value的访问级别不能高于其类型，故value必须声明为private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性的 Setter 访问级别不能高于 Getter访问级别</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private(set)</span> <span class="keyword">var</span> num <span class="operator">=</span> <span class="number">1_000_000</span>      <span class="comment">// 声明属性num，getter访问级别没有声明，默认为Internal，setter访问级别为private</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">internal(set)</span> <span class="keyword">var</span> name <span class="operator">=</span> <span class="string">&quot;bomo&quot;</span>   <span class="comment">// 报编译错误：属性name的setter访问级别为internal，高于getter访问级别private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议与类的访问级别关系</p><ul><li>协议中所有必须实现的成员的访问级别和协议本身的访问级别相同</li><li>其子协议的访问级别不高于父协议（与类相同）</li><li>如果类实现了协议，那类的访问级别必须低于或等于协议的访问级别</li></ul><p>类型别名访问级别与类型的关系</p><ul><li>类型别名的访问级别不能高于原类型的访问级别；</li></ul><p>函数构造函数默认访问级别为internal，如果需要给其他模块使用，需显式声明为public</p><blockquote><p>注意：swift的访问级别是作用于文件（private）和模块的（internal）的，而不只是类，所以只要在同一个文件内，private访问级别在不同类也可以直接访问，例如我们可以通过子类包装父类的方法以改变访问级别</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span>()</span> &#123;   <span class="comment">// 在同一个文件，改变someMethod的访问级别</span></span><br><span class="line">        <span class="keyword">super</span>.someMethod()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-属性"><a href="#7-属性" class="headerlink" title="7. 属性"></a>7. 属性</h3><ul><li>使用关键字<code>lazy</code>声明一个懒加载 <strong>变量</strong> 属性，当属性被使用的时候（get），才会进行初始化</li><li>set方法的访问级别必须必get方法低</li><li>声明属性的时候可以使用<code>private(set)</code>和<code>internal(set)</code>改变set方法默认的访问级别</li><li>每个实例都有一个self属性，指向实例自身，通常在属性与函数参数有冲突的时候使用</li><li>对于常量属性，不许在定义它的类的构造器中赋值，不能再子类赋值</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataImporter</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 只有第一次调用importer的get方法的时候才会初始化</span></span><br><span class="line">    <span class="keyword">lazy</span> <span class="keyword">var</span> importer <span class="operator">=</span> <span class="type">DataImporter</span>()</span><br><span class="line">    <span class="keyword">var</span> data <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> height: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明get方法和set方法的访问级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">private(set)</span> <span class="keyword">var</span> weight: <span class="type">Double</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 自定义get/set方法</span></span><br><span class="line">    <span class="keyword">var</span> square: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height)<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//set &#123;                 //如果不指定名称，默认通过newValue使用新值</span></span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            <span class="keyword">self</span>.width <span class="operator">=</span> newValue<span class="operator">/</span><span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">self</span>.height <span class="operator">=</span> newValue<span class="operator">/</span><span class="number">2.0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 只读属性，可以省略get，直接使用一个花括号</span></span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height) <span class="operator">*</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 属性监视器，在初始化的时候不会触发</span></span><br><span class="line">    <span class="keyword">var</span> someInt: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">willSet</span> &#123;       <span class="comment">//用法与set一样如果不指定名称，默认通过newValue使用旧值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;set方法之前触发&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;        <span class="comment">//用法与set一样如果不指定名称，默认通过oldValue使用旧值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;set方法完成后触发，可以在这里设置obj的值覆盖set方法设置的值&quot;</span>)</span><br><span class="line">            <span class="keyword">self</span>.someInt <span class="operator">=</span> <span class="number">0</span>      <span class="comment">// someInt的值永远为0，在监视器修改属性的值不会导致观察器被再次调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用lazy声明的属性不是线程安全的，在多线程情况下可能产生多份，需要自己控制</p></blockquote><p>对于结构体，与OC不同，swift的结构体允许直接对属性的子属性直接修改，而不需要取出重新赋值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">someVideoMode.resolution.width <span class="operator">=</span> <span class="number">1280</span></span><br></pre></td></tr></table></figure><p>在oc上需要这样做</p><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">var resolution = someVideoMode.resolution</span><br><span class="line">resolution.width = <span class="number">1024</span></span><br><span class="line">someVideoMode.resolution = resolution</span><br></pre></td></tr></table></figure><h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><p>我们都知道，在oc里所有的类都继承自NSObject/NSProxy，而在swift中的类并不是从一个通用的基类继承的，所有没有继承其他父类的类都称为<code>基类</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">gender</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gender <span class="operator">=</span> gender</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>: <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 重写可以改变父类方法的访问级别</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span> &#123;                  <span class="comment">// 重写父类方法必须加上override，否则会报编译错误</span></span><br><span class="line">        <span class="comment">//super.hello()                               // 可以通过super访问父类成员，包括附属脚本</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;son hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>重写属性的时候，如果属性提供了setter方法，则必须为提供getter方法<br>如果重写了属性的setter方法，则不能重写willSet和didSet方法<br>如果重写了willSet和didSet方法，则不能重写get和set方法</p></blockquote><p>父类的属性，方法，类方法，附属脚本，包括类本身都可以被子类继承和重写，可以通过<code>final</code>约束限制子类的重写（<code>final class</code>, <code>final var</code>, <code>final func</code>, <code>final class func</code>, 以及 <code>final subscript</code>）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">var</span> gender <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>        <span class="comment">// 不允许被子类重写</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>                    <span class="comment">// 可以被子类重写</span></span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">gender</span>: <span class="type">String</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.gender <span class="operator">=</span> gender</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span> &#123;                <span class="comment">// 不允许被重写</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;parent hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swift编译器在识别数组类型的时候，如果数组元素有相同的基类，会被自动识别出来</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t1 <span class="operator">=</span> <span class="type">Teacher</span>()</span><br><span class="line"><span class="keyword">let</span> t2 <span class="operator">=</span> <span class="type">Teacher</span>()</span><br><span class="line"><span class="keyword">let</span> s1 <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line"><span class="keyword">let</span> s2 <span class="operator">=</span> <span class="type">Student</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people <span class="operator">=</span> [t1, t2, s1, s2]      <span class="comment">// people会被识别为[Person]类型</span></span><br></pre></td></tr></table></figure><p>向下类型转换<code>as!</code>, <code>as?</code>，<code>as!</code>返回非可选类型，如果类型不匹配会报错，<code>as?</code>返回可选类型，如果类型不匹配返回nil</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> people &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> teacher <span class="operator">=</span> person <span class="keyword">as?</span> <span class="type">Teacher</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> student <span class="operator">=</span> person <span class="keyword">as?</span> <span class="type">Student</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-附属脚本subscript"><a href="#9-附属脚本subscript" class="headerlink" title="9. 附属脚本subscript"></a>9. 附属脚本subscript</h3><p>附属脚本可以让类、结构体、枚举对象快捷访问集合或序列，而不需要调用使用对象内的实例变量引用，看下面实例</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DailyMeal</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">MealTime</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Breakfast</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lunch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dinner</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> meals: [<span class="type">MealTime</span> : <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要使用DailyMeal的meals对象的，需要这么用</span></span><br><span class="line"><span class="keyword">var</span> dailyMeal <span class="operator">=</span> <span class="type">DailyMeal</span>()</span><br><span class="line">dailyMeal.meals[<span class="type">MealTime</span>.<span class="type">Breakfast</span>] <span class="operator">=</span> <span class="string">&quot;Toast&quot;</span></span><br></pre></td></tr></table></figure><p>使用附属脚本可以直接通过类对象索引访问meals的值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DailyMeal</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">MealTime</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Breakfast</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Lunch</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Dinner</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> meals: [<span class="type">MealTime</span> : <span class="type">String</span>] <span class="operator">=</span> [:]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义附加脚本，类似属性</span></span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">realMealTime</span>: <span class="type">MealTime</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> value <span class="operator">=</span> meals[realMealTime] &#123;</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;unknown&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            meals[realMealTime] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dailyMeal <span class="operator">=</span> <span class="type">DailyMeal</span>()</span><br><span class="line">dailyMeal[.<span class="type">Breakfast</span>] <span class="operator">=</span> <span class="string">&quot;sala&quot;</span></span><br><span class="line"><span class="built_in">print</span>(dailyMeal[.<span class="type">Breakfast</span>])</span><br></pre></td></tr></table></figure><p>附加脚本还支持多个参数</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rows: <span class="type">Int</span>, columns: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> grid: [<span class="type">Double</span>]</span><br><span class="line">    <span class="function"><span class="keyword">init</span>(<span class="params">rows</span>: <span class="type">Int</span>, <span class="params">columns</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.rows <span class="operator">=</span> rows</span><br><span class="line">        <span class="keyword">self</span>.columns <span class="operator">=</span> columns</span><br><span class="line">        grid <span class="operator">=</span> <span class="type">Array</span>(count: rows <span class="operator">*</span> columns, repeatedValue: <span class="number">0.0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">indexIsValidForRow</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> row <span class="operator">&lt;</span> rows <span class="operator">&amp;&amp;</span> column <span class="operator">&gt;=</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> column <span class="operator">&lt;</span> columns</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">subscript</span>(<span class="params">row</span>: <span class="type">Int</span>, <span class="params">column</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="built_in">assert</span>(indexIsValidForRow(row, column: column), <span class="string">&quot;Index out of range&quot;</span>)</span><br><span class="line">            grid[(row <span class="operator">*</span> columns) <span class="operator">+</span> column] <span class="operator">=</span> newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matrix <span class="operator">=</span> <span class="type">Matrix</span>(rows: <span class="number">2</span>, columns: <span class="number">2</span>)</span><br><span class="line">matrix[<span class="number">0</span>, <span class="number">1</span>] <span class="operator">=</span> <span class="number">1.5</span></span><br><span class="line">matrix[<span class="number">1</span>, <span class="number">0</span>] <span class="operator">=</span> <span class="number">3.2</span></span><br></pre></td></tr></table></figure><p>附加脚本类似属性，拥有get/set方法，支持只读和读写两种方式，附加脚本也支持多个参数，附属脚本可以屏蔽外部对内部对象的直接访问，隐藏对象内部的细节，提高封装度，使得代码更加健壮和简洁</p><h3 id="10-类型嵌套"><a href="#10-类型嵌套" class="headerlink" title="10. 类型嵌套"></a>10. 类型嵌套</h3><p>与枚举一样，结构体和类都支持类型嵌套，可以在类里面再定义类/结构体/枚举</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类里面嵌套定义枚举</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Spades</span> <span class="operator">=</span> <span class="string">&quot;♠&quot;</span>, <span class="type">Hearts</span> <span class="operator">=</span> <span class="string">&quot;♡&quot;</span>, <span class="type">Diamonds</span> <span class="operator">=</span> <span class="string">&quot;♢&quot;</span>, <span class="type">Clubs</span> <span class="operator">=</span> <span class="string">&quot;♣&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 枚举里面嵌套定义结构体</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Values</span> </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> first: <span class="type">Int</span>, second: <span class="type">Int</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类里面嵌套定义结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x: <span class="type">Int</span></span><br><span class="line">        <span class="keyword">let</span> y: <span class="type">Int</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类里面嵌套定义类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> name: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">var</span> id: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候像属性一样引用</span></span><br><span class="line"><span class="keyword">let</span> values <span class="operator">=</span> <span class="type">SomeClass</span>.<span class="type">Suit</span>.<span class="type">Values</span>(first: <span class="number">1</span>, second: <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="11-类型别名"><a href="#11-类型别名" class="headerlink" title="11. 类型别名"></a>11. 类型别名</h3><p>swift类型别名与c语言中取别名有点像，通过关键字<code>typealias</code>声明别名</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MyInt</span> <span class="operator">=</span> <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>(<span class="params">a</span>: <span class="type">MyInt</span>, <span class="params">b</span>: <span class="type">MyInt</span>)</span> -&gt; <span class="type">MyInt</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="operator">+</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常在容易出现命名冲突的情况下会考虑使用类型别名</p></blockquote><h2 id="十一、扩展Extension"><a href="#十一、扩展Extension" class="headerlink" title="十一、扩展Extension"></a>十一、扩展Extension</h2><p>与oc一样，扩展就是对已有的类添加新的功能，与oc的category类似，swift的扩展可以：</p><ul><li>提供新的构造器（需要符合构造器的基本规则）</li><li>添加实例计算型属性和类计算性属性</li><li>添加实例方法和类方法</li><li>添加附加脚本</li><li>添加新的嵌套类型</li><li>使一个已有类型符合某个接口</li></ul><p>swift扩展不可以：</p><ul><li>不可以添加存储属性</li><li>不可以向已有属性添加属性观测器(willSet, didSet)</li></ul><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义扩展</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;fly&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p <span class="operator">=</span> <span class="type">Person</span>()</span><br><span class="line">p.fly()</span><br></pre></td></tr></table></figure><p>扩展也可以作用在结构体和枚举上</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> width: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> height: <span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> perimeter: <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> <span class="operator">*</span> (<span class="keyword">self</span>.width <span class="operator">+</span> <span class="keyword">self</span>.height)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> rect <span class="operator">=</span> <span class="type">Rectangle</span>(width: <span class="number">100</span>, height: <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.perimeter)</span><br></pre></td></tr></table></figure><p>扩展内的成员定义与类类似，这里不再说明</p><h3 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h3><p>由于swift不能扩展新的属性，有时候我们希望给类添加属性，在oc里可以用关联属性新增存储属性，在swift也可以，需要引入<code>ObjectiveC</code>模块</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ObjectiveC</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> xoTag: <span class="type">UInt</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>xoTag) <span class="keyword">as!</span> <span class="type">Int</span></span><br><span class="line">        &#125; <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>xoTag, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_ASSIGN</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、协议Protocal"><a href="#十二、协议Protocal" class="headerlink" title="十二、协议Protocal"></a>十二、协议Protocal</h2><p>swift的协议在oc的基础上加了更多的支持，可以支持属性，方法，附加脚本，操作符等，协议的属性必须为变量<code>var</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 属性要求</span></span><br><span class="line">    <span class="keyword">var</span> mustBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 只读属性</span></span><br><span class="line">    <span class="keyword">var</span> doesNotNeedToBeSettable: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 只读静态属性</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> staticProperty: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">hello</span>()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-mutating"><a href="#1-mutating" class="headerlink" title="1. mutating"></a>1. mutating</h3><p>在结构体/枚举中的值类型变量，默认情况下不能对其进行修改，编译不通过，如果需要修改值类型的属性，需要在方法声明前加上<code>mutating</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">moveToPoint</span>(<span class="params">point</span>: <span class="type">Point</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> point.x        <span class="comment">// 报错：不能对值类型的属性进行修改</span></span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> point.y        <span class="comment">// 报错：不能对值类型的属性进行修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToPoint2</span>(<span class="params">point</span>: <span class="type">Point</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.x <span class="operator">=</span> point.x        <span class="comment">// 编译通过</span></span><br><span class="line">        <span class="keyword">self</span>.y <span class="operator">=</span> point.y        <span class="comment">// 编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变方法还可以对self进行修改，这个方法和moveToPoint2效果相同</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToPoint3</span>(<span class="params">x</span> <span class="params">deltaX</span>: <span class="type">Int</span>, <span class="params">y</span> <span class="params">deltaY</span>: <span class="type">Int</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> <span class="operator">=</span> <span class="type">Point</span>(x:deltaX, y:deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变方法还可以修改枚举值自身的值</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TriStateSwitch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Off</span>, <span class="type">Low</span>, <span class="type">High</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Off</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Low</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">Low</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">High</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="type">High</span>:</span><br><span class="line">                <span class="keyword">self</span> <span class="operator">=</span> .<span class="type">Off</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别是在定义Protocal的时候，需要考虑到协议可能作用于枚举或结构体，在定义协议的时候需要在方法前加上<code>mutating</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToPoint</span>(<span class="params">point</span>: <span class="type">Point</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-协议类型"><a href="#2-协议类型" class="headerlink" title="2. 协议类型"></a>2. 协议类型</h3><p>协议虽然没有任何实现，但可以当做类型来用，与oc的protocal类似，用协议类型表示实现了该协议的对象，与oc的<code>id&lt;SomeProtocol&gt;</code>一样</p><h3 id="3-协议组合"><a href="#3-协议组合" class="headerlink" title="3. 协议组合"></a>3. 协议组合</h3><p>有时候我们需要表示一个对象实现多个协议，可以使用协议组合来表示，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SwimProtocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">WalkProtocal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">walk</span>()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">through</span>(<span class="params">animal</span>: <span class="keyword">protocol</span><span class="operator">&lt;</span><span class="type">WalkProtocal</span>, <span class="type">SwimProtocal</span><span class="operator">&gt;</span>)</span> &#123;</span><br><span class="line">    animal.walk()</span><br><span class="line">    animal.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自身类型"><a href="#4-自身类型" class="headerlink" title="4. 自身类型"></a>4. 自身类型</h3><p>有时候我们需要表示实现协议的类型，可以使用<code>Self</code>代替，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">CompareProtocal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Self表示实现协议自己的类型本身</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">compare</span>(<span class="params">other</span>: <span class="keyword">Self</span>)</span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span>: <span class="title">CompareProtocal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">compare</span>(<span class="params">other</span>: <span class="type">Product</span>)</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.id <span class="operator">==</span> other.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-objc协议"><a href="#5-objc协议" class="headerlink" title="5. @objc协议"></a>5. @objc协议</h3><p>swift声明的协议是不能直接被oc的代码桥接调用的，如果需要，需要在声明前加上<code>@objc</code>，使用<code>@objc</code>声明的协议不能被用于结构体和枚举</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;            <span class="comment">// 协议可以被桥接到oc中使用</span></span><br><span class="line">    <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Optional要求"><a href="#6-Optional要求" class="headerlink" title="6. Optional要求"></a>6. Optional要求</h3><p>在oc中的protocal可以定义可选方法，在swift默认不支持可选方法，swift只有在添加了<code>@objc</code>声明的协议才能定义可选方法，在定义前添加<code>optional</code>声明</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">HasArea</span> </span>&#123;</span><br><span class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> area: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;     <span class="comment">// 定义可选属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十三、错误"><a href="#十三、错误" class="headerlink" title="十三、错误"></a>十三、错误</h2><p>与其他高级语言异常处理有点类似，swift引入了错误的机制，可以在出现异常的地方抛出错误，错误对象继承自Error，抛出的错误函数会立即返回，并将错误丢给调用函数的函数处理，如果一个函数可能抛出错误，那么必须在函数定义的时候进行声明，如下</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义错误类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">OperationError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DivideByZero</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Other</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义可能抛出异常的函数，在函数声明的返回值前面加上throws</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span>(<span class="params">a</span>: <span class="type">Int</span>, <span class="params">b</span>: <span class="type">Int</span>)</span> <span class="keyword">throws</span> -&gt; <span class="type">Float</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b <span class="operator">==</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">OperationError</span>.<span class="type">DivideByZero</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Float</span>(a) <span class="operator">/</span> <span class="type">Float</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用可能出错的函数（调用出必须加上try）</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result <span class="operator">=</span> <span class="keyword">try</span> divide(a: <span class="number">10</span>, b: <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="type">OperationError</span>.<span class="type">DivideByZero</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(error)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">//其他错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果错误是一个对象，而不是枚举，可以用let绑定到变量上</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> divide(a: <span class="number">10</span>, b: <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> err <span class="keyword">as</span> <span class="type">SomeErrorType</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(err.message)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;other error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不处理错误的话可以使用<code>try?</code>，使用try?关键字的方法会被包装到一个可选类型中，如果发生错误，则会返回nil，如下面序列化的例子</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serialize</span>(<span class="params">obj</span>: <span class="type">AnyObject</span>)</span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> jsonString <span class="operator">=</span> <span class="keyword">try?</span> someSerializeFuncMayThrowError(obj) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(jsonString)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;fail&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>try?配合guard let一起使用效果更好</p></blockquote><h2 id="十四、断言"><a href="#十四、断言" class="headerlink" title="十四、断言"></a>十四、断言</h2><p>断言可以让我们在调试时候更好的发现问题，排查错误，几乎所有的高级语言都支持断言，swift也如此，断言的代码在release的时候回被忽略，不会影响发布程序的性能，只会在调试的时候生效</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果age小于0，程序会停止，并输出错误信息</span></span><br><span class="line"><span class="built_in">assert</span>(age <span class="operator">&gt;=</span> <span class="number">0</span>, <span class="string">&quot;A person&#x27;s age cannot be less than zero&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="十五、泛型"><a href="#十五、泛型" class="headerlink" title="十五、泛型"></a>十五、泛型</h2><p>关于泛型的介绍，这里不进行说明，swift的泛型是我认为最酷的特性之一，当然其他语言也有，可以让类或函数更大程度的重用，swift的泛型与其他语言的泛型有点类似</p><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>在类或函数声明的时候，指定一个泛型类型参数（通常为T）然后使用的时候直接把T当成类型使用</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;<span class="type">T</span>&gt;(<span class="params">inout</span> <span class="params">a</span>: <span class="type">T</span>, <span class="params">inout</span> <span class="params">b</span>: <span class="type">T</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA <span class="operator">=</span> a</span><br><span class="line">    a <span class="operator">=</span> b</span><br><span class="line">    b <span class="operator">=</span> temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">T</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个泛型类型参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span>&lt;<span class="title">T</span>, <span class="title">TK</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> code: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> errorMessage: <span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">T</span>?</span><br><span class="line">    <span class="keyword">var</span> subData: <span class="type">TK</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-泛型约束"><a href="#2-泛型约束" class="headerlink" title="2. 泛型约束"></a>2. 泛型约束</h3><p>我们还可以对泛型进行约束，泛型类型参数只能是某些类型的子类，或实现了某些协议</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;<span class="type">T</span>&gt;(<span class="params">array</span>: [<span class="type">T</span>], <span class="params">valueToFind</span>: <span class="type">T</span>)</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数会报编译错误，因为在swift里，并不是所有的类都能用<code>==</code>操作符比较，只有实现了Equatable协议的类才能用<code>==</code>操作符，修改为</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findIndex</span>&lt;<span class="type">T</span>: <span class="type">Equatable</span>&gt;(<span class="params">array</span>: [<span class="type">T</span>], <span class="params">valueToFind</span>: <span class="type">T</span>)</span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> array.enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> value <span class="operator">==</span> valueToFind &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-多泛型类型参数"><a href="#3-多泛型类型参数" class="headerlink" title="3. 多泛型类型参数"></a>3. 多泛型类型参数</h3><p>有时候我们需要用多个协议进行约束，可以使用下面方式（类与函数的使用方式类似）</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunc</span>&lt;<span class="type">T</span> : protocol&lt;<span class="type">StudyProtocal</span>, <span class="type">RunProtocal</span>&gt;</span><span class="operator">&gt;</span>(arg: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果约束既有类又有协议的话可以使用<code>where</code>添加限制条件</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunc</span>&lt;<span class="type">T</span>, <span class="type">TK</span> where <span class="type">T</span>:<span class="type">Student</span>, <span class="type">T</span>: <span class="type">StudyProtocal</span>&gt;(<span class="params">t</span>: <span class="type">T</span>, <span class="params">tk</span>: <span class="type">TK</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// do stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-泛型是不可变的"><a href="#4-泛型是不可变的" class="headerlink" title="4. 泛型是不可变的"></a>4. 泛型是不可变的</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dog1 <span class="operator">=</span> <span class="type">SomeClass</span>&lt;<span class="type">Parent</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dog2 <span class="operator">=</span> <span class="type">SomeClass</span>&lt;<span class="type">Son</span>&gt;()</span><br><span class="line"></span><br><span class="line">dog1 <span class="operator">=</span> dog2       <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><blockquote><p>关于可变，不可变，逆变，协变参考这里：<a href="http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/">http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/</a></p></blockquote><h3 id="5-泛型协议"><a href="#5-泛型协议" class="headerlink" title="5. 泛型协议"></a>5. 泛型协议</h3><p>swift的协议不支持泛型，不能像类一样定义泛型，而是通过类型参数定义泛型</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">GenericProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T1</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">T2</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someFunc</span>(<span class="params">t2</span>: <span class="type">T2</span>)</span> -&gt; <span class="type">T1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&lt;<span class="title">T</span>&gt; : <span class="title">GenericProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置泛型类型</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T1</span> <span class="operator">=</span> <span class="type">String</span></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">T2</span> <span class="operator">=</span> <span class="type">T</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someFunc</span>(<span class="params">t2</span>: <span class="type">T2</span>)</span> -&gt; <span class="type">T1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十六、运算符重载"><a href="#十六、运算符重载" class="headerlink" title="十六、运算符重载"></a>十六、运算符重载</h2><p>与其他高级语言的一样，swift也提供了运算符重载的功能，我们可以自定义运算符的实现，运算符通常分为三种类型</p><ul><li>单目运算符：<code>&lt;运算符&gt;&lt;操作数&gt;</code>或<code>&lt;操作数&gt;&lt;运算符&gt;</code>，如<code>!a</code></li><li>双目运算符：<code>&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;</code>，如：<code>1 + 1</code></li><li>三元运算符：<code>&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;</code>，如：<code>a ? b : c</code></li></ul><p>swift的运算符重载</p><ul><li>支持自定义运算符<code>/</code>, <code>=</code>, <code>-</code>, <code>+</code>, <code>*</code>, <code>%</code>, <code>&lt;</code>, <code>&gt;</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>.</code>, <code>~</code>的任意组合。可以脑洞大开创造颜文字。</li><li>不能对默认的赋值运算符<code>=</code>进行重载。组合赋值运算符可以被重载，如<code>==</code>，<code>!==!</code></li><li>无法对三元运算符<code>a ? b : c</code>进行重载</li><li>运算符声明和定义只能定义在全局作用域，不能定义在类/结构体/枚举内</li><li></li></ul><h3 id="1-前缀，中缀，后缀运算符"><a href="#1-前缀，中缀，后缀运算符" class="headerlink" title="1. 前缀，中缀，后缀运算符"></a>1. 前缀，中缀，后缀运算符</h3><ul><li>前缀<code>prefix</code>：默认的有-，!，~等</li><li>中缀<code>infix</code>：默认的有+，*，==等</li><li>后缀<code>postfix</code>：默认的有：++，–等</li></ul><h3 id="1-1-声明运算符"><a href="#1-1-声明运算符" class="headerlink" title="1.1 声明运算符"></a>1.1 声明运算符</h3><p>如果实现不存在的运算符需要添加运算符声明（系统的提供的，可以不需要声明），声明必须放在全局作用域</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀运算符</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中缀运算符（二元运算符）</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀运算符</span></span><br><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> <span class="title">+++</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-实现上面三个运算符"><a href="#1-2-实现上面三个运算符" class="headerlink" title="1.2 实现上面三个运算符"></a>1.2 实现上面三个运算符</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义Point结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载操作符要放在全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">+++</span> (<span class="params">left</span>: <span class="type">Point</span>, <span class="params">right</span>: <span class="type">Point</span>)</span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: left.x <span class="operator">+</span> right.x, y: left.y <span class="operator">+</span> right.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要修改操作数，需要添加inout关键字</span></span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> <span class="title">+++</span> (<span class="params">inout</span> <span class="params">left</span>: <span class="type">Point</span>)</span> &#123;</span><br><span class="line">    left.x <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    left.y <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">postfix</span> <span class="function"><span class="keyword">func</span> <span class="title">---</span> (<span class="params">right</span>: <span class="type">Point</span>)</span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Point</span>(x: right.x <span class="operator">-</span> <span class="number">1</span>, y: right.y <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-使用"><a href="#1-3-使用" class="headerlink" title="1.3 使用"></a>1.3 使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">12</span>, y: <span class="number">21</span>)</span><br><span class="line"><span class="keyword">var</span> p2 <span class="operator">=</span> <span class="type">Point</span>(x: <span class="number">12</span>, y: <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p3 <span class="operator">=</span> p1<span class="operator">+++</span>p2            <span class="comment">// p3.x = 24, p3.y = 23</span></span><br><span class="line"><span class="operator">+++</span>p1                       <span class="comment">// p1.x = 13, p1.y = 3</span></span><br><span class="line">p1<span class="operator">---</span>                       <span class="comment">// p1.x = 12, p1.y = 2</span></span><br></pre></td></tr></table></figure><h3 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2. 优先级"></a>2. 优先级</h3><p>这个很好理解，就是优先级高的运算符先执行，声明运算符的时候可以指明优先级</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity left        <span class="comment">// 结合性，后面说</span></span><br><span class="line">    precedence <span class="number">140</span>            <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.apple.com/reference/swift/1851035-swift_standard_library_operators">这里</a>可以查看默认运算符的优先级</p><h3 id="3-结合性"><a href="#3-结合性" class="headerlink" title="3. 结合性"></a>3. 结合性</h3><p>运算符还可以定义结合性，对于双目运算符，当优先级一样的时候，可以定义运算符优先进行左结合还是右结合，运算符的结合性有下面三种</p><ul><li>left：左结合</li><li>right：右结合</li><li>none：无</li></ul><p>结合性设置为<code>left</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个双目操作符</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity left         <span class="comment">// 结合性</span></span><br><span class="line">    precedence <span class="number">140</span>             <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">^</span> (<span class="params">left</span>: <span class="type">Int</span>, <span class="params">right</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(pow(<span class="type">Double</span>(left), <span class="type">Double</span>(right)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>           <span class="comment">// 执行结果为256</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> aa <span class="operator">=</span> ((<span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>) <span class="operator">^</span> <span class="number">2</span>) <span class="operator">^</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果我们设置结合性为<code>right</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个双目操作符</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> <span class="title">^</span> &#123;</span><br><span class="line">    associativity right         <span class="comment">// 结合性</span></span><br><span class="line">    precedence <span class="number">140</span>              <span class="comment">// 指定运算符优先级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">^</span> (<span class="params">left</span>: <span class="type">Int</span>, <span class="params">right</span>: <span class="type">Int</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(pow(<span class="type">Double</span>(left), <span class="type">Double</span>(right)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>           <span class="comment">// 执行结果为65536</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">let</span> aa <span class="operator">=</span> <span class="number">2</span> <span class="operator">^</span> (<span class="number">2</span> <span class="operator">^</span> (<span class="number">2</span> <span class="operator">^</span> <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>如果结合性设置为<code>none</code>，则会报错，无法判断</p><h2 id="十七、命名空间"><a href="#十七、命名空间" class="headerlink" title="十七、命名空间"></a>十七、命名空间</h2><p>在很多语言里面，都有命名空间的概念，可以分离代码，防止命名冲突，而swift也有类似命名空间的概念，通过访问级别实现命名空间<br>//TODO</p><h2 id="十八、参考链接"><a href="#十八、参考链接" class="headerlink" title="十八、参考链接"></a>十八、参考链接</h2><ul><li><a href="https://en.wikipedia.org/wiki/Operator_associativity#Right-associativity_of_assignment_operators">运算符结合性</a></li><li><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html">Swift高级运算符</a></li></ul><h2 id="十九、总结"><a href="#十九、总结" class="headerlink" title="十九、总结"></a>十九、总结</h2><p>总的来说，swift还是比较装逼的，整个很多新名词，新概念，例如，指定构造器，便利构造器，构造器代理，但其实这些东西在别的语言基本上有，没那么复杂，另外swift的关键字太多了，有些可有可无，是不是苹果看到什么好的就想往swift里面塞还是怎么着，另外感觉苹果还是太装逼了，例如do-while非要偏偏要搞成repeat-while啥的，个人感觉编程语言应该是轻便，简单，当然，并且能满足所有需求的，反正，没什么特别的好感</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
