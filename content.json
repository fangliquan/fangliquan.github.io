{"meta":{"title":"microleo的个人博客","subtitle":"工作学习中的学习笔记及技术积累","description":"iOS,Windows开发者","author":"microleo","url":"http://fangliquan.github.io","root":"/"},"pages":[{"title":"tags","date":"2016-07-23T08:20:53.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"tags/index.html","permalink":"http://fangliquan.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2016-07-23T09:09:37.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"about/index.html","permalink":"http://fangliquan.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2016-07-23T08:20:38.000Z","updated":"2017-03-20T10:28:58.000Z","comments":false,"path":"categories/index.html","permalink":"http://fangliquan.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS面试整理(一)","slug":"iOS面试整理(一)","date":"2021-03-14T07:53:58.000Z","updated":"2021-03-16T03:24:54.576Z","comments":true,"path":"2021-03-14/iOS面试整理(一)/","link":"","permalink":"http://fangliquan.github.io/2021-03-14/iOS%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86(%E4%B8%80)/","excerpt":"","text":"iOS一、内存管理1.谈谈对内存管理的理解MRC (手动引用计数) 和ARC (自动引用计数) MRC 核心思想：引用计数式内存管理 四个法则 自己生成的对象自己持有 (使用 alloc/new/copy/mutableCopy 开头的方法生成对象后持有对象) 非自己生成的对象自己也能持有 (retain) 123id obj &#x3D; [NSArray array]; &#x2F;&#x2F; 非自己生成的对象，且该对象存在，但自己不持有&#x2F;&#x2F; 通过autorelease使对象的持有权在AutoreleasePool[obj retain]; &#x2F;&#x2F; 自己持有对象 不再需要自己持有的对象时释放 (release) 非自己持有的对象不能释放 对象操作对应的方法 对象操作 OC中方法 retainCount变化 生成并持有对象 alloc/new/copy/mutableCopy +1 持有对象 retain +1 释放对象 release -1 废弃对象 dealloc 无 alloc/new方法通过调用 allocWithZone: 类方法分配存储空间并初始化，同时使得retainCount = 1。 调用 retain 方法后引用计数值+1。 调用release方法后引用计数-1。 当retainCount = 0 时，调用 dealloc 方法废弃对象。 苹果将引用计数保存在引用计数表中（是一个散列表） 优点： 对象内存块的分配无需考虑内存块头部 引用计数表各记录中有内存块地址，可从各个记录追溯到各对象的内存块。（即使对象占用内存块损坏，能够根据引用计数表找到各内存块的位置） autorelease autorelease使得对象在超出其作用作用域（生命周期）后，在废弃autoreleasepool时，其中所有对象的release方法会被调用一次，可以指定变量的作用域。 步骤： 生成并持有 NSAutoreleasePool 对象 调用已分配对象的 autorelease 对象方法 废弃NSAutoreleasePool对象。（调用 - drain 对象方法） release 和 autorelease 区别： 调用 release 方法，对象会立即被释放 调用 autorelease 方法，对象不会立即被释放，而是被注册的 autoreleasepool 中，当autoreleasepool 对象被废弃时（drain），对其中的对象都做一次 release 操作。 ARC 本质还是引用计数式内存管理 由编译器进行内存管理。实际上是 编译器 + 运行时库。在编译时，系统自动在合适的位置添加 retain/ release/ dealloc/ autorelease 方法。 所有权修饰符 ARC中通过变量所有权修饰符，不需要使用 retain/release 就能完美满足引用计数式的思考方式： 从手写 release 语句变为通过控制对象的作用域控制对象的释放。 “自己生成的对象自己持有” 和 “非自己生成的对象自己也能持有” 通过对带 __strong 修饰符的变量赋值即可达到，“不再需要自己持有的对象时释放”通过废弃带 __strong 修饰符的变量（变量作用域结束或成员变量所属对象被废弃）或变量赋值（nil）（block中打破循环引用）做到。 __strong、__weak、__autoreleasing 修饰的自动变量会自动初始化为nil 对象没有被变量强引用着时，该对象被释放。 __strong : id 类型和对象类型默认的所有权修饰符。表示对对象的强引用。 在被 __strong 修饰的变量超出其作用域时，即在该变量被废弃时，会释放其被赋予的对象（随强引用的失效，引用的对象随之释放）。当要废弃被强引用的对象时，要保证所有指向该对象的强引用变量都置为nil。 __weak 提供弱引用，弱引用不能持有对象。当持有对象的弱引用时，若该对象被废弃，则此弱引用自动失效，且被置为nil。 使用 __weak 修饰符的变量，就是使用注册到 autoreleasepool中的对象。 __unsafe_unretained 声明这个引用不会保持对象的存活，如果对象被废弃，不会被置nil，该变量会变成野指针。使用被其修饰的变量时，先判断是否存在。被其修饰的变量不属于编译器的内存管理对象。 __autorelease 在ARC中替代 - autorelease 方法。如果方法名不以 alloc/new/copy/mutableCopy 开头，编译器自动将返回值的对象注册到 autoreleasepool 中（ init 开头的方法返回的对象不会被注册到 autoreleasepool 中，只是对 alloc 方法返回值的对象） 内存泄漏：应当被废弃的对象在超出其生存周期后依然继续存在。 2.ARC如何实现？通过变量所有权修饰符，满足引用计数式内存管理。 编译器+运行时。 ==通过运行时发送消息，通过编译器自动插入release==。 __strong 修饰符 使用 alloc/new/copy/mutableCopy 产生对象 123&#123; id __strong obj &#x3D; [[NSObject alloc] init];&#125; 在编译后转换为 123id obj &#x3D; obj_msgSend(NSObject, @selector(alloc));obj_msgSend(obj, @selector(init));obj_release(obj); &#x2F;&#x2F; 编译器插入 两次调用 obj_msgSend() 方法，在作用域结束调用 obj_release 释放对象。编译器自动插入了release。 非 alloc/new/copy/mutableCopy 产生对象 123&#123; id __strong obj &#x3D; [NSMutableArray array];&#125; 编译后转换为 123id obj &#x3D; objc_magSend(NSMutableArray, @selector(array));objc_retainAutoreleaseReturnValue(obj); &#x2F;&#x2F; 编译器插入objc_release(obj); objc_retainAutoreleaseReturnValue() 函数用于持有对象，但持有的对象应为函数的返回值或者注册在 autoreleasepool 中的对象。 123+ (id) array &#123; return [[NSMutableArray alloc] init];&#125; 编译后转换为 12345+ (id) array &#123; id obj &#x3D; objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; 调用obj_autoreleaseReturnValue() 时，如果方法或函数的调用方在调用了方法或函数后紧接着调用了 objc_retainAutoreleaseReturnValue() 函数，那么就不将返回的对象注册到 autoreleasepool 中-而是直接传递给方法或函数的调用方。 3.对MRC的理解4.GC（垃圾回收）和ARC的区别？ ARC 相比 GC 优点： ARC 工作在编译期，在运行时没有额外的开销。 ARC 的内存回收是平稳进行的，当对象不被持有时会立即被回收。 GC 的内存回收时需要暂停程序，会有一定的卡顿。 ARC 相比 GC 缺点： ==ARC 需要手动处理循环引用等内存管理问题，GC 不需要。== 5.内存关键字（assign, weak, strong, copy, retain)介绍 assign：用于非对象类型。其 setter 方法只是执行简单的赋值操作。 weak：用于对象类型，表示弱引用。其 setter 方法中既不保留新值，也不释放旧值，同assign类似。 但是在属性所指对象遭到废弃时，属性值会被置nil。 strong：用于除 NSString/block 之外的对象类型，表示一种“拥有关系”，表示对对象的持有和强引用。其 setter 方法中，先 relsease 旧值，再 retain 新值。 copy：所表达的所述关系与 strong 类似。在其 setter 方法中，不保留新值，而是将其 copy。当属性类型为 NSString 类型时，通过 copy 关键字保护器封装性，防止指向 MutableString 类型。 retain：MRC中使用，作用同 strong 相同。 6.weak和strong关键字内部做了什么？7.除了NSString什么情况下用copy？block为什么要复制到堆中？ 带有可变类型的对象，比如 NSArray、NSDictionary等。 因为父类指针能够指向子类对象，使用 copy 的目的是让本对象的属性不受外界影响，使用 copy 后无论传入的是可变还是不可变的对象，==本身持有的就是一个不可变对象==。 当用 strong 时，该属性可能指向一个可变对象，如果这个对象在外部被修改了，那么就会修改该属性。 用作 block 的关键字。 在 ARC中，对 block 使用 strong 和 copy 效果一样，ARC 中会自动将栈上的 block 拷贝到堆中。这里使用 copy 关键字是为了提醒我们这里的 block 被复制到了堆中。 扩展：block 为什么要复制到堆中？ 将栈中的 block 复制到堆上，这样即使 block 语法记述的变量作用域结束，堆上的 block 还可以继续存在。 当 block 从栈复制到堆时，block 中使用的 __block 变量也全部从栈复制到堆中，此时 blcok 持有 __block 变量。如果堆上的 block 被废弃，那么它使用的 __block 变量也就被释放。 8.调用静态方法（类方法）时需要release么？静态方法（类方法）创建的对象自动加入了自动释放池中，所以不需要release。 9. autorelease，AutoreleasePool的原理是什么？autoreleasepool 以==队列数组的形式==实现，主要通过3个函数完成： 1.objc_autoreleasePoolPush 创建 autoreleasepool，相当于NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]。 2.objc_autoreleasePoolPop 倾倒 autoreleasepool，相当于 [pool drain]。 3.objc_autorelease 将对象加入 pool 中。 扩展：如果 autorelease NSAutoreleasePool对象会如何？ 答：发生异常。无论调用哪一个对象的 autorelease 实例方法，实际上是调用 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已经被重载，因此运行时会出错。 10.autoreleasepool的drain时机 手动创建的 autoreleasepool（指定的autoreleasepool）：当作用域大括号结束时释放。 系统创建的 autoreleasepool（不指定autoreleasepool）：autorelease 对象出作用域后，被添加到==最近一次创建的== autoreleasepool 中，==在当前 runloop 结束时释放==。 当 runloop 检测到事件并启动后，会自动创建一个 autoreleasepool 。 所有延迟释放的对象都被添加到这个 autoreleasepool 中。 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。 当 runloop 即将结束时，倾倒 autoreleasepool ，向其中所有的对象发送 release 消息后，autoreleasepool 被销毁。 11.autoreleasepool的作用ARC中，不允许使用 autorelease 方法，每个 runloop 循环中系统都自动加入了autoreleasepool 的创建和释放 但是，==在需要创建和销毁大量对象时（大数的 for 循环中创建和销毁对象），使用手动创建的 autoreleasepool 可以避免内存峰值的出现==。如果不手动创建，被加入系统创建的 autoreleasepool 中的对象在 runloop 结束时才会被统一执行 release 操作，如果在 for 循环内部创建 autoreleasepool，那么每循环一次都会执行 release 操作。 12345678for (int i &#x3D; 0; i &lt; 100000000; i++)&#123; @autoreleasepool &#123; NSString* string &#x3D; @&quot;ab c&quot;; NSArray* array &#x3D; [string componentsSeparatedByString:string]; &#125;&#125; 12.iOS中堆栈的理解？ 堆栈的区别 堆空间的内存是动态分配的，一般存放对象，需要手动释放。 栈空间的内存是系统自动分配的，一般存放局部变量等，系统自动回收。 13.weak在对象销毁时使指向对象的指针置nil的原理？ 使用哈希表（散列表实现） key：对象的内存地址。 value：被__weak修饰的变量的地址。 当对象被废弃时发生： 从weak表中获取被废弃对象的地址为key的记录。（获取记录） 将包含在记录中所有被__weak修饰的变量的地址，赋值为nil。(赋值为nil) 从weak表中删除记录。(删除记录) 从引用技术表中删除被废弃对象的地址为键值的记录。 14.block作为viewControler属性时，如果block块中使用了self.view会发生循环引用么？会发生。 在block代码块之前使用__weak typeof(self) weakSelf = self;，打破闭环。 二、多线程1.对多线程的理解？进程：CPU分配资源和调度的最小单位 线程：CPU执行任务的最小单位 2.iOS中实现多线程的方式有哪些？3.GCD和NSOperation优缺点？ GCD是纯C语言的 API，NSOperation 是基于 GCD 的面向对象的封装。 NSOperation 可以轻松在 operation 间设置依赖，设置它们的优先级，任务能够被方便地暂停、恢复，可以自定义子类。可以将 KVO 应用在 NSOperation 中，监听一个 operation 是否完成、取消、正在执行。可以设置最大并发数。 GCD 以 block 为单位，代码简洁，更为轻量化。对于一次性运算，或是仅仅为了加快现有方法的运算速度，选择轻量化的 GCD 更为方便。 4.死锁发生的原因是什么？如何避免？12345@autorelease &#123; dispatch_sync(dispatch_get_main_queue(), ^(void)&#123; NSLog(@&quot;发生死锁&quot;)； &#125;)；&#125; 同步函数，会把 block 加入指定队列中，会一直等待 block 执行完成才返回。因此在 block 执行完之前，调用同步函数的线程是阻塞的。 异步函数，会把 block 加入指定队列中，不会等待 block 执行，会立即返回。只负责向队列中添加任务。 串行队列：按照任务的添加顺序执行任务。并且保证在执行某个任务时，它前面进入队列的任务都执行完了。 并发队列：按照任务的添加顺序 开始 执行任务。任务执行的结束时间不确定，取决于每个任务的耗时。 原因：主线程是串行的，在执行同步函数时被阻塞，同步函数要求 block 块执行完毕后才返回，这样主线程才能继续向下执行；由于在主线程中，执行 block 块要求同步函数执行完毕才进行，这样就造成了双方的互相等待，导致了死锁的发生。 导致死锁的原因一定是：在某个串行队列中，同步地向这个队列添加任务。(在串行队列中，同步函数向相同串行队列中添加任务) 注意：发生死锁要具体分析同步函数所在的队列是并发队列还是串行队列，并且 block 要添加到哪种队列。 如果使用异步函数添加任务，无论任务是否添加到串行队列都不会发生死锁，因为异步函数不会阻塞线程。 只在解决数据竞争问题时使用串行队列。 使用同步函数 + 串行队列的组合不一定会发生死锁。同步函数所在的串行队列和要添加任务的队列不同时，不会发生死锁。 5.iOS中有哪些锁？锁：一段代码在一段时间内只能被一个线程访问。 NSLock NSCondition 条件锁 NSConditionLock 条件锁 NSRecursiveLock 递归锁 6.iOS中线程安全有哪些情况？死锁，数据竞争，优先级反转 7.多线程操作对同一块资源发生数据竞争时能怎样做？ 互斥锁 @synchronized 优点：不需要在代码中显式地创建锁对象，就能实现锁的机制。 缺点：消耗大量CPU资源。 串行队列：一个串行队列就会开一条子线程，多个串行队列并发执行，可以用dispath_set_target_queue设置执行阶层。将不同的串行队列设置到新的串行队列中串行执行。 栅栏函数：使用并发队列和栅栏函数能实现高效的数据库访问和文件访问。 信号量：当信号量为1时可以当做锁使用。控制同时访问特定资源的线程数量。优势在于等待时不会消耗CPU资源。 dispatch_semaphore_create(long value) 创建信号量，括号中的数字表示能允许同时操作的线程数量。 dispatch_semaphore_wait(dispatch_semaphore_t _Nonnull dsema, dispatch_time_t timeout) 第一个参数：信号量 第二个参数：阻塞时间。表示如果信号量为0时阻塞线程的时间。DISPATCH_TIME_FOREVER 表示永久阻塞。 当信号量 = 0 时，函数返回1，表示需要等待，不允许操作。 当信号量 &gt;= 1是，函数返回0，表示不需要等待，继续执行操作。并把信号量 - 1 dispatch_semaphore_signal(dispatch_semaphore_t _Nonnull dsema) 执行完操作后调用，将信号量 + 1。 NSMutableArray *array = [[NSMutableArray alloc] init]; dispatch_semaphore_t semaphore = dispatch_semaphore_create(1); for (int i = 0; i &lt; 100; i++) &#123; dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 信号量是0时等待，非0时，经过dispatch_semaphore_wait函数后信号量-1，其他线程等待 [array addObject:[NSNumber numberWithInteger:i]]; NSLog(@&quot;%d---%ld---%@&quot;, i, array.count, [NSThread currentThread]); dispatch_semaphore_signal(semaphore); // 信号量+1 &#125;); &#125; 1234567891011121314151617181920212223- NSLock - 通过 &#96;- (void)lock &#96;和 &#96;- (void)unlock &#96;配对使用实现代码的锁定，只能执行被锁定的代码。需要使用相同的锁对象才能实现互斥。 &#96;&#96;&#96;objective-c &#x2F;&#x2F; 实例类person Person *person &#x3D; [[Person alloc] init]; &#x2F;&#x2F; 创建锁 NSLock *myLock &#x3D; [[NSLock alloc] init]; &#x2F;&#x2F; 线程A dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; &#x2F;&#x2F; 锁定 [person personA]; [NSThread sleepForTimeInterval:5]; [myLock unlock]; &#x2F;&#x2F; 解锁 &#125;); &#x2F;&#x2F; 线程B dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [myLock lock]; &#x2F;&#x2F; 锁定 [person personB]; [myLock unlock]; &#x2F;&#x2F; 解锁 &#125;); - (BOOL)tryLock：尝试锁定，如果加锁失败（已经被锁定）返回NO，不会阻塞线程。如果成功，同 -lock效果一样，用 -unlock 解锁。 - (BOOL)lockBeforeDate:(NSDate *)limit：在date时间之前尝试锁定，如果在date时间内都不能完成锁定，返回NO。如果成功，同 -lock效果一样，用 -unlock 解锁。 NSCondition：最基本的条件锁，手动控制线程 wait（等待）和 signal （继续） [condition lock] 锁定代码，其他线程的命令需要在lock 外等待，只到unlock ，才可访问。 [condition unlock 与lock 同时使用。 [condition wait] 让当前线程处于等待状态。 [condition signal] CPU发信号告诉线程不用在等待，可以继续执行。 123456789101112131415161718192021222324252627NSCondition *condition &#x3D; [[NSCondition alloc] init];NSMutableArray *products &#x3D; [NSMutableArray array];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; if ([products count] &#x3D;&#x3D; 0) &#123; NSLog(@&quot;wait for product&quot;); [condition wait]; &#x2F;&#x2F; 线程等待 &#125; [products removeObjectAtIndex:0]; NSLog(@&quot;custome a product&quot;); [condition unlock]; &#x2F;&#x2F; 解锁 &#125;&#125;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [condition lock]; [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;produce a product,总量:%zi&quot;,products.count); [condition signal]; &#x2F;&#x2F; 恢复线程 [condition unlock]; &#x2F;&#x2F; 解锁 sleep(1); &#125;&#125;); ​ NSConditionLock：条件锁，可以设置加锁/解锁条件，只有满足条件时才能加锁/解锁。 - (void)lockWhenCondition:(NSInteger)condition 满足条件时才能加锁。 - (void)unlockWithCondition:(NSInteger)condition 满足条件时才能解锁。 - (BOOL)tryLockWhenCondition:(NSInteger)condition 满足条件尝试加锁。 - (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit 满足条件在limit时间内尝试加锁。 同时 NSLock 的相关方法依旧能够使用，可以使用 - lock 和 - unlock 方法加锁或解锁。 1234567891011121314151617181920212223NSMutableArray *products &#x3D; [NSMutableArray array];NSInteger HAS_DATA &#x3D; 1;NSInteger NO_DATA &#x3D; 0;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; [lock lockWhenCondition:NO_DATA]; &#x2F;&#x2F; 满足条件加锁 [products addObject:[[NSObject alloc] init]]; NSLog(@&quot;produce a product,总量:%zi&quot;,products.count); [lock unlockWithCondition:HAS_DATA]; &#x2F;&#x2F; 满足条件解锁 sleep(1); &#125;&#125;);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; while (1) &#123; NSLog(@&quot;wait for product&quot;); [lock lockWhenCondition:HAS_DATA]; &#x2F;&#x2F; 满足条件加锁 [products removeObjectAtIndex:0]; NSLog(@&quot;custome a product&quot;); [lock unlockWithCondition:NO_DATA]; &#x2F;&#x2F; 满足条件解锁 &#125;&#125;); NSRecursiveLock：递归锁，这个锁可以被同一线程多次使用，而不会引起死锁。主要用在循环及递归操作中。递归锁会跟踪它被 lock 的次数。每次成功的 lock 都必须平衡调用 unlock 操作。只有这样锁才会被最终释放。 123456789101112131415161718&#x2F;&#x2F;NSLock *lock &#x3D; [[NSLock alloc] init];NSRecursiveLock *lock &#x3D; [[NSRecursiveLock alloc] init];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; static void (^RecursiveMethod)(int); RecursiveMethod &#x3D; ^(int value) &#123; [lock lock]; if (value &gt; 0) &#123; NSLog(@&quot;value &#x3D; %d&quot;, value); sleep(1); RecursiveMethod(value - 1); &#x2F;&#x2F; 递归调用 &#125; [lock unlock]; &#125;; RecursiveMethod(5);&#125;); 在这里如果把锁对象换为 NSLock 类型的话，从第二次递归调用开始会发生死锁。因为每次进入 block 都会加一把锁，从第二次开始因为已经加了锁并且没有解锁， 所以要等待解锁，造成了死锁，造成线程阻塞而 crash。如果换成 NSRecursiveLock 类就不会造成死锁。 8.atomic实现原理atomic为原子属性，为setter方法加互斥锁 123456@property(atomic, assign)int age;- (void)setAge:(int)age &#123; @synchronized(self)&#123; _age &#x3D; age; &#125;&#125; atomic 和 nonatomic 比较 atomic：线程安全（并非真正安全），需要消耗大量CPU资源。 例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。 nonatomic: 非线程安全，适合移动设备。 9.在主线程调用 dispatch_sync(自定义串行队列) 不会发生死锁的原因？dispatch_sync() 向当前线程中添加一个任务到指定队列 如果指定队列同调用dispatch_sync() 的队列是同一个串行队列。串行队列中的任务是上一个任务执行完毕才会执行下一个任务。dispatch_sync()会将Block任务添加到队列尾部，等队列中所有任务执行完毕后才会执行；dispatch_sync() 需要Block任务执行完毕才会返回，造成互相等待。 在追加Block执行结束之前，dispach_sync 会一直等待，等待意味着线程停止。 如果指定队列同调用dispatch_sync() 的队列不是同一个队列。系统会在当前线程中新开一条指定队列，并加入Block任务到新开队列中，Block任务被执行并返回，然后dispatch_sync() 返回。指定队列无论是串行和并行的，在dispatch_sync() 所在队列中串行执行任务，因为dispatch_sync() 是阻塞的。 dispatch_async() 新开线程执行任务，不等Block执行完毕就返回。 10.为什么使用atomic关键字的对象不一定是线程安全的？使用atomic只能保证 setter 方法和 getter 方法是线程安全的。但是仍然可能出现线程不安全的情况： @property(atomic, strong)NSMutableArray *array一个线程循环读数据，另一个线程循环存数据，这时就不是线程安全的，因为跟 setter 和 getter 方法没有关系。比如使用[array addObject:object]向数组中添加对象，因为不涉及到 setter 和 getter 方法，故不是线程安全的。 多线程数据为什么不安全？ 每条线程都有自己独立的栈空间，但是它们公用堆空间，所以可能同时访问同一块内存空间，因此造成数据竞争。 三、UI1.UITableView优化 使用 UITableViewCell 重用机制。 利用 RunLoop 空闲时间执行预缓存任务。 利用 RunLoopObserver 观察当前 RunLoop 的运行状态，并在状态切换时收到通知。 在 RunLoop 即将进入睡眠时使用。 将预缓存任务分解到多个 RunLoop 中执行。 2.UITableViewCell重用机制的原因和原理是什么？ 关键： ==可变数组NSMutableArray *visiableCells 保存屏幕正在显示的cell。== ==可变字典NSMutableDictionary *reusableTableCells 保存可重复利用的cell, key是重用标识identifier。== ==[tableView dequeueReusableCellWithIdentifier:identifier] 从reusableTableCells中根据identifier取可被重用的cell。== 原因：设备内存有限，TableView中有许多cell，而屏幕只能显示有限个cell，如果根据数据将cell全部创建完毕，会造成很大的内存负担。屏幕外的cell不需要立即创建，当滑动屏幕浏览cell时再加载。 作用：只创建了屏幕可显示的最大cell数+1个cell，然后循环使用这些cell，同时改变cell显示的数据，达到节省空间的目的。 原理： 第一次执行-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 方式时，reusableTableCells为空，[tableView dequeueReusableCellWithIdentifier:idertifier forIdentifiter:identifiter] 方法的返回值为nil。 此时通过[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifier:identifier] 创建新的cell。 当数据很多，整个屏幕的cell显示不完全时 调用[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault] reuseIdentifiter:identifier] 创建整个屏幕能显示的cell个数+1个cell（滑动屏幕时，第一个cell还没移出，最后一个cell已经出现），并且制定标识符identifier。 将创建并显示除最后一个外的cell加入visiableCells 数组，此时reusableTableCells字典为空。 滑动屏幕时，顶端的cell移出屏幕，该cell从visiableCells 数组中移除，并加入到reusableTableCells 字典中，key为该cell的identifier。将最后一个cell加入到visiableCells 数组中。 继续滑动时，reusableTableCells 中已经有值。需要显示新的cell时，cellForRowAtIndexPath 再次被调用，执行[tableView dequeueReusableCellWithIdentifier:identifier] 方法，返回一个标识为identifier的cell。该cell从reusableTableCells 中移除，添加到visableCells 中，如果resuableTableCells 中没有identifier类型的cell，就会创建一个；同时，移出屏幕的cell从visiableCells 中移除，添加到resuableTableCells 中。 iOS6中新方法 [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier: identifier] 当从reusableTableCells 中取cell时，如果没有，系统会自动创建给定类型的cell；如果有，直接重用。 在cellForRowAtIndexPath 中只需要 12345- (UITableViewCell *)table:(UITableView *)tableView cellForRowAtIdexPath:(NSIndexPath *)indexPath &#123; &#x2F;&#x2F; 系统会自动判断cell是否存在，不需要手动判断。 UITableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifiter:identifiter forIndexPath:indexPath]; return cell;&#125; 3.怎样裁剪圆头像4.自定义控件的封装5.viewController生命周期 viewWillAppear 之后，viewDidAppear 之前会调用 viewWillLayoutSubviews 和viewDidLayoutSubviews ，可以修改subviews。 -loadView 中初始化view, 由系统调用，==在 viewController 的 view 被访问并且为nil时调用==（self.view = …），可能被调用多次。 6.改变UIButton的点击面积重写UIButton的-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event方法。 该方法返回BOOL值表示判断当前的点击或触摸事件是否在当前的UIView中。 123456789@inplementation NewButton-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; CGRect bounds &#x3D; self.bounds; bounds &#x3D; CGRectInset(bounds, -50, -50); &#x2F;&#x2F; 该按钮上下左右范围各扩大了50. return CGRectContainsPoint(bounds, point);&#125;@end bounds = CGRectInset(bounds, -50, -50) 后两个参数是在左右方向和上下方向扩大或缩小的长度，正值表示缩小，负值表示扩大。该行代码表示在水平和竖直方向各扩大了100。 苹果要求：点击的热点区域不小于44*44 pt。 7.UIView、UIButton 、UITableView的继承关系?UIView -&gt; UIResponder -&gt; NSObject UIButton -&gt; UIControl -&gt; UIView - &gt; UIResponder -&gt; NSObject UITableView -&gt; UIScrollView -&gt; UIView -&gt; UIResponder -&gt; NSObject 四、设计模式1.KVO的原理？KVO的实现依赖于Runtime，使用isa混写（isa-swizzling）实现。当观察对象A时，KVO机制动态的创建对象A当前类的子类，并为这个新类重写了被观察属性的setter方法，在setter方法中通知观察对象属性的改变情况。将对象A的isa指针的指向修改为创建的新类。 具体实现 当观察对象A时，KVO机制动态地创建一个名为NSKVONotifying_A的新类，该类继承自对象A原来的类，并重写了被观察属性值的setter方法。重写的setter方法负责在调用原setter方法之前和之后，通知所有观察对象：属性值得更改。最后通过isa混写（isa-swizzling）把这个对象的isa指针指向新创建的子类，对象变成了新创建子类的实例。 setter方法剖析： KVO依赖于两个方法-willChangeValueForKey:和-didChangeValueForKey:，在原setter方法之前和之后分别调用。重写setter方法的注入是在运行时而不是在编译时。 -willChangeValueForKey:在属性值发生改变之前即原setter方法之前调用，通知keyPath属性值即将发生改变。 -didChangeValueForKey:在属性值发生改变之后即原setter方法之后调用，通知keyPath属性值已经发生改变。 之后-observerValueForKeyPath:ofObject:change:context也会被调用 - (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@&quot;name&quot;]; [super setValue:newName forKey:@&quot;name&quot;]; // 调用父类的存取方法,KVC实现 [self didChangeValueForKey:@&quot;name&quot;]; &#125; 12345678910111213141516171819- 使用前提 KVO被观察的是对象属性，只有__通过setter方法__或__KVC方法__修改对象属性时KVO才能被触发，使用KVO机制的__*前提是遵循KVO的属性设置方式来变更属性值*__。#### 2.手写KVO观察对象过程：1. 为__观察的对象__注册观察者 &#96;&#96;&#96;objective-c &#x2F;* 第一个参数：观察者，负责处理监听事件的对象 第二个参数：被观察的属性 第三个参数：被观察属性新旧值得一些配置 第四个参数：上下文，可以为KVO回调方法传值 *&#x2F; [self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil]; 被观察的属性发生变化时，收到通知，调用方法： 12345678910&#x2F;* 第一个参数：被观察的属性 第二个参数：被观察的对象 第三个参数：改变的属性值，前后的变化都存在字典中 第四个参数：上下文，context传递的值 *&#x2F;- (void)observeValueForKeyPath:(NSString *)keyPath object:(id)object change:(NSDictionary *)change context:(void *)context &#123; if([keyPath isEqualToString:@&quot;name&quot;] &amp;&amp; object &#x3D;&#x3D; self.person) &#123; &#x2F;&#x2F; 响应变化处理 NSLog(@&quot;new:%@, old:%@&quot;, [change valueForkey:@&quot;old&quot;], [change valueForKey:@&quot;new&quot;]); &#125;&#125; 在-dealloc方法中注销观察者 123- (void)dealloc&#123; [self.person removeObserver:self forKeyPath:@&quot;name&quot; context:nil];&#125; 3. 怎样手动触发KVO？​ 手动调用-willChangeValueForKey:和-didChangeValueForKey: ​ 场景：希望能控制”回调的调用时机时“（控制-didiChangeValueForKey调用） 4.KVC中setValue: forKeyPath: 复制过程？ 调用 setter 方法。 如果没有对应的 setter 方法，判断是否有与 key 值同名的成员属性，如果有，直接赋值。 如果没有与 key 值同名的成员属性，判断是否有与 key 值同名带下划线的成员属性，如果有，直接赋值。 报错：找不到对应的成员属性。 5.对MVC的理解？6.Notifaction、KVO、block、delegate的区别？当发生大量通信时用哪种方式？（delegate） delegate：一对一 优点： 语法严谨，所有收听到的事件都必须有清楚的定义。 delegate协议中的方法如果没有实现编译器会报错。 每个controller可以遵守多个协议，每个协议有不同的delegate。 能够接收调用协议的协议方法的返回值。delegate可以返回信息给controller。 没有第三方对象要求保持/监视通信过程。 缺点： 需要定义的代码多：协议的定义，controller的delegate属性，在delegate本身中实现delegate方法的定义。 释放代理对象的时候，需要将delegate改为nil，否则调用对象的方法会crash。 block： 优点 代码量比delegate少，更轻型，使用方便。 缺点： 需要注意循环引用的问题。 有多个方法时，假如每个方法设置一个block会更麻烦。 Notifaction：一对多 优点： 需要写的代码少。 一对多实现简单。 controller能传递context对象（NSDictionary），context对象携带了发送通知的自定义信息。 缺点： 编译期不会检查通知是否能被被观察者正确的处理。 释放注册的对象时，需要在通知中心取消注册。 需要第三方管理controller和观察者的关系。 通知发出后，发出通知的对象不能从观察者获得任何反馈。 KVO：可以一对多 优点： 能够提供观察的属性的新值和旧值。 通过keyPath观察属性，因此也可以嵌套对象。 能够对非我们创建的对象，即内部对象的状态改变做出相应，而且不需要改变内部对象的实现。 不需要额外的代码允许观察值能够被观察。 缺点： 被观察的属性必须用string定义，编译器不会对其进行检查，可能写错。 对属性的重构导致代码不可用。 所有的观察代码通过一个方法来指向，导致方法中复杂的if语句。 释放观察者时需要移除观察者。 五、网络请求1.NSURLSession和NSURLConnection区别？NSURLConnection从iOS 9废弃，NSURLSession在WWDC2013发布。 普通任务和上传 NSURLSession 针对普通会话、上传、下载有三种不同的任务NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownnloadTask。创建的会话都是挂起状态，需要resume才能启动。 当服务器返回的数据较小时，NSURLSession和NSURLConnection执行普通任务的操作没有区别。 执行上传任务时，NSURLSession和NSURLConnection一样需要设置POST请求的请求体进行上传。 请求方法的不同 NSURLConnection实例化对象， 通过-initWithRequest: delegate:创建的请求被自动发送 通过-initWithRequest: delegate: startImmediately:NO创建的请求通过[connect start]发送请求，方法内部把connect对象作为一个source添加到当前线程的runloop的默认模式下执行。(如果runloop不存在会自动创建当前线程对应的runloop) NSURLSession可以cancel(取消)、suspend(暂停)、resume(恢复)会话，暂停以后可以恢复继续请求。 下载任务的方式不同 NSURLConnection下载文件时，先将文件下载到内存，再写入沙盒，如果文件比较大，会出现内存暴涨的情况。 NSURLSessionDownloadTask 下载文件，默认下载到沙盒中的tem文件中，不会出现内存暴涨的情况。但是下载完成后会把tem中的临时文件删除，需要在completionHandler回调方法中将下载的文件移动到别的文件夹。 在代理方法中，能够方便地监听文件的下载进度。 断点续传方式不同（NSURLSession更加方便） NSURLConnection实现断点续传需要通过设置请求头的HTTPHeaderField的range属性进行。 NSURLSessionDownloadTask进行断点续传 当Task暂停时，如果downloadTask非空，调用-cancelByProducingResumeData:(void(^)(NSData *resumeData))completionHandler接收resumeData参数，保存已下载文件。(注意block中的循环引用，定义self的属性_resumeData, weakSelf.resumeData = resumeData) 再次下载是，如果self.resumeData != nil那么调用[[self.session downloadTaskWithResumeData:self.resumeData] rusume]继续下载，否则创建会话和下载任务。 NSURLSession可以设置配置信息Configuration。 +(NSURLSession *)sessionWithConfiguration: delegate: delegateQueue: 可以设置缓存策略，是否在后台进行请求，最大主机连接数，网络超时等。 2.AFN框架为什么封装NSURLSession？六、底层相关1.iOS程序的加载过程是什么？ 执行 main 函数。 执行 UIApplicationMain 函数。 创建 UIApplication 对象（是单例的）。 创建 UIApplication 的代理，并且设置 application 的代理。 开启 主RunLoop。 加载完毕后调用 - application: didFinishLaunchingWithOptions:。 2.&lt;UIApplicationDelegate&gt; 中有哪些方法？有什么作用？ - application: didFinishLaunchingWithOptions: 应用被加载完毕后被调用 - applicationWillResignActive: 当应用即将变为不活动状态时调用，比如电话进入、退出应用程序或开始进入后台状态。 - applicationDidEnterBackground: 当应用进入后台状态后调用。在后台状态中应用工作，但是不派发新的事件到响应器。 - applicationWillEnterForeground 应用将要回到前台时调用。 - applicationDidBecomeActive: 应用已经变为活动状态时调用。 - applicationWillTerminate: 应用即将结束时调用。 - applicationDidReceiveMemoryWarning: 收到内存警告时调用。 3.+load 方法和 +initialize 方法异同 相同： 都在实例化对象==之前==调用。 内部都使用了锁，应该避免线程阻塞在方法中。 +load 方法 +load 方法在这个==文件被程序加载时==调用，程序启动时会调用所有类的+load 方法。与类的使用与否无关。 +load 方法在main函数之==前==调用。 先调用父类的 +load 方法，再调用子类的 +load 方法。自动完成。 如果一个子类没有实现 +load 方法，那么也就不会调用父类的+load 方法。 使用场景：在+load方法中实现 Method swizzle。 +initialize 方法 当第一次给一个类发送消息时，它的+initiallze方法会被调用。只会调用一次。 如果一个类一直没有被使用，它的+initialize方法不会被调用。 在main函数之==后==被调用。 先调用父类的+initialize方法，再调用子类的+initialize方法。 如果子类没有实现+initialize方法没有被实现，父类的+initialize方法也会被调用。 使用场景：初始化全局变量或静态变量。 4.消息转发，_objc_msgForward函数是做什么的？直接调用会发生什么？ _objc_msgForward是 IMP 类型(一个函数指针)，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 IMP: 指向方法实现开头的指针。 我们可以这样创建一个_objc_msgForward对象： 1IMP msgForwardIMP &#x3D; _objc_msgForward; objc_msgSend在“消息传递”中的作用： 在“消息传递”过程中，objc_msgSend的动作比较清晰：首先在 Class 中的缓存查找 IMP （没缓存则初始化缓存），如果没找到，则向父类的 Class 查找。如果一直查找到根类仍旧没有实现，则用_objc_msgForward函数指针代替 IMP 。最后，执行这个 IMP 。 消息转发过程： 调用resolveInstanceMethod:方法 (或 resolveClassMethod:)。允许用户在此时为该 Class 动态添加实现。如果有实现了，则调用并返回YES，那么重新开始objc_msgSend流程。这一次对象会响应这个选择器，一般是因为它已经调用过class_addMethod。如果仍没实现，继续下面的动作。 调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接把消息转发给它，返回非 nil 对象。否则返回 nil ，继续下面的动作。注意，这里不要返回 self ，否则会形成死循环。 调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。如果能获取，则返回非nil：创建一个 NSlnvocation 并传给forwardInvocation:。 调用forwardInvocation:方法，将第3步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni。 调用doesNotRecognizeSelector: ，默认的实现是抛出异常。如果第3步没能获得一个方法签名，执行该步骤。 最常见的实现消息转发：就是重写方法3和4，吞掉一个消息或者代理给其他对象都是没问题的。 _objc_msgForward在进行消息转发的过程中会涉及以下这几个方法： resolveInstanceMethod:方法 (或 resolveClassMethod:)。 forwardingTargetForSelector:方法 methodSignatureForSelector:方法 forwardInvocation:方法 doesNotRecognizeSelector: 方法 直接调用_objc_msgForward是非常危险的事，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事。 一旦调用_objc_msgForward，将跳过查找 IMP 的过程，直接触发“消息转发”， 如果调用了_objc_msgForward，即使这个对象确实已经实现了这个方法，你也会告诉objc_msgSend： “我没有在这个对象里找到这个方法的实现” 有哪些场景需要直接调用_objc_msgForward？最常见的场景是：你想获取某方法所对应的NSInvocation对象。 5.__block为什么能够 block 在内部修改 blcok 外部变量？ 我们都知道：Block不允许修改外部变量的值，这里所说的==外部变量的值，指的是栈中指针的内存地址。==__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。 block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址 变量在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。 网络1.访问域名和访问IP地址的区别？ IP地址是服务器的物理地址，一台服务器可能对应多个网站，访问IP地址可能不知道要访问哪个。 一个域名可能对应多个IP地址，通过域名访问自动选择速度最快的建立连接。 2.访问www.xxx.com的过程？ 首先找本机的HOSTS文件，映射为IP地址或客户端向 DNS 服务器请求解析该 URL 中域名对应的 IP 地址。(域名解析) 根据 IP 地址和端口，客户端同服务器建立连接。(建立连接) 客户端向服务器发送请求。(发送请求) 该请求报文作为 TCP 三次握手第三个报文的数据发送给服务器。 服务器对请求做出响应，并把对应的数据发送给客户端。(作出相应) 释放 TCP 连接。(释放连接) 客户端对响应数据进行解析、处理。(解析数据) 3.GET和POST请求的区别？POST一定安全么？ 请求形式 GET 请求：请求的数据附在 URL 之后（数据在请求头中）。以？分割URL和传输数据，多个参数用&amp;相连。 POST 请求：请求的数据封装在请求体中。 安全性 GET 请求：请求的数据在地址栏中显示。 POST 请求：请求的数据虽然在请求体中，但也不安全，需要加密。 传输数据的大小 GET 请求：传输数据受URL长度限制，特定浏览器和服务器对URL的长度有限制。 POST 请求：理论上不受限制，实际服务器会对 POST 请求提交的数据大小进行限制。 获取变量值的方式 GET 请求：Request QueryString POST 请求：Request Form 4.HTTPS安全协议请求过程(HTTPS握手)是什么？ 涉及密钥： 对称加密密钥A 。 用于加密密钥A的非对称密钥B。公钥发送给客户端，私钥服务器持有。 用于加密密钥B公钥的CA证书密钥C。公钥保存在浏览器或系统中，私钥服务器持有。 请求过程(HTTPS握手)： 客户端发送HTTPS请求，请求对称加密公钥B。 服务器响应客户端请求，发送CA数字证书。 证书中包括：密钥B的公钥，域名，服务器信息，数字签名，数字摘要算法等信息。 客户端验证CA数字证书的正确性。 验证域名的正确性，比较CA证书中的域名和请求域名，可以验证证书是否是服务器发送的。 验证CA证书中数字签名，可以验证CA证书是否被第三方篡改。 客户端用CA证书的公钥对密文解密，得到密钥B的公钥。 客户端生成密钥A，用密钥B的公钥进行加密，发送给服务器。 服务器用密钥B的私钥对密文进行解密，得到密钥A。 安全连接建立完成，双方用密钥A对信息进行对称加密传输。 HTTPS加密在传输层 HTTPS报文在包装成TCP报文的时候完成加密过程，报文的header和body都会被加密。 5.HTTPS作用？ 内容加密：建立一个信息安全通道，来保证数据传输的安全。 身份认证：认证用户或服务器，确保数据发送到正确的客户或服务器。 数据完整性：防止内容被第三方冒充或篡改。（原因：数字摘要） 6.HTTP和HTTPS区别？ HTTPS需要到CA申请证书或自制证书。 HTTP直接进行明文传输。 HTTPS先经过具有安全性的SSL/TSL（表示层）加密，再传输密文。 HTTP端口：80。 HTTPS端口：443。 7.数字证书作用？ 确定得到公钥的正确性 确定目标主机的正确性 ​ 数字证书包括： 用户个人信息、公钥信息、颁发机构名称、证书本身的数字签名、证书数字签名用的HASH算法。 8.数字签名 数字签名 = 非对称加密 + 数字摘要 数字签名验证数据完整性过程： 将摘要信息用发送者私钥加密后，与原文一起传送给接受者。(摘要+原文) 接受者用发送者的公钥将被加密的摘要解密。(解密) 接受者用与发送者相同的HASH算法对接收到的明文产生一个摘要信息。(产生摘要) 将产生的摘要与解密得到的摘要进行对比，如果相同，则数据没有被修改。(比较摘要) 9.请求报文包括哪些？请求体和请求报文的关系？请求报文包括：请求行、请求头、空行、请求体。 请求报文包括请求体。 响应报文包括：状态行、响应头、空行，响应体。 10.UDP和TCP的区别？ TCP：面向连接，三次握手最低限度保证连接可靠性 UDP：无连接，传送数据前无需建立连接，数据到达后也无需确认。（发送端不知道数据是否到达接收端，也不知道数据是否被正确接受） TCP：可靠交付。 UDP：不可靠交付。 TCP：报文头部长，传输开销大 UDP：报文头部短，传输开销小，时延较短，实用性更好。 11.TCP三次握手和四次挥手过程 三次握手 四次挥手 C语言1.strstr函数是什么？2.free() 函数做了什么？3.strcpy和strnpy函数的区别？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"iOS面试","slug":"iOS面试","permalink":"http://fangliquan.github.io/tags/iOS%E9%9D%A2%E8%AF%95/"}]},{"title":"swift3.0_协议(Protocal)和扩展(Extension)","slug":"swift3-0-Protocol-And-Eextension","date":"2017-03-20T10:13:44.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-20/swift3-0-Protocol-And-Eextension/","link":"","permalink":"http://fangliquan.github.io/2017-03-20/swift3-0-Protocol-And-Eextension/","excerpt":"协议(Protocal使用protocol 来声明一个协议。 ExampleProtocal&#123; var simpleDesp:String&#123;get&#125; mutating func adjust()&#125;","text":"协议(Protocal使用protocol 来声明一个协议。 ExampleProtocal&#123; var simpleDesp:String&#123;get&#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议。class SimpleClass: ExampleProtocal&#123; var simpleDesp: String &#x3D; &quot;A simple class&quot; var anotherProperty:Int &#x3D; 45621 func adjust() &#123; simpleDesp +&#x3D; &quot; NO 100% adjusted&quot; &#125;&#125; 注意声明SimpleStructure 时候mutating 关键字用来标记一个会修改结构体的方法。SimpleClass 的声明不需要标记任何方法，因为类中的方法通常可以修改类属性（类的性质）。使用extension来为现有的类型添加功能，比如新的方法和计算属性。你可以使用扩展在别处修改定义，甚至是从外部库或者框架引入的一个类型，使得这个类型遵循某个协议。var simple &#x3D; SimpleClass()simple.adjust()let aDesp &#x3D; simple.simpleDespstruct SimpleStructure:ExampleProtocal&#123; var simpleDesp: String &#x3D; &quot;A simple structure&quot; mutating func adjust() &#123; simpleDesp +&#x3D; &quot;(adjusted)&quot; &#125;&#125;var b &#x3D; SimpleStructure()b.adjust()let bDesp &#x3D; b.simpleDespextension Int:ExampleProtocal &#123; var simpleDesp :String &#123; return &quot;The number\\(self)&quot; &#125; mutating func adjust() &#123; self +&#x3D; 42 &#125;&#125;print(7.simpleDesp) 你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象􀔀合。当你处理类型是协议的值时，协议外定义的方法不可用。let protocolValue : ExampleProtocal &#x3D; simpleprint(protocolValue.simpleDesp)&#x2F;&#x2F;print(protocolValue.anotherProperty) &#x2F;&#x2F; 去掉注释可以看到错误 即使protocolValue 变量运行时的类型是simpleClass ，编译器会把它的类型当做ExampleProtocol 。这表示你不能调用类在它实现的协议之外实现的方法或者属性。","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_类和对象","slug":"swift3-0-Class-And-Object-study","date":"2017-03-19T11:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-Class-And-Object-study/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-Class-And-Object-study/","excerpt":"类和对象和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。","text":"类和对象和类名来创建一个类。类中属性的声明和常量、变量声明一样，唯一的区别就是它们的上下文是类。同样，方法和函数声明也一样。 class Shape&#123; var numberOfSize &#x3D; 0 func simpleDescription() -&gt; String &#123; return&quot;A shape with \\(numberOfSize) sides.&quot; &#125; func simpleDescription(str:String) -&gt; String &#123; return&quot;A shape with \\(numberOfSize) sides.&quot; &#125;&#125; 要创建一个类的实例，在类名后面加上括号。使用点语法来访问实例的属性和方法。var shape &#x3D; Shape()shape.numberOfSize &#x3D; 7var shapeDescription &#x3D; shape.simpleDescription()class NameShape&#123; var numberOfSides:Int &#x3D; 0 var name:String init(name:String) &#123; self.name &#x3D; name; &#125; func simpleDescription() -&gt; String &#123; return&quot;A shape with \\(numberOfSides)&quot; &#125;&#125; 注意self 被用来区别实例变量。当你创建实例的时候，像传入函数参数一样给类传入构造器的参数。每个属性都需要赋值——无论是通过声明（就像numberOfSides ）还是通过构造器（就像name ）。 如果你需要在删除对象之前进行一些清理工作，使用deinit 创建一个析构函数。子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。创建类的时候并不需要一个标准的根类，所以你可以忽略父类。子类如果要重写父类的方法的话，需要用override 标记——如果没有添加override 就重写父类方法的话编译器会报错。编译器同样会检测override 标记的方法是否确实在父类中class Square:NameShape&#123; var sideLength:Double &#x3D; 0.0; init(sideLength:Double,name:String) &#123; super.init(name: name) self.sideLength &#x3D; sideLength numberOfSides &#x3D; 4 &#125; func area() -&gt; Double &#123; return sideLength*sideLength &#125; override func simpleDescription() -&gt; String &#123; return &quot;A square with sides of length \\(sideLength)&quot; &#125;&#125;let test &#x3D; Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription() 除了储存简单的属性之外，属性可以有 getter 和 setter 。class EquilateralTriangle:NameShape&#123; var sideLength: Double &#x3D; 0.0 init(sideLength:Double,name:String) &#123; super.init(name: name) self.sideLength &#x3D; sideLength; numberOfSides &#x3D; 3 &#125; var perimeter :Double&#123; get&#123; return 3.0 * sideLength &#125; set&#123; sideLength &#x3D; newValue&#x2F;3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return &quot;an equilateral triagle with sides of length \\(sideLength).&quot; &#125;&#125;var triangle &#x3D; EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)print(triangle.perimeter)triangle.perimeter &#x3D; 9.9print(triangle.sideLength) 在perimeter 的 setter 中，新值的名字是newValue 。你可以在set 之后显式的设置一个名字。注意EquilateralTriangle 类的构造器执行了三步： 设置子类声明的属性值 调用父类的构造器 改变父类定义的属性值。其他的工作比如调用方法、getters 和 setters 也可以在这个阶段完成。如果你不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用willSet 和didSet 。class TriangleAndSquare &#123; var triangle: EquilateralTriangle &#123; willSet &#123; square.sideLength &#x3D; newValue.sideLength &#125; &#125; var square:Square&#123; willSet&#123; triangle.sideLength &#x3D; newValue.sideLength &#125; &#125; init(size:Double,name:String) &#123; square &#x3D; Square(sideLength: size, name: name) triangle &#x3D; EquilateralTriangle(sideLength: size, name: name) &#125;&#125;var triangleAndSquare &#x3D; TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square &#x3D; Square(sideLength: 50, name: &quot;larger square&quot;)print(triangleAndSquare.triangle.sideLength) 处理变量的可选值时，你可以在操作（比如方法、属性和子脚本）之前加? 。如果? 之前的值是nil ， ? 后面的东西都会被忽略，并且整个表达式返回nil 。否则， ? 之后的东西都会被运行。在这两种情况下，整个表达式的值也是一个可选值。let optionalSquare:Square? &#x3D; Square(sideLength: 2.5, name: &quot;optional Square&quot;)let sideLength &#x3D; optionalSquare?.sideLength","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_枚举(Enum)和结构体(struct)","slug":"swift3-0-Struct-and-Enum","date":"2017-03-19T09:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-Struct-and-Enum/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-Struct-and-Enum/","excerpt":"枚举和结构体使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。","text":"枚举和结构体使用enum 来创建一个枚举。就像类和其他所有命名类型一样，枚举可以包含方法。 enum Rank: Int&#123; case Ace &#x3D; 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King func simpleDescription() -&gt; String &#123; switch self &#123; case .Ace: return &quot;ace&quot; case.Jack: return &quot;jack&quot; case.Queen: return &quot;queen&quot; case.King: return &quot;king&quot; default: return String(self.rawValue) &#125; &#125;&#125;let ace &#x3D; Rank.Acelet aceRawValue &#x3D; ace.rawValuelet kingRawValue &#x3D; Rank.King.rawValuelet queenString &#x3D; Rank.simpleDescription(.Jack)print(queenString()) 默认情况下，Swift 按照从 0 开始每次加 1 的方式为原始值进行赋值，不过你可以通过显式赋值进行改变。在上面的例子中， Ace 被显式赋值为 1，并且剩下的原始值会按照顺序赋值。你也可以使用字符串或者浮点数作为 枚举的原始值。使用rawValue 属性来访问一个枚举成员的原始值。使用init?(rawValue:) 初始化构造器在原始值和枚举值之间进行转换。if let convertedRank &#x3D; Rank(rawValue: 3)&#123; let threeDescription &#x3D; convertedRank.simpleDescription()&#125; 枚举的成员值是实际值，并不是原始值的另一种表达方法。实际上，如果没有比较有意义的原始值，你就不需要提供原始值。enum Suit &#123; case Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return &quot;spades&quot; case .Hearts: return &quot;hearts&quot; case .Diamonds: return &quot;diamonds&quot; case .Clubs: return &quot;clubs&quot; &#125; &#125; func color() -&gt; String &#123; switch self &#123; case .Spades: return &quot;balck&quot; case .Hearts: return &quot;red&quot; case .Diamonds: return &quot;red&quot; case .Clubs: return &quot;black&quot; &#125; &#125;&#125;let hearts &#x3D; Suit.Heartslet heartsDescription &#x3D; hearts.simpleDescription()let heartsColor &#x3D; hearts.color()let shapeColor &#x3D; Suit.Clubs.color() 注意，有两种方式可以引用Hearts 成员：给hearts 常量赋值时，枚举成员Suit.Hearts 需要用全名来引用，因为常量没有显式指定类型。在switch 里，枚举成员使用缩写.Hearts 来引用，因为self 的值已经知道是一个suit 。已知变量类型的情况下你可以使用缩写。 一个枚举成员的实例可以有实例值。相同枚举成员的实例可以有不同的值。创建实例的时候传入值即可。实例值和原始值是不同的：枚举成员的原始值对于所有实例都是相同的，而且你是在定义枚举的时候设置原始值。 例如，考虑从服务器获取日出和日落的时间。服务器会返回正常结果或者错误信息。enum ServerResponse&#123; case Reasult(String,String) case Failure(String)&#125;let success &#x3D; ServerResponse.Reasult(&quot;6:00pm&quot;, &quot;8:09pm&quot;)let failure &#x3D; ServerResponse.Failure(&quot;Out of cheese&quot;)switch success &#123;case let .Reasult(sunrise,sunset): let serRepsonse &#x3D; &quot;Sunrise is at\\(sunrise) and sunset is at\\(sunset)&quot;case let .Failure(message): print(&quot;Failure....\\(message)&quot;)&#125; 注意日升和日落时间是如何从ServerResponse 中提取到并与switch 的case 相匹配的。 使用struct 来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们之间最大的一个区别就是结构体是传值，类是传引用。struct Card&#123; var rank :Rank var suit :Suit func sampleDesp() -&gt; String&#123; return &quot;The \\(rank.simpleDescription()) of \\(suit.simpleDescription())&quot; &#125;&#125;let threeOfSpades &#x3D; Card(rank: .Three, suit: .Spades)let threeOfSpadesDesp &#x3D; threeOfSpades.sampleDesp()let threeOfRank &#x3D; threeOfSpades.rank.hashValue","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"swift3.0_函数和闭包","slug":"swift3-0-func-study","date":"2017-03-19T09:15:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2017-03-19/swift3-0-func-study/","link":"","permalink":"http://fangliquan.github.io/2017-03-19/swift3-0-func-study/","excerpt":"函数和闭包使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型func great( person:String,day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125;","text":"函数和闭包使用func 来声明一个函数，使用名字和参数来调用函数。使用-&gt; 来指定函数返回值的类型func great( person:String,day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125; 默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用_表示不使用参数标签。func greaton(_ person:String,on day :String) -&gt;String&#123; return &quot;Hello \\(person),today is \\(day)&quot;&#125;great(person: &quot;&quot;, day: &quot;&quot;)greaton(&quot;John&quot;, on: &quot;Sunday&quot;) 使用元组来让一个函数返回多个值。该元组的元素可以用名称或数字来表示。func calculateStatistics(scores:[Int]) -&gt;(min:Int,max:Int,sum:Int)&#123; var minInt &#x3D; scores[0] var maxInt &#x3D; scores[0] var sum &#x3D; 0 for score in scores &#123; if score&gt;maxInt &#123; maxInt &#x3D; score &#125;else if score&lt;minInt&#123; minInt &#x3D; score &#125; sum+&#x3D;score &#125; return(minInt,maxInt,sum)&#125;let statistics &#x3D; calculateStatistics(scores: [3,4,567,89,99])print(statistics.sum)print(statistics.max)print(statistics.min)print(statistics.2) 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：func sumOf(numbers:Int...)-&gt;Int&#123; var sum &#x3D; 0; for number in numbers &#123; sum+&#x3D;number &#125; return sum&#125;sumOf(numbers: 34,56,78)sumOf() 函数可以嵌套。被嵌套的函数可以访问外侧函数的变量，你可以使用嵌套函数来重构一个太长或者太复杂的函数。func returnFifteen()-&gt;Int&#123; var y &#x3D; 10 func add()&#123; y+&#x3D;10 &#125; add(); return y;&#125;returnFifteen() 函数是第一等类型，这意味着函数可以作为另一个函数的返回值。func makeIncrementer()-&gt;((Int) -&gt;Int)&#123; func addOne(number:Int)-&gt;Int&#123; return 1+number &#125; return addOne&#125;var increment &#x3D; makeIncrementer()increment(10) 函数也可以当做参数传入另一个函数func hasAnyMatches(list:[Int],condition:(Int) -&gt;Bool)-&gt;Bool&#123; for item in list &#123; if condition(item) &#123; return true; &#125; &#125; return false;&#125;func lessThanTen(number:Int)-&gt;Bool&#123; return number&lt;10&#125;var numbers &#x3D; [20,19,6,12]hasAnyMatches(list: numbers, condition: lessThanTen) 函数实际上是一种特殊的闭包:它是一段能之后被调取的代码。闭包中的代码能访问闭包所建作用域中能得到的变量和函数，即使闭包是在一个不同的作用域被执行的 - 你已经在嵌套函数例子中所看到。你可以使用{} 来创建一个匿名闭包。使用in 将参数和返回值类型声明与闭包函数体进行分离。numbers.map &#123; (number :Int) -&gt; Int in let result &#x3D; 3*number; return result;&#125;print(numbers) 有很多种创建更简洁的闭包的方法。如果一个闭包的类型已知，比如作为一个回调函数，你可以忽略参数的类型和返回值。单个语句闭包会把它语句的值当做结果返回。let mappedNumbers &#x3D; numbers.map(&#123;number in 3*number&#125;)print(mappedNumbers) 你可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面。当一个闭包是传给函数的唯一参数，你可以完全忽略括号。let sortedNumbers &#x3D; numbers.sort&#123;$0&gt;$1&#125;print(sortedNumbers)","categories":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"}],"tags":[{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"}]},{"title":"iOS 解决蓝牙音箱输出App播放的音频问题","slug":"IPhone-Bluetooth-speaker-output-audio","date":"2016-09-16T03:31:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-09-16/IPhone-Bluetooth-speaker-output-audio/","link":"","permalink":"http://fangliquan.github.io/2016-09-16/IPhone-Bluetooth-speaker-output-audio/","excerpt":"App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。","text":"App中有音频播放的功能，在App连接蓝牙设备时音频没有从蓝颜音箱输出。再找一些资料时总结一些技术点。添加对AudioSession支持蓝牙的设置 ，处理设备输出路径通知的监控，处理外设的操作事件。 AVAudioSession的设置 如果app需要支持蓝牙外设输出及耳机 的控制需要添加 对OverrideAudioRoute OverrideCategoryEnableBluetoothInput的支持 同时还要设置AVAudioSession的Category为AVAudioSessionCategoryPlayback. AVAudioSession * session = [AVAudioSession sharedInstance];[session setCategory:AVAudioSessionCategoryPlayback error:nil];[session setActive:YES error:nil];UInt32 audioRouteOverride = kAudioSessionOverrideAudioRoute_Speaker;AudioSessionSetProperty (kAudioSessionProperty_OverrideAudioRoute, sizeof (audioRouteOverride), &amp;audioRouteOverride);//kAudioSessionProperty_OverrideCategoryDefaultToSpeakerUInt32 allowBluetoothInput = 1;AudioSessionSetProperty ( kAudioSessionProperty_OverrideCategoryEnableBluetoothInput, sizeof (allowBluetoothInput), &amp;allowBluetoothInput );//[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;];[[UIApplication sharedApplication] beginReceivingRemoteControlEvents];[[UIApplication sharedApplication] becomeFirstResponder]; 处理输出路径的变换的通知 AVAudioSessionRouteChangeNotification 的监听 注册通知后 要对监听做处理 AVAudioSession *audioSession = [AVAudioSession sharedInstance];NSInteger changeReason = [[notification.userInfo objectForKey:AVAudioSessionRouteChangeReasonKey] integerValue];AVAudioSessionRouteDescription *oldRoute = [notification.userInfo objectForKey:AVAudioSessionRouteChangePreviousRouteKey];NSString *oldOutput = [[oldRoute.outputs objectAtIndex:0] portType];AVAudioSessionRouteDescription *newRoute = [audioSession currentRoute];NSString *newOutput = [[newRoute.outputs objectAtIndex:0] portType]; 具体实现请看代码 - (void)currentRouteChanged:(NSNotification *)notification&#123; AVAudioSession *audioSession = [AVAudioSession sharedInstance]; NSInteger changeReason = [[notification.userInfo objectForKey:AVAudioSessionRouteChangeReasonKey] integerValue]; AVAudioSessionRouteDescription *oldRoute = [notification.userInfo objectForKey:AVAudioSessionRouteChangePreviousRouteKey]; NSString *oldOutput = [[oldRoute.outputs objectAtIndex:0] portType]; AVAudioSessionRouteDescription *newRoute = [audioSession currentRoute]; NSString *newOutput = [[newRoute.outputs objectAtIndex:0] portType]; NSLogDebug(@&quot;changeReason - ------------------ %d&quot;,(int)changeReason); switch (changeReason) &#123; case AVAudioSessionRouteChangeReasonOldDeviceUnavailable: &#123; if ([oldOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = NO; // Special Scenario: // when headphones are plugged in before the call and plugged out during the call // route will change to &#123;input: MicrophoneBuiltIn, output: Receiver&#125; // manually refresh session and support all devices again.// [audioSession setActive:NO error:nil];// [audioSession setCategory:AVAudioSessionCategoryPlayAndRecord withOptions:AVAudioSessionCategoryOptionAllowBluetooth error:nil];// [audioSession setMode:AVAudioSessionModeVoiceChat error:nil];// [audioSession setActive:YES error:nil]; dispatch_async(dispatch_get_main_queue(), ^&#123; [WawaAudioBookListView pauseCurrentAudio]; &#125;); &#125; else if ([self isBluetoothDevice:oldOutput]) &#123; BOOL showBluetooth = NO; // Additional checking for iOS7 devices (more accurate) // when multiple blutooth devices connected, one is no longer available does not mean no bluetooth available if ([audioSession respondsToSelector:@selector(availableInputs)]) &#123; NSArray *inputs = [audioSession availableInputs]; for (AVAudioSessionPortDescription *input in inputs)&#123; if ([self isBluetoothDevice:[input portType]])&#123; showBluetooth = YES; break; &#125; &#125; &#125; if (!showBluetooth) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; &#125; break; case AVAudioSessionRouteChangeReasonNewDeviceAvailable: &#123; if ([self isBluetoothDevice:newOutput]) &#123; self.bluetoothDeviceAvailable = YES; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = YES; &#125; &#125; break; case AVAudioSessionRouteChangeReasonCategoryChange: &#123; if ([self isBluetoothDevice:newOutput]) &#123; self.bluetoothDeviceAvailable = YES; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortHeadphones]) &#123; self.headsetDeviceAvailable = YES; &#125; NSUserDefaults *defaults =[NSUserDefaults standardUserDefaults]; [defaults setObject:@&quot;YES&quot; forKey:@&quot;WawaAVAudioSessionRouteChangeReasonCategoryChange&quot;]; &#125; break; case AVAudioSessionRouteChangeReasonOverride: &#123; if ([self isBluetoothDevice:oldOutput]) &#123; if ([audioSession respondsToSelector:@selector(availableInputs)]) &#123; BOOL showBluetooth = NO; NSArray *inputs = [audioSession availableInputs]; for (AVAudioSessionPortDescription *input in inputs)&#123; if ([self isBluetoothDevice:[input portType]])&#123; showBluetooth = YES; break; &#125; &#125; if (!showBluetooth) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; else if ([newOutput isEqualToString:AVAudioSessionPortBuiltInReceiver]) &#123; self.bluetoothDeviceAvailable = NO; &#125; &#125; &#125; break; default: break; &#125;&#125;- (BOOL)isBluetoothDevice:(NSString*)portType &#123; return ([portType isEqualToString:AVAudioSessionPortBluetoothA2DP] || [portType isEqualToString:AVAudioSessionPortBluetoothHFP]);&#125;- (void)start&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(currentRouteChanged:) name:AVAudioSessionRouteChangeNotification object:nil];&#125; 处理RemoteControl 音频蓝牙音箱的外设可以进行下一首 等操作 所以对RemoteControl做处理 来控制音频的播放 - (void)remoteControlReceivedWithEvent:(UIEvent *)event&#123; switch (event.subtype) &#123; case UIEventSubtypeRemoteControlPlay: &#123; [self postNotification:kRemoteControlPlayTapped]; &#125; break; case UIEventSubtypeRemoteControlPause: [self postNotification:kRemoteControlPauseTapped]; break; case UIEventSubtypeRemoteControlNextTrack: [self postNotification:kRemoteControlNextTapped]; break; case UIEventSubtypeRemoteControlPreviousTrack: [self postNotification:kRemoteControlPreviousTapped]; break; default: break; &#125;&#125;- (void)postNotification:(const NSString *)notificationName&#123; [[NSNotificationCenter defaultCenter] postNotificationName:(NSString *)notificationName object:nil];&#125;- (void)observeRemoteControl:(id)observer selector:(SEL)selector&#123; NSNotificationCenter * center = [NSNotificationCenter defaultCenter]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlNextTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPauseTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPlayTapped object:nil]; [center addObserver:observer selector:selector name:(NSString *)kRemoteControlPreviousTapped object:nil];&#125; 处理事件 - (void)onRemoteControlNotification:(NSNotification *)notification&#123; NSLog(@&quot;changeReason - ------------------ kRemoteControlPlayTapped&quot;); //[[AudioSessionManager sharedInstance]changeMode:@&quot;kAudioSessionManagerMode_Playback&quot;]; if ([notification.name isEqualToString:kRemoteControlPlayTapped]) &#123; if (self.audioSteamSate == kFsAudioStreamRetrievingURL || self.audioSteamSate == kFsAudioStreamStopped) &#123; // 当前选中的 audio 处于准备中则播放此 url self.needResume = YES; [self playFromUrl:self.currentPlayAduio]; &#125; else &#123;// 否则暂停或者播放 if (self.audioSteamSate ==kFsAudioStreamPlaying) &#123; self.needResume = YES; &#125; //只在当前播放状态为播放时处理蓝牙设备的接入 [self.audioStream pause]; &#125; &#125; else if ([notification.name isEqualToString:kRemoteControlPauseTapped]) &#123; [self.audioStream pause]; &#125; else if ([notification.name isEqualToString:kRemoteControlNextTapped]) &#123; [self next]; &#125; else if ([notification.name isEqualToString:kRemoteControlPreviousTapped]) &#123; [self previous]; &#125;&#125;","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"AVAudioSession","slug":"AVAudioSession","permalink":"http://fangliquan.github.io/tags/AVAudioSession/"},{"name":"AudioSessionProperty","slug":"AudioSessionProperty","permalink":"http://fangliquan.github.io/tags/AudioSessionProperty/"}]},{"title":"iOS 解决支付宝SDK在没有安装支付宝时不能启动网页支付","slug":"To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment","date":"2016-08-28T03:31:13.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/","link":"","permalink":"http://fangliquan.github.io/2016-08-28/To-solve-the-Alipay-SDK-not-installed-Alipay-cannot-start-payment/","excerpt":"在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。","text":"在做支付宝支付功能时，在没有安装支付宝的时候不能启动网页支付。我找到了一种解决方法。 配置plist 文件配置 LSApplicationQueriesSchemes &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt; &lt;array&gt; &lt;string&gt;alipayauth&lt;/string&gt; &lt;string&gt;alipay&lt;/string&gt; &lt;string&gt;alipayshare&lt;/string&gt; &lt;string&gt;safepay&lt;/string&gt; &lt;string&gt;aliminipayauth&lt;/string&gt; &lt;string&gt;cydia&lt;/string&gt; &lt;/array&gt;配置NSAppTransportSecurity ，添加NSExceptionDomains支持 &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;alipay.com&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSIncludesSubdomains&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSTemporaryExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSTemporaryExceptionMinimumTLSVersion&lt;/key&gt; &lt;string&gt;TLSv1.1&lt;/string&gt; &lt;key&gt;NSExceptionRequiresForwardSecrecy&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; 在AppDelegate中添加以下代码，不知道是否起作用，我设置断点没有进入该代码段😄- (BOOL)connection:(NSURLConnection *)connection canAuthenticateAgainstProtectionSpace:(NSURLProtectionSpace *)protectionSpac&#123; return YES;&#125;- (void)connection:(NSURLConnection *)connection didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge &#123; NSArray *trustedHosts = [NSArray arrayWithObjects:@&quot;alipay&quot;,nil]; if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust])&#123; if ([trustedHosts containsObject:challenge.protectionSpace.host]) &#123; [challenge.sender useCredential:[NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust] forAuthenticationChallenge:challenge]; &#125; &#125; [challenge.sender continueWithoutCredentialForAuthenticationChallenge:challenge];&#125; 我们的项目是通过storyboard启动的，所以需要将第一个Window 的hidden设为NO，我在这里判断了系统是否安装了支付宝。因为将第一个Window设为显示后会出现我们已经因此的页面，会重新走一遍流程。所以我在这个Window的RootViewControll的View添加了一个白色的View来覆盖页面。在支付的回调里面，再讲页面的hidden设为YES并将白色View 移除掉。__block UIWindow* window = nil;NSURL * app_Alipay_URL = [NSURL URLWithString:@&quot;alipay:&quot;];UIView *bgView = [[UIView alloc]initWithFrame:CGRectMake(0, 0, Main_Screen_Width, Main_Screen_Height)];bgView.backgroundColor = [UIColor whiteColor];if (![[UIApplication sharedApplication] canOpenURL:app_Alipay_URL]) &#123; //如果没有安装支付宝 NSArray *array = [[UIApplication sharedApplication] windows]; window = [array firstObject]; if (window) &#123; [window.rootViewController.view addSubview:bgView]; [window setHidden:NO]; &#125;&#125;[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic) &#123; if (window) &#123; [window setHidden:YES]; [bgView removeFromSuperview]; window = nil; &#125; if (_callBack) &#123; _callBack([self requestFromResultDic:resultDic]); &#125;&#125;];","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"支付宝SDK","slug":"支付宝SDK","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9DSDK/"},{"name":"支付宝","slug":"支付宝","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"}]},{"title":"iOS 多线程同时访问数组出现was mutated while being enumerated","slug":"was_mutated_while_being_enumerated","date":"2016-08-13T02:41:15.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-08-13/was_mutated_while_being_enumerated/","link":"","permalink":"http://fangliquan.github.io/2016-08-13/was_mutated_while_being_enumerated/","excerpt":"错误：iOS 多线程同时访问数组出现was mutated while being enumerated__NSArrayM: 0x96be3e0 was mutated while being enumerated.意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突","text":"错误：iOS 多线程同时访问数组出现was mutated while being enumerated__NSArrayM: 0x96be3e0 was mutated while being enumerated.意思就是数组在被一个线程访问的时候，另一个数组也对它进行访问。原因是这样的，我的app中，有个音乐播放数据管理单例，里面有一个数组来保存当前播放的目录，用一个方法检测是否是当前播放的歌曲，但是新的歌曲不断的加入在主线程中加入）。两个线程在不特定的时刻会冲突 + (NSArray *)getAudioPlayArray:(NSArray *)array playingId:(long long)playingId&#123; NSArray * targetArray = nil; NSMutableArray * tempArray = [NSMutableArray array]; for (NSObject * model in array) &#123; AudioPlayModel * playModel = [[AudioPlayModel alloc] init]; if ([model isKindOfClass:[GenBookListDTO class]]) &#123; GenBookListDTO * picBook = (GenBookListDTO *)model; playModel.playId = picBook.bookId; playModel.playName = picBook.name; playModel.playCover = picBook.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[GenSongListDTO class]]) &#123; GenSongListDTO * songRes = (GenSongListDTO *)model; playModel.playId = songRes.songId; playModel.playName = songRes.name; playModel.playCover = songRes.audioCover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_Song; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[AudioPlayModel class]]) &#123; AudioPlayModel * audioModel = (AudioPlayModel *)model; playModel.playId = audioModel.playId; playModel.playName = audioModel.playName; playModel.playCover = audioModel.playCover; playModel.publisher = @&quot;&quot;; playModel.audioType = audioModel.audioType; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[PictureBook class]]) &#123; PictureBook * picBookModel = (PictureBook *)model; playModel.playId = (long long)picBookModel.bookId; playModel.playName = picBookModel.title; playModel.playCover = picBookModel.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; else if ([model isKindOfClass:[GenBookBorrowedDTO class]]) &#123; GenBookBorrowedDTO * borrowBookModel = (GenBookBorrowedDTO *)model; playModel.playId = borrowBookModel.bookId; playModel.playName = borrowBookModel.name; playModel.playCover = borrowBookModel.cover; playModel.publisher = @&quot;&quot;; playModel.audioType = PlayAudioType_PictureBook; if (playModel.playId == playingId) &#123; playModel.isPlaying = YES; &#125; else &#123; playModel.isPlaying = NO; &#125; &#125; [tempArray addObject:playModel]; &#125; if (tempArray.count) &#123; [AudioPlayModel saveAudioPlayList:tempArray]; &#125; targetArray = tempArray; return targetArray;&#125; 解决的方法：在次线程中复制一个数组的副本，用副本进行遍历。 NSArray* array=[NSArray arrayWithArray:b];","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://fangliquan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"解决Xcode开发组件失效的命令","slug":"solve-Xcode-development-component-failure-of-the-command","date":"2016-07-30T15:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-30/solve-Xcode-development-component-failure-of-the-command/","link":"","permalink":"http://fangliquan.github.io/2016-07-30/solve-Xcode-development-component-failure-of-the-command/","excerpt":"","text":"find ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID","categories":[{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/categories/xcode/"}],"tags":[{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/tags/xcode/"}]},{"title":"iOS开发--多线程 NSThread GCD 学习","slug":"iOS-multithreading-NSThread-GCD","date":"2016-07-28T15:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-28/iOS-multithreading-NSThread-GCD/","link":"","permalink":"http://fangliquan.github.io/2016-07-28/iOS-multithreading-NSThread-GCD/","excerpt":"1.基本概念 1.1 进程 进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。","text":"1.基本概念 1.1 进程 进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 1.2 线程 （1）基本概念 1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。（2）线程的串行 1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 1.3 多线程 （1）基本概念 即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。（2）线程的并行 并行即同时执行。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C。（3）多线程并发执行的原理 在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象（4）多线程优缺点 优点 1）能适当提高程序的执行效率。 2）能适当提高资源利用率（CPU、内存利用率） 缺点 1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 2）线程越多，CPU在调度线程上的开销就越大。 3）程序设计更加复杂：比如线程之间的通信、多线程的数据共享 1.4 多线程在iOS开发中的应用 （1）主线程 1）一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”。 2）作用。刷新显示UI,处理UI事件。（2）使用注意 1）不要将耗时操作放到主线程中去处理，会卡住线程。 1.5 iOS中多线程的实现方案 （1）pthread 01 特点： （1）一套通用的多线程API （2）适用于Unix\\Linux\\Windows等系统 （3）跨平台\\可移植 （4）使用难度大 02 使用语言：c语言 03 使用频率：几乎不用 04 线程生命周期：由程序员进行管理（2） NSThread 01 特点： （1）使用更加面向对象 （2）简单易用，可直接操作线程对象 02 使用语言：OC语言 03 使用频率：偶尔使用 04 线程生命周期：由程序员进行管理（3）GCD 01 特点： （1）旨在替代NSThread等线程技术 （2）充分利用设备的多核(自动) 02 使用语言：OC语言 03 使用频率：经常使用 04 线程生命周期：自动管理(4) NSOperation 01 特点： （1）基于GCD（底层是GCD） （2）比GCD多了一些更简单实用的功能 （3）使用更加面向对象 02 使用语言：OC语言 03 使用频率：经常使用 04 线程生命周期：自动管理 2.pthread（1）pthread的基本使用（需要包含头文件） //使用pthread创建线程pthread_t thread; NSString *name = @&quot;wendingding&quot;; //使用pthread创建线程 //第一个参数：线程对象地址 //第二个参数：线程属性 //第三个参数：指向函数的执行 //第四个参数：传递给该函数的参数 pthread_create(&amp;thread, NULL, run, (__bridge void *)(name)); 3.NSThread（1）NSThread的基本使用 //第一种创建线程的方式：alloc init.//特点：需要手动开启线程，可以拿到线程对象进行详细设置 //创建线程 /* 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） */ NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;wendingding&quot;]; //启动线程 [thread start];//第二种创建线程的方式：分离出一条子线程//特点：自动启动线程，无法对线程进行更详细的设置 /* 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 */ [NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;我是分离出来的子线程&quot;];//第三种创建线程的方式：后台线程//特点：自动启动县城，无法进行更详细设置[self performSelectorInBackground:@selector(run:) withObject:@&quot;我是后台线程&quot;]; （2）设置线程的属性 //设置线程的属性 //设置线程的名称 thread.name = @&quot;线程A&quot;; //设置线程的优先级,注意线程优先级的取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.5 thread.threadPriority = 1.0; （3）线程的状态（了解） //线程的各种状态：新建-就绪-运行-阻塞-死亡//常用的控制线程状态的方法[NSThread exit];//退出当前线程[NSThread sleepForTimeInterval:2.0];//阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];//阻塞线程//注意：线程死了不能复生 （4）线程安全 01 前提：多个线程访问同一块资源会发生数据安全问题 02 解决方案：加互斥锁 03 相关代码：@synchronized(self)&#123;&#125; 04 专业术语-线程同步 05 原子和非原子属性（是否对setter方法加锁）（5）线程间通信 -(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2]; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; （6）如何计算代码段的执行时间 //第一种方法 NSDate *start = [NSDate date]; //2.根据url地址下载图片数据到本地（二进制数据） NSData *data = [NSData dataWithContentsOfURL:url]; NSDate *end = [NSDate date]; NSLog(@&quot;第二步操作花费的时间为%f&quot;,[end timeIntervalSinceDate:start]);//第二种方法 CFTimeInterval start = CFAbsoluteTimeGetCurrent(); NSData *data = [NSData dataWithContentsOfURL:url]; CFTimeInterval end = CFAbsoluteTimeGetCurrent(); NSLog(@&quot;第二步操作花费的时间为%f&quot;,end - start); ###4.GCD （1）GCD基本知识 01 两个核心概念-队列和任务 02 同步函数和异步函数（2）GCD基本使用【重点】 01 异步函数+并发队列：开启多条线程，并发执行任务 02 异步函数+串行队列：开启一条线程，串行执行任务 03 同步函数+并发队列：不开线程，串行执行任务 04 同步函数+串行队列：不开线程，串行执行任务 05 异步函数+主队列：不开线程，在主线程中串行执行任务 06 同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 07 注意同步函数和异步函数在执行顺序上面的差异（3）GCD线程间通信 //0.获取一个全局的队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.先开启一个线程，把下载图片的操作放在子线程中处理 dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@&quot;http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg&quot;]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@&quot;下载操作所在的线程--%@&quot;,[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@&quot;刷新UI---%@&quot;,[NSThread currentThread]); &#125;); &#125;); （4）GCD其它常用函数 01 栅栏函数（控制任务的执行顺序） dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;--dispatch_barrier_async-&quot;); &#125;); 02 延迟执行（延迟·控制在哪个线程执行） dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@&quot;---%@&quot;,[NSThread currentThread]); &#125;); 03 一次性代码（注意不能放到懒加载） -(void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;-----&quot;); &#125;); &#125; 04 快速迭代（开多个线程并发完成迭代操作） dispatch_apply(subpaths.count, queue, ^(size_t index) &#123; &#125;); 05 队列组（同栅栏函数） //创建队列组 dispatch_group_t group = dispatch_group_create(); //队列组中的任务执行完毕之后，执行该函数 dispatch_group_notify(dispatch_group_t group,dispatch_queue_t queue,dispatch_block_t block); 学习小马哥·文顶顶）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"NSThread","slug":"NSThread","permalink":"http://fangliquan.github.io/tags/NSThread/"},{"name":"GCD","slug":"GCD","permalink":"http://fangliquan.github.io/tags/GCD/"}]},{"title":"iOS 轻量级播放器","slug":"wawa-mediaplayer","date":"2016-07-24T15:30:11.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-24/wawa-mediaplayer/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/wawa-mediaplayer/","excerpt":"公司项目 娃娃 中播放小视频的播放器控件抽取出来，分享一下。WaWaVideoPlayer是一款轻量级视频播放器组件,利用原生MPMoviePlayerController参考kr-video-player编写的一款视频控件。解决项目中微视频播放问题。","text":"公司项目 娃娃 中播放小视频的播放器控件抽取出来，分享一下。WaWaVideoPlayer是一款轻量级视频播放器组件,利用原生MPMoviePlayerController参考kr-video-player编写的一款视频控件。解决项目中微视频播放问题。 WaWaVideoPlayer使用说明使用方法// 视频播放WawaVideoPlayViewController *vc= [[WawaVideoPlayViewController alloc] init];vc.videoURL =[NSURL URLWithString:@&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;];vc.content = @&quot;http://2527.vod.myqcloud.com/2527_117134a2343111e5b8f5bdca6cb9f38c.f20.mp4&quot;;UINavigationController *rootVedioVc = [[UINavigationController alloc]initWithRootViewController:vc];rootVedioVc.navigationBarHidden = YES;[self presentViewController:rootVedioVc animated:NO completion:nil]; 下载视频核心方法 播放器使用 AFNetworking 进行视频文件的下载，用MBProgressHD实现了下载进度 -(void)downloadVideo :(NSURL *)video andMsgContent:(NSString *)content isOnlyDown:(BOOL )isOnlyDown&#123; NSString *videoPath = [self getVideoSaveFolderPathString];//文件名 NSString *file = [videoPath stringByAppendingPathComponent:[content stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;_&quot;]]; if (![file hasSuffix:@&quot;.mp4&quot;]) &#123; file = [file stringByAppendingString:@&quot;.mp4&quot;]; &#125; self.currentVideoFile = file; NSFileManager *fileManager = [NSFileManager defaultManager]; if(![fileManager fileExistsAtPath:file]) &#123; [self createVideoFolderIfNotExist];//创建文件file //初始化进度条 MBProgressHUD *HUD = [MBProgressHUD showMessag:nil toView:self.view]; HUD.tag = 1000; HUD.mode = MBProgressHUDModeAnnularDeterminate; HUD.labelFont = [UIFont systemFontOfSize:12]; HUD.detailsLabelText = @&quot;正在下载...&quot;; HUD.detailsLabelFont = [UIFont systemFontOfSize:14]; HUD.square = YES; //初始化队列 NSOperationQueue *queue = [[NSOperationQueue alloc ]init]; __weak typeof(self)weakSelf = self; //保存路径 AFHTTPRequestOperation *op = [[AFHTTPRequestOperation alloc]initWithRequest:[NSURLRequest requestWithURL:video]]; op.outputStream = [NSOutputStream outputStreamToFileAtPath:file append:NO]; // 根据下载量设置进度条的百分比 [op setDownloadProgressBlock:^(NSUInteger bytesRead, long long totalBytesRead, long long totalBytesExpectedToRead) &#123; CGFloat precent = (CGFloat)totalBytesRead / totalBytesExpectedToRead; HUD.progress = precent; HUD.labelText = [NSString stringWithFormat:@&quot;%0.0f%%&quot;,precent*100]; &#125;]; [op setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123; //NSLog(@&quot;下载成功&quot;); [responseObject writeToFile:file atomically:YES]; if (!isOnlyDown) &#123; [weakSelf playVideoWithURL:[NSURL fileURLWithPath:file]]; &#125;else&#123; if (weakSelf.currentVideoFile &amp;&amp; weakSelf.currentVideoFile.length &gt;0) &#123; [weakSelf.videoController reloadLocalVideo:[NSURL fileURLWithPath:weakSelf.currentVideoFile]]; &#125; &#125; [HUD removeFromSuperview]; &#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; //NSLog(@&quot;下载失败&quot;); HUD.labelText = [NSString stringWithFormat:@&quot;下载失败&quot;]; [HUD removeFromSuperview]; if (!isOnlyDown) &#123; [weakSelf dismissViewControllerAnimated:NO completion:nil]; &#125; &#125;]; //开始下载 [queue addOperation:op]; &#125;else&#123; if (!isOnlyDown) &#123; [self playVideoWithURL:[NSURL fileURLWithPath:file]]; &#125;else&#123; [self.videoController reloadLocalVideo:[NSURL fileURLWithPath:self.currentVideoFile]]; &#125; &#125;&#125; 更多具体实现请下载工程实例源码下载","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS视频播放器","slug":"iOS视频播放器","permalink":"http://fangliquan.github.io/tags/iOS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"}]},{"title":"使用Hexo和github pages搭建博客","slug":"使用Hexo-和github-pages-搭建博客","date":"2016-07-24T11:50:26.000Z","updated":"2016-07-24T14:30:26.000Z","comments":true,"path":"2016-07-24/使用Hexo-和github-pages-搭建博客/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/%E4%BD%BF%E7%94%A8Hexo-%E5%92%8Cgithub-pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows/MAC/Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo","text":"1. 简介hexo是一个基于node.js的静态博客程序，可以方便的生成静态网页（纯html）支持多个平台（Windows/MAC/Linux），风格优雅，更适合写技术博客，与hexo类似的博客程序还有jekyll，jekyll被github着力推荐官方就提供了jekyll教程，但是jekyll是基于ruby写的，并且关于代码高亮没找到比较好的方案，就选择了用hexo 2. 配置环境2.1 安装git作者用的是mac，可以使用brew下面命令安装 $ brew install git 也可以直接上git官网下载安装 2.2 安装node.js同样的，mac可以使用brew安装，新版的node.js已经包含npm工具，不需要再另外安装了 $ brew install node 可以通过下面命令检查是否已安装 $ node -v$ npm -v 如果是windows用户可以通过官网下载 jode.js 2.3 Hexo安装上面的安装完成后，接下来安装hexo npm install hexo-cli -g #-g表示全局安装, npm默认为当前项目安装hexo init blog #在当前目录下新建blog目录初始化博客cd blog #进入blog目录#npm install hexo generate #根据当前配置生成静态页面hexo server #启动本地服务，默认为：[http://localhost:4000/](http://localhost:4000/) 接下来就可以通过http://localhost:4000/查看效果了 3. 配置github pages每个github账户都可以有一个外部空间/Responsitory，可以直接通过用户名.github.io访问到该仓库的内容 在github上新增一个responsitory，仓库名为 用户名.github.io 或 用户名.github.com 创建完成后，github会自动将 用户名.github.io指向该仓库，默认访问根目录下的index.html页面 可以进入Responsitory的Setting页查看 github会提供几个模板搭建站点，我们可以不用他提供的模板，可以在仓库里面，添加一个简单的index.html文件，如果能通过用户名.github.com访问，则表明创建成功了 4. 写博客hexo的文章存放在source目录下 ├── source | ├── _posts #存放文章 | └── _drafts #存放草稿 $ hexo new post &quot;postName&quot; # 在source/_posts 目录下创建postName.md文件 创建文件的命名格式可以在_config.yml文件配置 # Writingnew_post_name: :year-:month-:day-:title.md 文件创建完成后会自动生成以下格式（可以自己添加） ---title: 使用Hexo和github pages搭建博客date: 2016-04-18 19:50:26categories: blog # 分类tags: [blogs, hexo] # 标签，格式：[标签, 标签2]--- 关与写作的各种参数可以参见：https://hexo.io/docs/writing.html 写完后预览的时候发现，文章在首页就全部显示出来了，如果不想全部显示，可以在文章中间添加下面标记，在首页列表就会出现Read More的标记 &lt;!--more--&gt; Hexo支持使用Markdown语法写文章，我比较习惯用Atom写Markdown，Atom有个hexo插件 5. 主题官方自带主题基本够用，有能力可以自己改造，当然，网上已经有很多人做了一些很好看的主题了，我们可以直接拿来用，下面是官方列出的一些主题，找到喜欢的可以直接用 https://github.com/hexojs/hexo/wiki/Themeshttps://hexo.io/themes 在hexo上，主题放在themes目录下，我们只需要把别人做好的主题clone下来就好了，然后在_config.yml修改一下配置例如：我们可以https://github.com/xiangming/landscape-plus这个主题clone下来 git clone git@github.com:xiangming&#x2F;landscape-plus.git themes&#x2F;landscape-plus 修改设置_config.yml theme: landscape-plus 6. 添加多说评论插件到多说官网注册和创建一个站点 修改配置到themes/landscape-plus/_config.yml添加多说的配置，shortname即注册的站点名称 # Duoshuoduoshuo_shortname: bomo 参见官方说明，替换评论相关的代码http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9 完成，如下图评论有了 7. 部署到github上修改配置_config.yml deploy: type: git repository: https://github.com/zhengbomo/zhengbomo.github.io.git branch: master 安装 hexo-deployer-git $ npm install hexo-deployer-git --save 部署hexo到git上 $ hexo deploy 部署过程需要输入账号密码，然后会push到github上，参考：https://hexo.io/docs/deployment.html hexo部署时会把最终生成的博客文件（public目录下的文件）push到git远程仓库，而博客程序还是在本地，当我们切换电脑的时候，无法对博客进行重新编辑和发布，这个时候我们可以在git添加一个分支hexo用来存放博客程序和编写的内容，详情可以参见： git创建分支hexo存放博客程序 8. 域名绑定 通常域名在godaddy注册比较靠谱，这个是最大的域名提供商，而且不需要备案，支持支付宝付款，购买的时候可以使用优惠码会便宜一些，网上有很多优惠码，可以自行搜索，购买过程很简单，这里就不贴了 注册和配置DNS服务器Godaddy自带的域名解析服务器比较慢，在国内推荐使用DNSpod：快，免费，稳定。 到DNSpod注册登陆，然后到用户中心，添加域名，例如我的域名为bomobox.org 进入设置添加两个A记录指向github提供的ip，参见这里 192.30.252.153192.30.252.154 添加一个CNAME记录指向自己的github域名：username.github.io把其他的删除 注册域名和配置DNS 到Godaddy购买域名完成后完成后进入MyAccount 进入DNS Manager修改DNS服务器 f1g1ns1.dnspod.netf1g1ns2.dnspod.net 到github仓库的根目录添加CNAME文件，文件内添加自己的域名，否则会出现404访问错误，也可以在hexo的source目录下添加，然后不熟到github 上面步骤设置完成后可能会有几个小时的延迟，才能生效，总的来说还是比较简单的 9. 问题在使用别人的主题的时候可能会报错或者有些功能用不了，原因可能是部分插件没有安装，例如RSS用不了，那可能是hexo-generator-feed没安装，下面列举一些常用的插件，建议都安装，没有用到也没有关系，需要先到hexo程序目录下在执行命令，插件位于node_modules目录下 $ npm install hexo-generator-feed --save #支持RSS$ npm install hexo-generator-sitemap --save #生成站点地图$ npm install hexo-generator-baidu-sitemap --save #生成百度站点地图$ npm install hexo-html-minifier --save #HTML 压缩$ npm install hexo-uglify --save #JavaScript 压缩$ npm install hexo-clean-css --save #CSS 压缩插件$ npm install hexo-generator-seo-friendly-sitemap --save #SEO优化$ npm install hexo-deployer-git --save #git部署插件 并在博客配置文件_config.yml配置plugin Plugins:- hexo-generator-feed- hexo-generator-sitemap 更多插件可以在https://hexo.io/plugins/找到 10. Atom插件由于我编写md使用的是Atom，这里推荐几个Atom上的插件 markdown-scroll-sync：Markdown预览实时滚动，自带的预览不支持实时滚动 markdown-writer：Markdown协作工具 Date：快速插入当前时间的工具 atom-hexo：快速添加draft，post，publish，deploy 11. 总结使用hexo搭建博客环境还是非常方便的，基本上都是自动的，当然还有一些详细的配置，例如分页，分类，评论等，Hexo支持的插件也相当多的，接下来可以好好写博客了，以后再慢慢完善了，今天先到这里 12. 参考链接 https://hexo.io 转自 bomo大神的博客","categories":[{"name":"blog","slug":"blog","permalink":"http://fangliquan.github.io/categories/blog/"}],"tags":[{"name":"blogs","slug":"blogs","permalink":"http://fangliquan.github.io/tags/blogs/"},{"name":"hexo","slug":"hexo","permalink":"http://fangliquan.github.io/tags/hexo/"}]},{"title":"iOS开发--图文混排","slug":"iOS-multi-graphic-solution-Frame-model","date":"2016-07-24T05:26:17.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-24/iOS-multi-graphic-solution-Frame-model/","link":"","permalink":"http://fangliquan.github.io/2016-07-24/iOS-multi-graphic-solution-Frame-model/","excerpt":"iOS开发中会遇到页面展示多图文的问题，尤其是新闻等图文混排，而且是图片不知道到宽高的情况。 此时就需要先异步下载图片然后根据得到的image通过 宽高比来更新对应ImageView的Frame。最后通过每个ImageView的Frame变化在重新更新多图文UI的Frame。","text":"iOS开发中会遇到页面展示多图文的问题，尤其是新闻等图文混排，而且是图片不知道到宽高的情况。 此时就需要先异步下载图片然后根据得到的image通过 宽高比来更新对应ImageView的Frame。最后通过每个ImageView的Frame变化在重新更新多图文UI的Frame。 根据页面设计得出页面的Frame模型 例： @property(nonatomic ,assign ,readonly) CGRect noticeTitleF;@property(nonatomic ,assign ,readonly) CGRect noticeTimeF;@property(nonatomic ,assign ,readonly) CGRect noticeSenderF;@property(nonatomic ,assign ,readonly) CGRect noticecontentF;@property(nonatomic ,strong ,readonly) NSArray *noticeImagesF;@property(nonatomic ,strong ,readonly) NSArray *noticeImagesDespF; 给通过Frame模型中setModel方法来计算对应的Rect值 项目中的图文和标题内容是分开的 以AttachModel集合的方式返回过来，先假设集合中的每一项都有image和对应的描述来计算对应的Attach的ViewModelFrame，例：HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i];ViewFrameModel *imageRect = [[ViewFrameModel alloc]init];imageRect.x = rightAndLeftMargin;imageRect.y = offsetY + upImageDespH;imageRect.width = contentWidth;imageRect.height = 300;[imagesF addObject:imageRect]; CGFloat imageDespH = [BabyScheduleTaskHeaderFrame textFrameWithString:pictureTopicPost.desp width:contentWidth fontSize:WAWA_TEXTFONT_FLOAT_TITLE].height + 2;ViewFrameModel *imageDespRect = [[ViewFrameModel alloc]init];imageDespRect.x = rightAndLeftMargin;imageDespRect.y = offsetY + upImageDespH + 300;imageDespRect.width = contentWidth;imageDespRect.height = imageDespH;[imagesDespF addObject:imageDespRect];upImageDespH += (imageDespH +topAndBottomMargin + 300); 根据集合下载对应的Image并更新Framefor (int i = 0 ; i &lt;attachs.count; i++) &#123; HedoneAttachDTO *pictureTopicPost = hedoneClassWeeklyTaskResponse.attachs[i]; [self getClassWeeklyTaskAttachPictureFrame:pictureTopicPost andIndex:i completion:^(NSInteger index, CGFloat imageH)&#123; NSMutableArray *imagesOldF = [NSMutableArray arrayWithArray:_noticeImagesF]; NSMutableArray *imagesDespOldF = [NSMutableArray arrayWithArray:_noticeImagesDespF]; //更新imageHeight ViewFrameModel *pictureF = imagesOldF [index]; pictureF.height = imageH; [imagesOldF replaceObjectAtIndex:index withObject:pictureF]; ViewFrameModel *oldpictureFM = [imagesOldF firstObject]; CGRect oldpictureR = CGRectMake(oldpictureFM.x, oldpictureFM.y, oldpictureFM.width, oldpictureFM.height); ViewFrameModel *oldpictureDespFM = [imagesDespOldF firstObject]; oldpictureDespFM.y = CGRectGetMaxY(oldpictureR) + topAndBottomMargin; [imagesDespOldF replaceObjectAtIndex:0 withObject:oldpictureDespFM]; CGFloat oldOffsetY = offsetY + oldpictureFM.height + topAndBottomMargin + oldpictureDespFM.height + topAndBottomMargin; //遍历集合 重新赋值frame for (int m = 1; m &lt;imagesOldF.count; m++) &#123; oldOffsetY = oldOffsetY; ViewFrameModel *uppictureF = imagesOldF [m]; uppictureF.y = oldOffsetY; [imagesOldF replaceObjectAtIndex:m withObject:uppictureF]; oldOffsetY = oldOffsetY + uppictureF.height + topAndBottomMargin; ViewFrameModel *uppictureDespF = imagesDespOldF [m]; uppictureDespF.y = oldOffsetY; [imagesDespOldF replaceObjectAtIndex:m withObject:uppictureDespF]; oldOffsetY = oldOffsetY + uppictureDespF.height + topAndBottomMargin; &#125; _noticeFooterF = CGRectMake(0, oldOffsetY + topAndBottomMargin*4, Main_Screen_Width, 1); _noticeHeaderHeight = CGRectGetMaxY(_noticeFooterF); _noticeImagesF = imagesOldF; _noticeImagesDespF = imagesDespOldF; if (self.reloadNoticeHeaderFrameBlock) &#123; //更新页面Frame回调Block self.reloadNoticeHeaderFrameBlock(); &#125; &#125;];&#125; 根据设计编写多图文的UIView代码 有多图文对象的个数来绘制页面并保存到数组中 _imageArray = [NSMutableArray arrayWithCapacity:_momentPicturesCount];_imageDespArray = [NSMutableArray arrayWithCapacity:_momentPicturesCount];for (int i = 0;i&lt; _momentPicturesCount;i++) &#123; UIImageView *picView = [[UIImageView alloc]init]; picView.tag = i; picView.image = [UIImage imageNamed: (@&quot;childshow_placeholder&quot;)]; picView.userInteractionEnabled = YES; [picView addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(showPicture:)]]; [_imageArray addObject:picView]; [self addSubview:picView]; AutoLinkLabel *imageDespLabel = [[AutoLinkLabel alloc]init]; imageDespLabel.font = [UIFont systemFontOfSize:WAWA_TEXTFONT_FLOAT_CONTENT_BIG]; imageDespLabel.textColor = WAWA_TEXTCOLOR_DARKGRAY; imageDespLabel.aDelegate = self; imageDespLabel.numberOfLines = 0; [_imageDespArray addObject:imageDespLabel]; [self addSubview:imageDespLabel];&#125; 在UIView的setModel中给页面控件赋值Frame和Content 由计算好的Frame在重新给已保存好的多图文集合赋值并替换 for (int i = 0 ; i &lt; babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs.count; i++) &#123; UIImageView *imageView = self.imageArray[i]; ViewFrameModel *frameModel = babyScheduleTaskHeaderFrame.noticeImagesF[i]; imageView.frame = CGRectMake(frameModel.x, frameModel.y, frameModel.width, frameModel.height); //NSLog(@&quot;image%ld, offsetY:%ld,height :%ld&quot;,i,frameModel.y,frameModel.height); AutoLinkLabel *imageDespL = self.imageDespArray[i]; ViewFrameModel *despframeModel = babyScheduleTaskHeaderFrame.noticeImagesDespF[i]; imageDespL.frame = CGRectMake(despframeModel.x, despframeModel.y, despframeModel.width, despframeModel.height); //NSLog(@&quot;imageDesp%ld, offsetY:%ld,height :%ld&quot;,i,despframeModel.y,despframeModel.height); HedoneAttachDTO *pictureTopicPost = babyScheduleTaskHeaderFrame.hedoneClassWeeklyTaskResponse.attachs[i]; [imageView setImageWithURLStr:pictureTopicPost.addr placeholder:[UIImage imageNamed:@&quot;childshow_placeholder&quot;]]; imageDespL.autoLinkText = pictureTopicPost.desp?pictureTopicPost.desp:@&quot;&quot;; [self.imageArray replaceObjectAtIndex:i withObject:imageView]; [self.imageDespArray replaceObjectAtIndex:i withObject:imageDespL];&#125; 将UIView赋值给TableViewHeader定义多图文frameModel对象并设置detailModel BabyScheduleTaskHeaderFrame *detailHeaderFrame = [[BabyScheduleTaskHeaderFrame alloc]init];detailHeaderFrame.hedoneClassWeeklyTaskResponse = model;__unsafe_unretained typeof(self) selfVc = self;detailHeaderFrame.reloadNoticeHeaderFrameBlock = ^()&#123; //回调更新Frame selfVc.babyScheduleTaskHeaderView.babyScheduleTaskHeaderFrame = selfVc.babyScheduleTaskHeaderFrame; CGRect oldHeaderF = selfVc.babyScheduleTaskHeaderView.frame; oldHeaderF.size.height = selfVc.babyScheduleTaskHeaderFrame.noticeHeaderHeight; selfVc.babyScheduleTaskHeaderView.frame = oldHeaderF; selfVc.tableView.tableHeaderView = selfVc.babyScheduleTaskHeaderView;&#125;;self.babyScheduleTaskHeaderFrame = detailHeaderFrame;BabyScheduleTaskHeaderView *detailHeaderView = [[BabyScheduleTaskHeaderView alloc]initWithFrame:CGRectMake(0, 0, Main_Screen_Width, detailHeaderFrame.noticeHeaderHeight) andMomentPicturesCount:(int)model.attachs.count];detailHeaderView.babyScheduleTaskHeaderFrame = detailHeaderFrame;self.babyScheduleTaskHeaderView = detailHeaderView;self.tableView.tableHeaderView = self.babyScheduleTaskHeaderView; 更多具体实现请下载源码 下载源码","categories":[{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"}],"tags":[{"name":"iOS多图文","slug":"iOS多图文","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E5%9B%BE%E6%96%87/"},{"name":"图文混排","slug":"图文混排","permalink":"http://fangliquan.github.io/tags/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/"},{"name":"Frame模型","slug":"Frame模型","permalink":"http://fangliquan.github.io/tags/Frame%E6%A8%A1%E5%9E%8B/"}]},{"title":"iOS新特性学习--泛型","slug":"iOS9-new-feature-generic","date":"2016-07-23T09:06:11.000Z","updated":"2021-03-14T07:55:26.990Z","comments":true,"path":"2016-07-23/iOS9-new-feature-generic/","link":"","permalink":"http://fangliquan.github.io/2016-07-23/iOS9-new-feature-generic/","excerpt":"泛型：限制类型使用场景 在集合（数组，字典，NSSet)中使用泛型比较常见 当声明一个类，类里面的某些书写的类型不确定，这时候我们才使用泛型。z","text":"泛型：限制类型使用场景 在集合（数组，字典，NSSet)中使用泛型比较常见 当声明一个类，类里面的某些书写的类型不确定，这时候我们才使用泛型。z 书写规范 在类型后面定义泛型，1NSMutableArray&lt;UIImage *&gt; *mutableArray 修饰：只能修饰方法的调用 好处： 提高规范，减少交流 通过集合取出来对象，直接当做泛型对象使用，可以直接使用点语法1self.mutableArray[0].temp; 子类想给父类赋值使用协变__covariant(协变）:用于数据强转类型，可以向上强转，子类，可以转成 父类，例: 1@interface Person&lt;__covariant ObjectType&gt; 父类强转成子类 逆变__contravariant（逆变）：用于泛型数据强转类型，可以向下强转，父类可以转成子类 例: 1@interface Person&lt;__contravariant ObjectType&gt; 定义泛型类123@interface Person&lt;__covariant ObjectType&gt; : NSObject@property(nonatomic) ObjectType language;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"runtime","slug":"runtime","permalink":"http://fangliquan.github.io/tags/runtime/"},{"name":"iOS9新特性","slug":"iOS9新特性","permalink":"http://fangliquan.github.io/tags/iOS9%E6%96%B0%E7%89%B9%E6%80%A7/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-07-22T09:06:11.000Z","updated":"2017-03-20T10:28:58.000Z","comments":true,"path":"2016-07-22/hello-world/","link":"","permalink":"http://fangliquan.github.io/2016-07-22/hello-world/","excerpt":"","text":"世界上的第一个程序就是Hello World！！ I am a programmer. I like programming.","categories":[],"tags":[]},{"title":"swift学习笔记","slug":"swift-start","date":"2016-06-28T07:00:04.000Z","updated":"2016-12-16T07:00:04.000Z","comments":true,"path":"2016-06-28/swift-start/","link":"","permalink":"http://fangliquan.github.io/2016-06-28/swift-start/","excerpt":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子","text":"一直没有时间好好看一下swift，最近复习了一遍语法，这里记录swift学习过程中遇到的一些问题和要点，和Object-C的一些相关特性这里也不做介绍，只记录swift特有的一些特性swift借鉴了很多语言的语法，特别是脚本语言，在swift里，可以看到python语言的一些影子，还有其他编程语言的影子 一、基础语法 swift语句结束不需要分号（写了也没有问题），有一种情况需要分号，如果一行代码中有多条语句，这时候就必须要分号隔开 swift字符串，数组语法糖，字典语法糖不需要@标示 swift是类型安全的语言，所有的类型都不会自动转换（如：Int和UInt类型不能直接运算），同事swift具有强大的类型推测，所以很多时候我们不需要声明类型 swift的多行注释支持嵌套/* 这是第一个多行注释的开头/* 这是第二个被嵌套的多行注释 */这是第一个多行注释的结尾 */ swift的布尔值使用小写true和false，判断语句只能使用Bool类型 二、数据类型 与objc一样，swift支持以前（objc）使用的所有数据类型，swift的类型名字首字母大写，如Int, Float, NSInteger swift支持可选类型（Optionals）类型，相当于C#中的可空类型，标识变量可能为空，基础数据类型也可为空，可选类型不能直接赋非可选类型var a: Int? = 10var b: Int = a // 报错，不同类型不能赋值 swift的布尔类型使用true/false，而不用YES/NO swift支持使用_来分割数值来增强可读性而不影响值，如一亿可以表示为下面形式let oneMillion = 1_000_000 swift数值类型进行运算符计算的时候不会自动进行类型转换，通常可以通过类型的构造方法进行类型转换var a: Int = 12var b: Float = 23var c = a + b // 报错var d = Float(a) + b // 正确 swift的基础数据类型与对象类型一视同仁，可以混用，不需要装箱和拆箱 TODO：Any, AnyObject,三、常量变量 与C/Obj-C不同，swift的常量更为广义，支持任意类型，常量只能赋值一次 swift的变量和常量在声明的时候类型就已经确定（由编译器自动识别或开发者指定） 使用let声明的集合为可变集合，使用var声明的集合为不可变集合 如果你的代码中有不需要改变的值，请使用 let 关键字将它声明为常量。只将需要改变的值声明为变量。这样可以尽量数据安全，并且常量是线程安全 // 常量：使用let声明，赋值后就不能再修改let a = NSMutableArray()let b = 12let c: Float = 12 // 类型标注(type annotation)let d = b + 12a.addObject(11) // str == [11]let e = a // str == [11], d == [11]a.addObject(12) // str == [11, 12], d == [11, 12]// 变量：使用var声明var f: Double? = 12var g = &quot;hello world&quot; 类型标注在声明变量和常量的时候可以如果可以由编译器自动识别，可以不用制定类型，如下 let a = 12 //常量a会编译为Int类型var b = 1.3 //变量b会编译为Double类型 我们也可以指定类型 let a: Double = 12let b: Float = 1.3 可以在一行声明多个变量/常量，在最后一个声明类型 var red, green, blue: UInt 四、序列和集合1. 数组Arrayswift的数组可以是有类型的（泛型），存放同类型的数据，如果添加一个错误的类型会报编译错误，默认情况下编译器会自动识别 //1. 数组的写法为：Array&lt;Int&gt;，也可以简写成[Int]//2. 数组初始化与NSArray类似，直接用中括号括起来，里面值用逗号隔开var array0 = [Int]()var array1: [Int] = [1, 3, 5, 7, 9]var array2: Array&lt;Int&gt; = array1array1.append(11) // [1, 3, 5, 7, 9, 11]array1.insert(0, atIndex: 0) // [0, 1, 3, 5, 7, 9, 11]array1.isEmpty // Falsearray1.count // 7// 3. 如果初始化时不指定类型，而编译器也不能识别出类型，这时候，会被当成NSArray处理var array3 = [] // array3 为 NSArray类型的空数组// 4. 如果声明的时候使用不同的类型，编译器会把数组识别为NSObject类型var array4 = [&quot;fdsa&quot;, 121] // array4 为 Array&lt;NSObject&gt; 类型// 5. 集合支持加法运算，相当于NSMutableArray的addObjectsFromArrayarray1 += [2, 4, 6, 8, 10] // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]// 6. 使用let声明的数组不可变，不能修改数组array3let array5: [Int] = [1, 3, 5, 7, 9]//array5.append(2) // 报编译错误// 7. 集合使用下标索引，支持区间索引，区间不可越界var array6: [Int] = [1, 3, 5, 7, 9]array6[1] = 4 // [1, 3, 5, 7, 9]array6[1...3] = [2, 3, 4] // [1, 2, 3, 4, 9]array6[0...2] = array6[1...3] // [2, 3, 4, 4, 9]// 8. 迭代数组的时候，如果需要索引，可以用enumerate方法for (index, value) in array4.enumerated() &#123; //do something&#125; 2. 字典Dictionary与数组类型一样，字典也支持泛型，其键值类型都可以指定或有编译器识别，其中Key的类型，必须是可Hash的，swift中基础数据类型都是可hash的（String、Int、Double和Bool） // 1. 用法与oc类似，初始化不需要@var dict1 = [&quot;key1&quot;: 1, &quot;key2&quot;: 2, &quot;key3&quot;: 3]// 2. 声明方式var dict2: Dictionary&lt;String, Int&gt; = dict1 //dict2与dict1不是一个对象var dict3: [String: Int] = dict1 //通常采用这种方式声明类型// 3. 不声明类型，编译器又无法识别，则为NSDictionaryvar dict4 = [:]var dict5: [Int: String] = [:]// 4. 修改或添加键值对dict1[&quot;key3&quot;] = 4// 5. 删除键dict1[&quot;key3&quot;] = nil// 6. key不存在不报错，返回可空类型nillet value4 = dict1[&quot;key4&quot;]// 7. 字典迭代返回key/value元组，类似pythonfor (key, value) in dict1 &#123; print(&quot;\\(key) = \\(value)&quot;)&#125; 数组（Array）或字典（Dictionary），如果声明为变量（var），则为可变，如果为常量（let），则为不可变常量数组或字典编译器会对其进行优化，所以尽量把不可变的数组定义为常量数组 3. SetSet集合用于存放无序不重复的对象，用法与数组类似，重复的项会被忽略 var s: Set&lt;Int&gt; = [1, 3, 5, 6, 7, 4, 3, 7] // [1, 3, 4, 5, 6, 7]s.counts.isEmptys.insert(3)s.remove(3)s.contains(3) 集合操作 let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]//合操作oddDigits.union(evenDigits).sort() // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]//交操作oddDigits.intersection(evenDigits).sorted() // []//减操作oddDigits.subtracting(singleDigitPrimeNumbers).sorted() // [1, 9]//不重叠集合oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted() // [1, 2, 9] 使用“是否相等”运算符( == )来判断两个 合是否包含全部相同的值。 使用 isSubset(of:) 方法来判断一个 合中的值是否也被包含在另外一个 合中。 使用 isSuperset(of:) 方法来判断一个 合中包含另一个 合中所有的值。 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个 合的子 合或 者父 合并且两个 合并不相等。 使用 isDisjoint(with:) 方法来判断两个 合是否不含有相同的值(是否没有交 ) 4. 元组Tuple与python类似，swift也支持元组，可以很方便的使用元组包装多个值，也使得函数返回多个值变得更加方便，特别是临时组建值得时候 支持任意类型 支持同时赋值 支持自定义key，支持索引 元组不是对象，不是AnyObject类型，由于swift是强类型的，所以元组有时不能当做普通的对象使用，例如不能把元组加到数组里面，元组内的所有类型必须是明确的 // 1. 声明一个元组，元组支持任意类型let httpError1 = (404, &quot;Not Found&quot;)let point = (100, 50)// 2. 可以分别赋值let (x, y) = pointprint(x) // 100print(y) // 50// 3. 使用下标取元组元素，下标从0开始print(httpError1.0) // 404print(httpError1.1) // Not Found// 4. 可以给数组元素取名let httpError2 = (code: 404, errorMessage: &quot;Not Found&quot;)print(httpError2.code) // 404print(httpError2.errorMessage) // Not Found// 5. 可以用下划线表示忽略部分值let (a, _) = point 元组在临时组织值得时候很有用，可以不用重新定义数据结构 5. 字符串Stringswift字符串是由Character字符组成的集合，支持+操作符，可以与NSString无缝桥接，swift的字符串完全兼容unicode字符串与值类型（与Int, Float）一样，是值类型，在传值的时候都会进行拷贝，当然这回带来一定的性能损耗，swift编译器在编译的时候会进行优化，保证只在必要的情况下才进行拷贝 // 1. 与NSString不同，声明不需要@前缀，支持转移字符let name1 = &quot;bomo\\n&quot;// 2. 空串（下面两种方式等价）let name2 = &quot;&quot;let name3 = String()// 3. 字符串由字符Character组成，定义字符let character1: Character = &quot;!&quot;// 4. 常见属性，方法name1.isEmpty // 判空name1.characters.count // 获取字符串的字符数name1.uppercaseStringname1.lowercaseStringname1.hasPrefix(&quot;bo&quot;)name1.hasSuffix(&quot;mo&quot;)// 5. 加法运算let hello = &quot;hello &quot; + name1 // hello bomo\\n// 6. 比较（比较值，而不是地址）let name4 = &quot;b&quot; + &quot;omo\\n&quot;name4 == name1 // True// 7. 字符串插值（使用反斜杠和括号站位）let city = &quot;广州&quot;let hello2 = &quot;I&#x27;m \\(name1) from \\(city)&quot;// 8. 格式化字符串let f = 123.3233var s = String(format: &quot;%.2f&quot;, f) //123.32 6. 集合的赋值和拷贝行为swift的集合通常有Array和Dictionary，他们在赋值或传递的时候，行为上有所不同，字典类型Dictionary或数组类型Array在赋值给变量或常量的时候，只要有做修改，就会进行值拷贝，并且不会作用到原来变量上 var dict1 = [&quot;a&quot;: 1, &quot;b&quot;: 2]var dict2 = dict1print(dict1 == dict2) // truedict2[&quot;a&quot;] = 3 // 修改dict2print(dict1 == dict2) // falsevar arr1 = [&quot;a&quot;, &quot;b&quot;]var arr2 = arr1print(arr1 == arr2) // truearr1[0] = &quot;c&quot; // 修改arr1// arr1.append(&quot;c&quot;)print(arr1 == arr2) // false 当数组或字典作为参数传递给函数的时候，由于在Swift3中不推荐使用变量参数，故所有函数参数不可变，故也不进行拷贝 五、可选类型（可空类型）swift加入了可空类型让我们使用数据的时候更为安全，我们需要在可空的地方使用可选类型声明该变量可为空，不能给非可选类型设值nil值，在使用的时候可以明确的知道对象是否可能为nil，有点像ObjC的对象，对象可以为nil，也可以不为nil，而swift得可选类型范围更广可以作用于任何类型（基础类型，类，结构体，枚举） 1. 声明// 1. 声明可选类型，在类型后面加上?var obj1: NSObject?obj1 = NSObject()obj1 = nil// 2. 不能给一个可选类型赋nil，下面会报错，var obj = NSObject()obj = nil// 3. 如果声明可选变量时没有赋值，则默认为nilvar i: Int?// 4. 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;// 5. 不能把可选类型赋值给非可选类型，下面会报错let cat: String = dog 2. 强制解析可选类型不能直接使用，需要通过取值操作符!取得变量的值，才能使用，如果变量有值，则返回该值，如果变量为空，则会运行时错误 var b: Int?var a: Inta = 12b = 13let c = a + b! // 先对b取值，再运算var b: Bool? = nilif b! &#123; // b为空，编译不报错，运行时报错 print(&quot;true&quot;)&#125; else &#123; print(&quot;false&quot;)&#125; 3. 可选绑定使用可选绑定可以判断一个可选类型是否有值，如果有值，则绑定到变量上，如果没有值，返回false，使用if-let组合实现 var i: Int? = nilif let number = i &#123; print(&quot;\\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持绑定条件 var i: Int? = nilif let number = i where i &gt; 10 &#123; print(&quot;i不为空且大于10 \\(number)&quot;)&#125; else &#123; print(&quot;nil&quot;)&#125; 可选绑定还支持多个绑定，不许所有的绑定都满足才返回true if let firstNumber = 1, let secondNumber = 2)&#125;// 输出 &quot;4 &lt; 42 &lt; 100&quot; if let firstNumber = Int(&quot;4&quot;) &#123; if let secondNumber = Int(&quot;42&quot;) &#123; if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 &#123; print(&quot;\\(firstNumber) &lt; \\(secondNumber) &lt; 100&quot;)&#125; &#125;&#125; 4. 隐式解析声明类型的时候可以使用隐式解析，即在使用可选变量的时候自动取值，不需要调用!操作符， // 一个函数返回一个可选类型func getdog() -&gt; String? &#123; return &quot;wangcai&quot;&#125;//假定我们通过getdog方法返回的值一定不为空var dog: String? = getdog()let cat: String = dog! // 使用前需要通过!强制取值 使用dog的时候都需要取值我们觉得太麻烦了，可以声明成隐式可选类型，使用的时候自动取值 var dog: String! = getdog() // 实际上dog还是可选类型，只是使用的时候回自动取值let cat: String = dog // 在使用dog的时候会自动进行取值，不需要取值操作符 5. 可选类型自判断链接在使用可选类型之前，需要进行判断其是否有值，才能使用，通过!操作符取值后使用（保证有值的情况下），或通过if-let可选绑定的方式，swift提供了一种类似C#语言的语法糖可以让代码更为简洁，可以自动判断值，如果有值，则操作，无值则不操作，并返回nil，在使用前加上? class Person &#123; var favDog: Dog?&#125;class Dog &#123; var name: String?&#125;var p = Person()var d = Dog()// p.favDog = dp.favDog?.name = &quot;tobi&quot; // 如果p.favDog为空，不设置nameif let name = p.favDog?.name &#123; // p.favDog不为空且p.favDog.name不为空&#125; else &#123; // p.favDog为空或p.favDog.name为空&#125; 自判断链接还支持多连接如 let identifier = john.residence?.address?.buildingIdentifier 6. 可选关联运算符可选关联运算符可对可选类型进行拆包，如果可选类型对象为nil，返回第二个操作数，第二个操作数类型必须和第一个操作数同类型（可选或不可选） let defaultColorName = &quot;red&quot;var userDefinedColorName: String? // defaults to nilvar colorNameToUse = userDefinedColorName ?? defaultColorName defaultColorName和userDefinedColorName必须是同类型（String或String?） 如果userDefinedColorName不为空，返回其值，如果userDefinedColorName为空，返回defaultColorName 返回值colorNameToUse的类型同??的第二个操作数的类型，为String 六、运算符swift运算符在原有的基础上做了一些改进，还添加了一下更高级的用法，还有新的运算符 =运算符不返回值 符合运算符+=, -=等不返回值 //下面语句会报错let b = a *= 2 比较运算符可以用于元组的比较（逐个比较，如果遇到不等的元素，则返回，默认最多只能比较7个元素的元组，超过则需要自定义） (1, &quot;zebra&quot;) &lt; (2, &quot;apple&quot;) // true，因为 1 小于 2 字符串String，字符Character支持+运算符 浮点数支持%求余运算 8 % 2.5 // 等于 0.5 ++/--运算在swift3被抛弃，用+=/-=代替 支持溢出运算符（&amp;+, &amp;-, &amp;*），可以在溢出时进行(高位)截断 支持位运算符（&gt;&gt;, &lt;&lt;） 支持三目运算符（a ? b : c） 支持逻辑运算符（&amp;&amp;, ||, !） 与其他高级语言类似，swift运算符支持重载，可以为类添加自定义的运算符逻辑，后面会讲到 !=, ==, ===, !==（恒等于/不恒等于） `===`：这两个操作符用于引用类型，用于判断两个对象是否指向同一地址 `!===`：与`===`相反，表示两个变量/常量指向的的地址不同 `==`：表示两个对象逻辑相等，可以通过重载运算符实现相等的逻辑，两个值相等的对象可以是不同地址的对象 `!=`：与`==`相反，表示两个对象逻辑不等 区间运算符 可以使用a...b表示一个范围，有点类似于Python的range(a, b) for i in 1...5 &#123; print(i) // 1, 2, 3, 4, 5&#125; a...b: 从a到b并包含a和b a..&lt;b: 包含a不包含b a..b表示半闭区间的用法已经被放弃 范围运算符也可以作用于字符串 let az = &quot;a&quot;...&quot;z&quot; // 返回的是CloseInteval或HalfOpenIntervalaz.contains(&quot;e&quot;) // True 空合运算符??（与C#类似） 对于可选类型取值，如果不为空则返回该值，如果为空则去第二个操作数 let result = a ?? b 七、流程控制swift使用三种语句控制流程：for-in、for、switch-case、while和repeat-while，且判断条件的括号可以省略 let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names &#123; print(&quot;Hello, \\(name)!&quot;)&#125;//如果不需要使用到迭代的值，使用下划线`_`忽略该值for _ in 1...10 print(&quot;hello&quot;) 流程控制语句的条件返回值必须是Bool，下面会报错 var dd: Bool? = trueif dd &#123; print(&quot;fd&quot;)&#125; 条件判断可以与let结合使用，当值为nil时，视为false（即：可选绑定） var dd: Bool? = trueif let ee = dd &#123; print(&quot;fd&quot;)&#125; 在Swift2.0以后，不支持do-while语句，使用repeat-while代替，用法与do-while一样 repeat &#123; print(&quot;repeat while : \\(j)&quot;) j++ &#125; while j &lt; 3 guard-else翻译为保镖模式，在执行操作前，进行检查，如果不符合，则拦截，使用方式与if有些类似，如果与let结合使用，可以对可选类型解包，先看看普通的if-else模式 func test(i: Int?) &#123; if let i = i where i &gt; 0 &#123; // 符合条件的处理 return &#125; // 不符合条件的处理&#125; 上面的处理把条件放在了条件判断内部，使用guard与之相反，把正确的情况放在最外部，而异常情况放在条件判断内部 func test(i: Int?) &#123; guard let i = i where i &gt; 0 else &#123; // 在这里拦截，处理不符合条件的情况 return &#125; // 符合条件的处理，这个时候已经对i进行了拆包，i是非可选类型，可以直接使用 print(i)&#125; 保镖模式可以避免代码中过多的流程判断代码导致过多的代码块嵌套，增强可读性 保镖模式guard-else内的代码块必须包含break, return等跳出代码块的关键字 switch-case switch语句支持更多数据类型（String，Int, Float, 元组, 枚举），理论上switch支持任意类型的对象（需要实现~=方法或Equatable协议，详情参见这里） case可以带多个值，用逗号隔开 case可以支持区间（a...b），支持元组，区间可以嵌套在元组内使用 case多条语句不需要用大括号包起来 case语句不需要break，除了空语句，如果需要执行下面的case，可以使用fallthrough 如果case不能命中所有的情况，必须要default，如Int，String类型，否则编译会失败 可以用fallthrough关键字声明接着执行下一条case语句，注意，如果case语句有赋值语句（let），则fallthrough无效 // 定义一个枚举enum HttpStatus &#123; case ServerError case NetworkError case Success case Redirect&#125;var status = HttpStatus.Redirectswitch status &#123;// case可以接收多个值case HttpStatus.ServerError, HttpStatus.NetworkError: print(&quot;error&quot;) // case语句结束显式写break，除非是空语句case .Redirect: // 如果编译器可以识别出枚举类型，可以省略枚举名 print (&quot;redirect&quot;) fallthrough // 像C语言一样，继续执行下一条casecase HttpStatus.Success: print(&quot;success&quot;)&#125;//元组，区间let request = (0, &quot;https://baidu.com&quot;)switch request &#123;case (0, let a): // 支持绑定 print(a)case let (a, b) where a == 1: // 绑定可以卸载元组外面，支持where判断 print(&quot;cancel \\(b)&quot;)case (2...10, _): // 支持区间，支持忽略值 print(&quot;error&quot;)default: print(&quot;unknown&quot;)&#125;// case可以与where进行进一步判断let request2 = (0, 10)switch request2 &#123;case (0, let y) where y &lt; 5:&quot;success&quot; //被输出case (0, let y) where y &gt;= 5:&quot;error&quot; //被输出default: &quot;unknown&quot;&#125; case除了和swift一起使用外，还支持与if语句结合使用，用法与switch一样 let bb = (12, &quot;bomo&quot;)if case (1...20, let cc) = bb where cc == &quot;bomo&quot; &#123; print(cc)&#125; else &#123; print(&quot;nil&quot;)&#125; 带标签的语句如果有多层嵌套的情况下，有时候我们需要在某处直接退出多层循环，在objc下并没有比较好的方式实现，需要添加退出标识，然后一层一层退出，而在swift可以很方便的退出多层循环，首先需要使用标签标识不通的循环体，形式如下 labelName : while condition &#123; statements &#125; 看下面例子 outerLoop1 : for i in 1...10 &#123; outerLoop2 : for j in 1...10 &#123; outerLoop3 : for k in 1...10 &#123; if j &gt; 5 &#123; // 1. 跳出一层循环（默认）继续outerLoop2的循环 break // 2. 跳出两层循环，继续outerLoop1的循环 // break outerLoop2 // 3. 跳出三层循环，退出整个循环，继续后面的语句 // break outerLoop1 &#125; &#125; &#125;&#125; 八、函数1. 基本形式//有返回值func 函数名(参数名1:参数类型1, 参数名2:参数类型2) -&gt; 返回值类型 &#123; // 函数体&#125;//多个返回值（元组）func getPoint() -&gt; (x: Int, y: Int) &#123; return (1, 3)&#125;var p = getPoint()p.x//无参数无返回值func sayHello() &#123; // 函数体&#125;//eggfunc add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(12, b: 232) 函数调用除了第一个参数，后面所有的参数必须带上参数名（符合Objc的函数命名规则）如果是调用构造器，第一个参数也需要显示声明 class A &#123; var name: String init(name: String) &#123; self.name = name &#125; func sayHello(msg: String, count: Int) &#123; for _ in 1...count &#123; print (msg) &#125; &#125;&#125;let a = A(name: &quot;bomo&quot;) // 构造器所有参数都必须显示声明参数名a.sayHello(&quot;hello&quot;, count: 2) // 函数参数除了第一个其他都需要显示声明参数名 2. 可变参数可变参数只能作为最后一个参数，一个方法最多只有一个可变参数 func sum(numbers: Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125; 3. 外部参数名默认情况下，如果不指定外部参数名，swift编译器会自动为函数参数声明与内部参数名同名的外部参数名（格式为：外部参数名 内部参数名: 类型名） //默认情况下，外部参数名与内部参数名一样func add(first a: Int, second b: Int) -&gt; Int &#123; return a + b&#125;// 调用add(first: 10, second: 20) 如果函数在第一个参数定义外部参数名，必须显示指定，当然我们还可以通过下划线_让函数忽略参数名 func add(a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;add(1, 2) 4. 函数默认值函数还支持声明默认值，（格式为：外部参数名 内部参数名: 类型名 = 默认值） func log(msg: String, isDebug: Bool = true) &#123; if isDebug &#123; print(msg) &#125;&#125;log(&quot;fail&quot;)log(&quot;success&quot;, isDebug: false) 如果使用默认值并且默认值不是出现在最后，那调用的时候必须写全所有参数 建议把默认参数放到最后面，这样可以确保非默认参数的赋值顺序，减少参数混乱的情况 5. 闭包 函数作为变量 函数作为函数参数 函数作为函数返回值 闭包函数声明func add(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;//函数作为变量，函数hello赋给somefunc，并调用let somefunc: (Int, Int) -&gt; Int = addsomefunc(10, 20) // 30//函数作为参数func logAdd(a:Int, b:Int, function: (Int, Int) -&gt; Int) &#123; // 函数内容 print(&quot;begin&quot;) function(a, b) print(&quot;end&quot;)&#125;logAdd(12, b: 23, function: add)//函数作为返回值（包装一个函数，在执行前后输出信息），函数作为参数又作为返回值func addWrapper(addFunc: (Int, Int) -&gt; Int) -&gt; ((Int, Int) -&gt; Int) &#123; // 函数内容 func wrapper(a: Int, b: Int) -&gt; Int &#123; print(&quot;begin&quot;) let res = addFunc(a, b) print(&quot;end&quot;) return res &#125; return wrapper&#125;var newAdd = addWrapper(add)newAdd(12, 32) 闭包函数声明形式 &#123; (parameters) -&gt; returnType in statements // 可以有多行&#125; 闭包函数 //定义一个函数变量var addfunc: (Int, Int) -&gt; Int//闭包的写法// 1. 完整写法addfunc = &#123;(a: Int, b: Int) -&gt; (Int) in //var c = a + 1 //函数体可以有多条语句，如果在同一行，需要用分号隔开，函数体不需要大括号 return a + b&#125;// 2. 前面的addfunc变量可以推断出后面函数的参数类型和返回值类型，故可以省略addfunc = &#123;(a, b) in return a + b&#125;// 3. 参数列表括号可以省去，函数只有一条语句时，return可以省略addfunc = &#123;a, b in a + b&#125;// 4. 参数和in可以省去，通过$和索引取得参数addfunc = &#123;$0 + $1&#125;// 操作符需要的参数与函数参数一致，可以省去参数，并使用括号括起来，作为参数时，可不用括号addfunc = (+) 6. Trailing(尾行)闭包如果函数作为另一个函数的参数，并且是最后一个参数时，可以通过Trainling闭包来增强函数的可读性 func someFunctionThatTakesAClosure(a: Int, closure: () -&gt; ()) &#123; // 函数体部分&#125;// 1. 一般形式someFunctionThatTakesAClosure(10, closure: &#123; // 闭包主体部分&#125;)// 2. Trainling闭包的方式someFunctionThatTakesAClosure(10) &#123; // 闭包主体部分&#125;// 3. 如果没有其他参数时，可以省略括号someFunctionThatTakesAClosure &#123; // 闭包主体部分&#125; 7. Escaping（逃逸）闭包如果一个闭包/函数作为参数传给另外一个函数，但这个闭包在传入函数返回之后才会执行，就称该闭包在函数中”逃逸”，需要在函数参数添加@escaping声明，来声明该闭包/函数允许从函数中”逃逸”，如下 var completionHandlers: [() -&gt; Void] = []// 传入的闭包/函数并没有在函数内执行，需要在函数类型钱添加@escaping声明func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 逃逸闭包只是一个声明，以增强函数的意图 8. 自动闭包对于没有参数的闭包，swift提供了一种简写的方式，直接写函数体，不需要函数形式（返回值和参数列表），如下 // 声明一个自动闭包（无参数，可以有返回值，返回值类型swift可以自动识别）let sayHello = &#123; print(&quot;hello world&quot;) &#125;//调用闭包函数sayHello() 自动闭包只是闭包的一种简写方式 如果一个函数接受一个不带参数的闭包 func logIfTrue(predicate: () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125; 调用的时候可以使用自动闭包 logIfTrue(predicate: &#123; return 1 &lt; 2 &#125;)// 可以简化returnlogIfTrue(predicate: &#123; 1 &lt; 2 &#125;) 上面代码看起来可读性不是很好，swift引入了一个关键字@autoclosure，简化自动闭包的大括号，在闭包类型前面添加该关键字声明 func logIfTrue(predicate: @autoclosure () -&gt; Bool) &#123; if predicate() &#123; print(&quot;True&quot;) &#125;&#125;// 调用logIfTrue(predicate:1 &lt; 2) @autoclosure 关键字是为了简化闭包的写法，增强可读性，这里的例子比较简单，可以参考：@AUTOCLOSURE 和 ?? 9. 常量参数和变量参数默认情况下所有函数参数都是常量，意味着参数是不可变的，我们可以显式的声明参数为变量 func log(msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 会报错，因为msg为常量 print(msg)&#125;func log(var msg: String) &#123; msg = &quot;begin &quot; + msg + &quot; end&quot; // 变量参数正常运行 print(msg)&#125; 注：变量参数在swift3被抛弃 10. 输入输出参数在c语言里有指针，可以通过传址直接修改外部变量的值，在swift通过inout关键字声明函数内部可直接修改外部变量，外部通过&amp;操作符取得变量地址 func swap(inout a: Int, inout b: Int) &#123; let temp = a a = b b = temp&#125;var a = 19, b = 3swap(&amp;a, &amp;b) 11. 嵌套函数swift的函数还支持嵌套，默认情况下，嵌套函数对外部不可见，只能在函数内部使用 func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; //定义两个内部函数 func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125; 嵌套函数相当于objc函数内的block 12. defer在swift2.0之后添加了defer关键字，可以定义代码块在函数执行完成之前的完成一些操作，并且在函数抛出错误的时候也可以执行 func test() &#123; print(&quot;begin1&quot;) defer &#123; // 入栈 print(&quot;end1&quot;) &#125; print(&quot;begin2&quot;) defer &#123; // 入栈 print(&quot;end2&quot;) &#125; if true &#123; print(&quot;begin4&quot;) defer &#123; print(&quot;end4&quot;) &#125; print(&quot;begin5&quot;) defer &#123; print(&quot;end5&quot;) &#125; &#125; print(&quot;do balabala&quot;) return&#125; 上面输出结果为 begin1begin2begin4begin5end5end4do balabalaend2end1 通常可以用在需要成对操作的逻辑中（如：open/close） 九、枚举swift的枚举比C语言的枚举更为强大，支持更多特性，swift的枚举更像类和结构体，支持类和结构体的一些特性，与ObjC不同，如果不声明枚举的值，编译器不会给枚举设置默认值 枚举与结构体一样，是值类型 1. 声明和使用// 1. 定义枚举enum CompassPoint &#123; case North case South case East case West&#125;// 2. 可以把枚举值定义在一行，用逗号隔开enum CompassPoint2 &#123; case North, South, East, West&#125;// 3. 像对象一样使用枚举，代码结构更为清晰，枚举更为简短let direction = CompassPoint.East// 4. 如果编译器可以识别出枚举的类型，可以省略枚举名let direction2: CompassPointdirection2 = .East// 5. 如果编译器能确定case命中所有的情况，可以不需要defaultswitch direction &#123;case .East: print(&quot;east&quot;)case .West: print(&quot;west&quot;)case .South: print(&quot;south&quot;)case .North: print(&quot;north&quot;) //所有值都被枚举，则不需要default&#125; 2. 嵌套枚举swift的枚举定义支持嵌套，在使用的时候一层一层引用 enum Character &#123; enum Weapon &#123; case Bow case Sword case Lance case Dagger &#125; enum Helmet &#123; case Wooden case Iron case Diamond &#125; case Thief case Warrior case Knight&#125;let character = Character.Thieflet weapon = Character.Weapon.Bowlet helmet = Character.Helmet.Iron 3. 递归枚举枚举的关联值的类型可以设为枚举自身，这样的枚举称为递归枚举 enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 带递归类型的枚举需要在case前面添加关键字声明indirect，也可以在enum前面加上声明，表示所有的成员是可以递归的 indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 使用递归枚举取值的时候可以使用递归函数 func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125;let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)// (5 + 4) * 2let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))print(evaluate(product)) 其实感觉这种嵌套多层的用法可读性并不是特别好，而且在取值的时候还需要递归，通常来说，嵌套一层就够了 4. 原始值与C语言一样，可以为每个枚举指定值，并且可以支持更多类型（Int, Float, Character, String） // 定义枚举，并初始化原始值enum ASCIIControlCharacter: Character &#123; case Tab = &quot;\\t&quot; case LineFeed = &quot;\\n&quot; case CarriageReturn = &quot;\\r&quot;&#125;// 2. 通过两个属性获得原始值var ch = ASCIIControlCharacter.Tabch.hashValue // 获取是否有原始值ch.rawValue // 获得原始值// 3. 通过原始值构造枚举，如果不存在，则返回nilvar tab = ASCIIControlCharacter.init(rawValue: &quot;\\t&quot;)// 4. 如果是原始值是整形值，后面的值默认自增1，如果不指定，则默认为空，而不是从0开始enum Planet: Int &#123; case Mercury = 1, Venus // Venus = 2 case Neptune // Neptune = 3&#125;// 5. 如果没有指定枚举原始值的类型，则默认为空，而不是整型enum CompassPoint &#123; case North case South case East case West&#125;//swift 不会为North, South, East, West设置为0,1,2,3，并且CompassPoint没有原始值（rawValue）// 6. 有原始值的枚举可以通过原始值构造（构造器返回可选类型）let lineFeed = ASCIIControlCharacter(rawValue: &quot;\\n&quot;) 5. 关联值上面我们说到，枚举与类和结构体类似，swift的枚举可以给不同的枚举值绑定关联值，如下 enum Barcode &#123; case UPCA(Int, Int, Int) //条形码，关联一个元组 case QRCode(String) //二维码，关联一个字符串&#125;var productBarcode = Barcode.UPCA(8, 85909_51226, 3)// var productBarcode = .QRCode(&quot;http://www.baidu.com&quot;)switch productBarcode &#123;case .UPCA(let a, let b, let c): //在枚举的时候可以取得关联值 print(&quot;barcode: \\(a)\\(b)\\(c)&quot;)case let .QRCode(value): print(&quot;qrcode: \\(value)&quot;)&#125; 如上面这种轻量的数据，在OC上一般我们可能需要定义两个类实现，而swift的枚举可以轻松的处理这种轻量数据，而减少项目中类的定义和维护 十、类与结构体先来看看结构体和类的一些差异 类是引用类型，结构体为值类型 类使用引用计数管理内存，结构体分配在栈上，有系统管理内存，变量传递的时候，结构体整个拷贝，而类默认只传递引用地址（有些类会进行一些额外的拷贝，详见深拷贝和浅拷贝） 结构体不支持继承，类支持继承 与ObjC不同，swift的结构体可以定义方法 类支持运行时类型检查，而结构体不支持 类有构造器和析构器，结构体只有构造器 常量结构体的成员的值不能改变 实际上，在 Swift 中，所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。 1. 结构体，类定义struct Point &#123; let x: Int let y: Int func printPoint() &#123; print(&quot;x=\\(x), y=\\(y)&quot;) &#125;&#125;class Person &#123; var someObj = NSObject() // 定义属性，并初始化 var name: String // 定义属性，并指定类型 init(name: String) &#123; // 构造函数 self.name = name &#125; func hello() &#123; print(&quot;hello \\(self.name)&quot;) &#125; //析构函数 deinit &#123; print(&quot;dealloc&quot;) &#125;&#125; swift中，许多基本类型如String, Array和Dictionary都是用结构体实现的，意味着在传递的时候都会进行值拷贝，当然swift也对这些类型进行了优化，只有在需要的时候进行拷贝 2. 静态属性，静态方法swift中有两个static和class声明静态变量或方法，其中class只能用在类的方法和计算属性上，其他的都使用static，由于类支持继承，所以使用class声明的静态方法可以被继承，而static声明的静态方法不能被继承 class Person &#123; static var instanceCount: Int = 0 // 声明一个类属性 init () &#123; Person.instanceCount += 1 // 通过类名引用类属性，子类可以访问基类的类属性 &#125; // 使用class声明的静态方法可以被继承 class func overrideableComputedTypeProperty() &#123; print(&quot;\\(Person.instanceCount)&quot;) &#125; // 使用static声明的静态方法不能被继承 static func printInstanceCount() &#123; // 声明一个静态方法 print(&quot;\\(Person.instanceCount)&quot;) &#125;&#125; 类和结构体的声明和用法与类类似，使用static 注意：class只能用来声明计算属性和方法，不能用来声明普通属性 3. 构造器和析构器swift的构造器规则和限制比较多，关于构造器可以参见：这里 析构器相当于objc里面的dealloc方法，做一些需要手动释放资源的操作，析构器与构造器不同，没有参数，定义的时候不需要括号，类在释放的之前会自动调用父类的析构器，不需要主动调用 class Person &#123; deinit &#123; print(&quot;释放额外的资源，如通知&quot;) &#125;&#125; 4. 类型判断在objc中，我们通常使用isKindOfClass, isMemberOfClass, isSubclassOfClass等方法进行类型判断，swift使用is和as判断类型 class Parent &#123;&#125;class Son: Parent &#123;&#125;var s = Son()// isKindOfClassson is Son // trueson is Parent // true// isMemberOfClassson.dynamicType == Son.self // trueson.dynamicType == Parent.self // false// isSubclassOfClass 暂时没找到相关的API //TODO: swift动态性，反射 5. 弱引用与ObjC一样，swift的内存管理也使用引用计数管理，也使用weak声明弱引用变量 class Person &#123; weak var person: Person? = nil&#125; 6. 访问级别在swift中，framework和bundle都被处理成模块 * public：公开，可以被外部访问 * internal：内部，在模块（framework）内部使用，模块外访问不到 * private：只能在当前源文件中使用swift默认的访问级别为Internal，使用的时候只需要在类/变量/函数前面加上访问级别即可 public class Person &#123; class public var peopleCount: Int = 0 // 类变量，通过class声明，类变量使用时使用类名引用 internal var age: Int // 实例变量 var name: String // 不声明，则为internal init() &#123; self.age = 0 self.name = &quot;&quot; Person.peopleCount++ // 使用静态变量 &#125; private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 外层访问级别的必须是比成员更高，下面会报警告 class Person &#123; // 默认为internal public var age: Int = 0 // 为public，比类访问级别高，会有警告 private var gender: Int = 10 private func sayHello() &#123; print(&quot;hello&quot;) &#125;&#125; 函数的访问级别要比参数(或泛型类型)的访问级别低，否则会报警告 private class PrivatePerson &#123; private var age: Int = 0 var gender: Int = 10 // 报警告 private func sayHello() &#123; &#125;&#125;public class Test &#123; public func test(person:PrivatePerson) &#123; //报编译错误：这里参数访问级别为private，所以函数访问级别不能高于private，则只能为private &#125;&#125; 枚举类型的成员访问级别跟随枚举类型，嵌套类型默认最高访问级别为internal（外层为public，内层默认为internal） public enum CompassPoint &#123; case North // 四个枚举成员访问级别都为public case South case East case West&#125; 子类访问级别不能高于父类（包括泛型类型），协议继承也同理，子协议访问级别不能高于父协议 class Parent &#123;&#125;public class Son: Parent &#123; // 报编译错误：Son访问级别必须低于Parent，应该为internal或private&#125; 元组的访问级别为元组内所有类型访问级别中最低级的 class Parent &#123;&#125;private class Son: Parent &#123;&#125;public class SomeClass &#123; internal let sometuple = (Son(), Parent()) // 报编译错误：sometuple的访问级别不能高于成员类型的访问级别，由于Son为private，故sometuple必须为private&#125; 变量的访问级别不能高于类型 private class PrivateClass &#123;&#125;public class SomeClass &#123; public var value: PrivateClass // 报编译错误：变量value的访问级别不能高于其类型，故value必须声明为private&#125; 属性的 Setter 访问级别不能高于 Getter访问级别 public class SomeClass &#123; private(set) var num = 1_000_000 // 声明属性num，getter访问级别没有声明，默认为Internal，setter访问级别为private private internal(set) var name = &quot;bomo&quot; // 报编译错误：属性name的setter访问级别为internal，高于getter访问级别private&#125; 协议与类的访问级别关系 协议中所有必须实现的成员的访问级别和协议本身的访问级别相同 其子协议的访问级别不高于父协议（与类相同） 如果类实现了协议，那类的访问级别必须低于或等于协议的访问级别 类型别名访问级别与类型的关系 类型别名的访问级别不能高于原类型的访问级别； 函数构造函数默认访问级别为internal，如果需要给其他模块使用，需显式声明为public 注意：swift的访问级别是作用于文件（private）和模块的（internal）的，而不只是类，所以只要在同一个文件内，private访问级别在不同类也可以直接访问，例如我们可以通过子类包装父类的方法以改变访问级别 public class A &#123; private func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; // 在同一个文件，改变someMethod的访问级别 super.someMethod() &#125;&#125; 7. 属性 使用关键字lazy声明一个懒加载 变量 属性，当属性被使用的时候（get），才会进行初始化 set方法的访问级别必须必get方法低 声明属性的时候可以使用private(set)和internal(set)改变set方法默认的访问级别 每个实例都有一个self属性，指向实例自身，通常在属性与函数参数有冲突的时候使用 对于常量属性，不许在定义它的类的构造器中赋值，不能再子类赋值 class DataImporter &#123;&#125;class DataManager &#123; // 1. 只有第一次调用importer的get方法的时候才会初始化 lazy var importer = DataImporter() var data = [String]()&#125;class Rectangle &#123; var width: Double = 0.0 var height: Double = 0.0 // 2. 声明get方法和set方法的访问级别 private private(set) var weight: Double = 0 // 3. 自定义get/set方法 var square: Double &#123; get &#123; return (self.width + self.height)/2; &#125; //set &#123; //如果不指定名称，默认通过newValue使用新值 set(newValue) &#123; self.width = newValue/2.0; self.height = newValue/2.0 &#125; &#125; // 4. 只读属性，可以省略get，直接使用一个花括号 var perimeter: Double &#123; return (self.width + self.height) * 2 &#125; // 5. 属性监视器，在初始化的时候不会触发 var someInt: Int = 0 &#123; willSet &#123; //用法与set一样如果不指定名称，默认通过newValue使用旧值 print(&quot;set方法之前触发&quot;) &#125; didSet &#123; //用法与set一样如果不指定名称，默认通过oldValue使用旧值 print(&quot;set方法完成后触发，可以在这里设置obj的值覆盖set方法设置的值&quot;) self.someInt = 0 // someInt的值永远为0，在监视器修改属性的值不会导致观察器被再次调用 &#125; &#125;&#125; 使用lazy声明的属性不是线程安全的，在多线程情况下可能产生多份，需要自己控制 对于结构体，与OC不同，swift的结构体允许直接对属性的子属性直接修改，而不需要取出重新赋值 someVideoMode.resolution.width = 1280 在oc上需要这样做 var resolution = someVideoMode.resolutionresolution.width = 1024someVideoMode.resolution = resolution 8. 继承我们都知道，在oc里所有的类都继承自NSObject/NSProxy，而在swift中的类并不是从一个通用的基类继承的，所有没有继承其他父类的类都称为基类 class Parent &#123; final var gender = &quot;unknown&quot; init(gender: String) &#123; self.gender = gender &#125; private func hello() &#123; print(&quot;parent hello&quot;) &#125;&#125;class Son: Parent &#123; // 重写可以改变父类方法的访问级别 internal override func hello() &#123; // 重写父类方法必须加上override，否则会报编译错误 //super.hello() // 可以通过super访问父类成员，包括附属脚本 print(&quot;son hello&quot;) &#125;&#125; 重写属性的时候，如果属性提供了setter方法，则必须为提供getter方法如果重写了属性的setter方法，则不能重写willSet和didSet方法如果重写了willSet和didSet方法，则不能重写get和set方法 父类的属性，方法，类方法，附属脚本，包括类本身都可以被子类继承和重写，可以通过final约束限制子类的重写（final class, final var, final func, final class func, 以及 final subscript） class Parent &#123; final var gender = &quot;unknown&quot; // 不允许被子类重写 var name: String // 可以被子类重写 init(gender: String) &#123; self.gender = gender self.name = &quot;&quot; &#125; final func hello() &#123; // 不允许被重写 print(&quot;parent hello&quot;) &#125;&#125; swift编译器在识别数组类型的时候，如果数组元素有相同的基类，会被自动识别出来 class Person &#123;&#125;class Teacher: Person &#123;&#125;class Student: Person &#123;&#125;let t1 = Teacher()let t2 = Teacher()let s1 = Student()let s2 = Student()let people = [t1, t2, s1, s2] // people会被识别为[Person]类型 向下类型转换as!, as?，as!返回非可选类型，如果类型不匹配会报错，as?返回可选类型，如果类型不匹配返回nil for person in people &#123; if let teacher = person as? Teacher &#123; println(&quot;teacher&quot;) &#125; else if let student = person as? Student &#123; println(&quot;student&quot;) &#125;&#125; 9. 附属脚本subscript附属脚本可以让类、结构体、枚举对象快捷访问集合或序列，而不需要调用使用对象内的实例变量引用，看下面实例 class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:]&#125;// 如果需要使用DailyMeal的meals对象的，需要这么用var dailyMeal = DailyMeal()dailyMeal.meals[MealTime.Breakfast] = &quot;Toast&quot; 使用附属脚本可以直接通过类对象索引访问meals的值 class DailyMeal &#123; enum MealTime &#123; case Breakfast case Lunch case Dinner &#125; var meals: [MealTime : String] = [:] // 定义附加脚本，类似属性 subscript(realMealTime: MealTime) -&gt; String &#123; get &#123; if let value = meals[realMealTime] &#123; return value &#125; else &#123; return &quot;unknown&quot; &#125; &#125; set(newValue) &#123; meals[realMealTime] = newValue &#125; &#125;&#125;var dailyMeal = DailyMeal()dailyMeal[.Breakfast] = &quot;sala&quot;print(dailyMeal[.Breakfast]) 附加脚本还支持多个参数 struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(count: rows * columns, repeatedValue: 0.0) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row, column: column), &quot;Index out of range&quot;) grid[(row * columns) + column] = newValue &#125; &#125;&#125;var matrix = Matrix(rows: 2, columns: 2)matrix[0, 1] = 1.5matrix[1, 0] = 3.2 附加脚本类似属性，拥有get/set方法，支持只读和读写两种方式，附加脚本也支持多个参数，附属脚本可以屏蔽外部对内部对象的直接访问，隐藏对象内部的细节，提高封装度，使得代码更加健壮和简洁 10. 类型嵌套与枚举一样，结构体和类都支持类型嵌套，可以在类里面再定义类/结构体/枚举 class SomeClass &#123; // 类里面嵌套定义枚举 enum Suit: Character &#123; case Spades = &quot;♠&quot;, Hearts = &quot;♡&quot;, Diamonds = &quot;♢&quot;, Clubs = &quot;♣&quot; // 枚举里面嵌套定义结构体 struct Values &#123; let first: Int, second: Int &#125; &#125; // 类里面嵌套定义结构体 struct Point &#123; let x: Int let y: Int &#125; // 类里面嵌套定义类 class InnerClass &#123; var name: String = &quot;&quot; var id: Int = 0 &#125;&#125;// 使用的时候像属性一样引用let values = SomeClass.Suit.Values(first: 1, second: 2) 11. 类型别名swift类型别名与c语言中取别名有点像，通过关键字typealias声明别名 public typealias MyInt = Intfunc add(a: MyInt, b: MyInt) -&gt; MyInt &#123; return a + b&#125; 通常在容易出现命名冲突的情况下会考虑使用类型别名 十一、扩展Extension与oc一样，扩展就是对已有的类添加新的功能，与oc的category类似，swift的扩展可以： 提供新的构造器（需要符合构造器的基本规则） 添加实例计算型属性和类计算性属性 添加实例方法和类方法 添加附加脚本 添加新的嵌套类型 使一个已有类型符合某个接口 swift扩展不可以： 不可以添加存储属性 不可以向已有属性添加属性观测器(willSet, didSet) class Person &#123; func hello() &#123; print(&quot;hello&quot;) &#125;&#125;// 定义扩展extension Person &#123; func fly() &#123; print(&quot;fly&quot;) &#125;&#125;let p = Person()p.fly() 扩展也可以作用在结构体和枚举上 struct Rectangle &#123; let width: Double let height: Double&#125;extension Rectangle &#123; var perimeter: Double &#123; return 2 * (self.width + self.height) &#125;&#125;let rect = Rectangle(width: 100, height: 200)print(rect.perimeter) 扩展内的成员定义与类类似，这里不再说明 扩展属性由于swift不能扩展新的属性，有时候我们希望给类添加属性，在oc里可以用关联属性新增存储属性，在swift也可以，需要引入ObjectiveC模块 import ObjectiveCclass Point &#123; var x: Int = 0 var y: Int = 1&#125;private var xoTag: UInt = 0extension Point &#123; var z: Int &#123; get &#123; return objc_getAssociatedObject(self, &amp;xoTag) as! Int &#125; set(newValue) &#123; objc_setAssociatedObject(self, &amp;xoTag, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125; 十二、协议Protocalswift的协议在oc的基础上加了更多的支持，可以支持属性，方法，附加脚本，操作符等，协议的属性必须为变量var protocol SomeProtocol &#123; // 属性要求 var mustBeSettable: Int &#123; get set &#125; // 只读属性 var doesNotNeedToBeSettable: Int &#123; get &#125; // 只读静态属性 static var staticProperty: Int &#123; get &#125; // 静态方法 static func hello()&#125; 1. mutating在结构体/枚举中的值类型变量，默认情况下不能对其进行修改，编译不通过，如果需要修改值类型的属性，需要在方法声明前加上mutating struct Point &#123; var x: Int var y: Int func moveToPoint(point: Point) &#123; self.x = point.x // 报错：不能对值类型的属性进行修改 self.y = point.y // 报错：不能对值类型的属性进行修改 &#125; mutating func moveToPoint2(point: Point) &#123; self.x = point.x // 编译通过 self.y = point.y // 编译通过 &#125; //可变方法还可以对self进行修改，这个方法和moveToPoint2效果相同 mutating func moveToPoint3(x deltaX: Int, y deltaY: Int) &#123; self = Point(x:deltaX, y:deltaY) &#125;&#125; 可变方法还可以修改枚举值自身的值 enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125; 特别是在定义Protocal的时候，需要考虑到协议可能作用于枚举或结构体，在定义协议的时候需要在方法前加上mutating protocol SomeProtocol &#123; mutating func moveToPoint(point: Point)&#125; 2. 协议类型协议虽然没有任何实现，但可以当做类型来用，与oc的protocal类似，用协议类型表示实现了该协议的对象，与oc的id&lt;SomeProtocol&gt;一样 3. 协议组合有时候我们需要表示一个对象实现多个协议，可以使用协议组合来表示，如下 protocol SwimProtocal &#123; func fly()&#125;protocol WalkProtocal &#123; func walk()&#125;func through(animal: protocol&lt;WalkProtocal, SwimProtocal&gt;) &#123; animal.walk() animal.fly()&#125; 4. 自身类型有时候我们需要表示实现协议的类型，可以使用Self代替，如下 protocol CompareProtocal &#123; // Self表示实现协议自己的类型本身 func compare(other: Self) -&gt; Bool&#125;class Product: CompareProtocal &#123; var id: Int = 0 func compare(other: Product) -&gt; Bool &#123; return self.id == other.id &#125;&#125; 5. @objc协议swift声明的协议是不能直接被oc的代码桥接调用的，如果需要，需要在声明前加上@objc，使用@objc声明的协议不能被用于结构体和枚举 import Foundation@objc protocol HasArea &#123; // 协议可以被桥接到oc中使用 var area: Double &#123; get &#125;&#125; 6. Optional要求在oc中的protocal可以定义可选方法，在swift默认不支持可选方法，swift只有在添加了@objc声明的协议才能定义可选方法，在定义前添加optional声明 import Foundation@objc protocol HasArea &#123; optional var area: Double &#123; get &#125; // 定义可选属性&#125; 十三、错误与其他高级语言异常处理有点类似，swift引入了错误的机制，可以在出现异常的地方抛出错误，错误对象继承自Error，抛出的错误函数会立即返回，并将错误丢给调用函数的函数处理，如果一个函数可能抛出错误，那么必须在函数定义的时候进行声明，如下 //定义错误类型enum OperationError: Error &#123; case DivideByZero case Other&#125;//定义可能抛出异常的函数，在函数声明的返回值前面加上throwsfunc divide(a: Int, b: Int) throws -&gt; Float &#123; if b == 0 &#123; throw OperationError.DivideByZero &#125; return Float(a) / Float(b)&#125;//调用可能出错的函数（调用出必须加上try）do &#123; let result = try divide(a: 10, b: 0) print(result)&#125; catch OperationError.DivideByZero &#123; print(error)&#125; catch &#123; //其他错误&#125; 如果错误是一个对象，而不是枚举，可以用let绑定到变量上 do &#123; try divide(a: 10, b: 0)&#125; catch let err as SomeErrorType &#123; print(err.message)&#125; catch &#123; print(&quot;other error&quot;)&#125; 如果不处理错误的话可以使用try?，使用try?关键字的方法会被包装到一个可选类型中，如果发生错误，则会返回nil，如下面序列化的例子 func serialize(obj: AnyObject) -&gt; String &#123; guard let jsonString = try? someSerializeFuncMayThrowError(obj) else &#123; print(jsonString) &#125; print(&quot;fail&quot;)&#125; try?配合guard let一起使用效果更好 十四、断言断言可以让我们在调试时候更好的发现问题，排查错误，几乎所有的高级语言都支持断言，swift也如此，断言的代码在release的时候回被忽略，不会影响发布程序的性能，只会在调试的时候生效 // 如果age小于0，程序会停止，并输出错误信息assert(age &gt;= 0, &quot;A person&#x27;s age cannot be less than zero&quot;) 十五、泛型关于泛型的介绍，这里不进行说明，swift的泛型是我认为最酷的特性之一，当然其他语言也有，可以让类或函数更大程度的重用，swift的泛型与其他语言的泛型有点类似 1. 定义在类或函数声明的时候，指定一个泛型类型参数（通常为T）然后使用的时候直接把T当成类型使用 //泛型函数定义func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) &#123; let temporaryA = a a = b b = temporaryA&#125;//泛型类定义class Result&lt;T&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T?&#125;//多个泛型类型参数class Result&lt;T, TK&gt; &#123; var code: Int = 0 var errorMessage: String? var data: T? var subData: TK?&#125; 2. 泛型约束我们还可以对泛型进行约束，泛型类型参数只能是某些类型的子类，或实现了某些协议 func findIndex&lt;T&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 上面函数会报编译错误，因为在swift里，并不是所有的类都能用==操作符比较，只有实现了Equatable协议的类才能用==操作符，修改为 func findIndex&lt;T: Equatable&gt;(array: [T], valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerate() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 3. 多泛型类型参数有时候我们需要用多个协议进行约束，可以使用下面方式（类与函数的使用方式类似） func someFunc&lt;T : protocol&lt;StudyProtocal, RunProtocal&gt;&gt;(arg: T) &#123; // do stuff&#125; 如果约束既有类又有协议的话可以使用where添加限制条件 func someFunc&lt;T, TK where T:Student, T: StudyProtocal&gt;(t: T, tk: TK) &#123; // do stuff&#125; 4. 泛型是不可变的var dog1 = SomeClass&lt;Parent&gt;()var dog2 = SomeClass&lt;Son&gt;()dog1 = dog2 // 报错 关于可变，不可变，逆变，协变参考这里：http://swift.gg/2015/12/24/friday-qa-2015-11-20-covariance-and-contravariance/ 5. 泛型协议swift的协议不支持泛型，不能像类一样定义泛型，而是通过类型参数定义泛型 protocol GenericProtocol &#123; associatedtype T1 associatedtype T2 func someFunc(t2: T2) -&gt; T1&#125;class SomeClass&lt;T&gt; : GenericProtocol &#123; // 设置泛型类型 typealias T1 = String typealias T2 = T func someFunc(t2: T2) -&gt; T1 &#123; return &quot;&quot; &#125;&#125; 十六、运算符重载与其他高级语言的一样，swift也提供了运算符重载的功能，我们可以自定义运算符的实现，运算符通常分为三种类型 单目运算符：&lt;运算符&gt;&lt;操作数&gt;或&lt;操作数&gt;&lt;运算符&gt;，如!a 双目运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：1 + 1 三元运算符：&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;&lt;运算符&gt;&lt;操作数&gt;，如：a ? b : c swift的运算符重载 支持自定义运算符/, =, -, +, *, %, &lt;, &gt;, !, &amp;, |, ^, ., ~的任意组合。可以脑洞大开创造颜文字。 不能对默认的赋值运算符=进行重载。组合赋值运算符可以被重载，如==，!==! 无法对三元运算符a ? b : c进行重载 运算符声明和定义只能定义在全局作用域，不能定义在类/结构体/枚举内 1. 前缀，中缀，后缀运算符 前缀prefix：默认的有-，!，~等 中缀infix：默认的有+，*，==等 后缀postfix：默认的有：++，–等 1.1 声明运算符如果实现不存在的运算符需要添加运算符声明（系统的提供的，可以不需要声明），声明必须放在全局作用域 // 前缀运算符prefix operator +++ &#123;&#125;// 中缀运算符（二元运算符）infix operator +++ &#123;&#125;// 后缀运算符postfix operator +++ &#123;&#125; 1.2 实现上面三个运算符// 定义Point结构体struct Point &#123; var x: Int var y: Int&#125;// 重载操作符要放在全局作用域func +++ (left: Point, right: Point) -&gt; Point &#123; return Point(x: left.x + right.x, y: left.y + right.y)&#125;// 如果需要修改操作数，需要添加inout关键字prefix func +++ (inout left: Point) &#123; left.x += 1 left.y += 1&#125;postfix func --- (right: Point) -&gt; Point &#123; return Point(x: right.x - 1, y: right.y - 1)&#125; 1.3 使用var p1 = Point(x: 12, y: 21)var p2 = Point(x: 12, y: 2)let p3 = p1+++p2 // p3.x = 24, p3.y = 23+++p1 // p1.x = 13, p1.y = 3p1--- // p1.x = 12, p1.y = 2 2. 优先级这个很好理解，就是优先级高的运算符先执行，声明运算符的时候可以指明优先级 infix operator ^ &#123; associativity left // 结合性，后面说 precedence 140 // 指定运算符优先级&#125; 这里可以查看默认运算符的优先级 3. 结合性运算符还可以定义结合性，对于双目运算符，当优先级一样的时候，可以定义运算符优先进行左结合还是右结合，运算符的结合性有下面三种 left：左结合 right：右结合 none：无 结合性设置为left // 定义一个双目操作符infix operator ^ &#123; associativity left // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为256// 相当于let aa = ((2 ^ 2) ^ 2) ^ 2 如果我们设置结合性为right // 定义一个双目操作符infix operator ^ &#123; associativity right // 结合性 precedence 140 // 指定运算符优先级&#125;func ^ (left: Int, right: Int) -&gt; Int &#123; return Int(pow(Double(left), Double(right)))&#125;let a = 2 ^ 2 ^ 2 ^ 2 // 执行结果为65536// 相当于let aa = 2 ^ (2 ^ (2 ^ 2)) 如果结合性设置为none，则会报错，无法判断 十七、命名空间在很多语言里面，都有命名空间的概念，可以分离代码，防止命名冲突，而swift也有类似命名空间的概念，通过访问级别实现命名空间//TODO 十八、参考链接 运算符结合性 Swift高级运算符 十九、总结总的来说，swift还是比较装逼的，整个很多新名词，新概念，例如，指定构造器，便利构造器，构造器代理，但其实这些东西在别的语言基本上有，没那么复杂，另外swift的关键字太多了，有些可有可无，是不是苹果看到什么好的就想往swift里面塞还是怎么着，另外感觉苹果还是太装逼了，例如do-while非要偏偏要搞成repeat-while啥的，个人感觉编程语言应该是轻便，简单，当然，并且能满足所有需求的，反正，没什么特别的好感","categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"}],"tags":[{"name":"swift","slug":"swift","permalink":"http://fangliquan.github.io/tags/swift/"}]}],"categories":[{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/categories/iOS/"},{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/categories/swift3-0/"},{"name":"iOS Project Practice","slug":"iOS-Project-Practice","permalink":"http://fangliquan.github.io/categories/iOS-Project-Practice/"},{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/categories/xcode/"},{"name":"blog","slug":"blog","permalink":"http://fangliquan.github.io/categories/blog/"}],"tags":[{"name":"iOS面试","slug":"iOS面试","permalink":"http://fangliquan.github.io/tags/iOS%E9%9D%A2%E8%AF%95/"},{"name":"swift3.0","slug":"swift3-0","permalink":"http://fangliquan.github.io/tags/swift3-0/"},{"name":"iOS","slug":"iOS","permalink":"http://fangliquan.github.io/tags/iOS/"},{"name":"AVAudioSession","slug":"AVAudioSession","permalink":"http://fangliquan.github.io/tags/AVAudioSession/"},{"name":"AudioSessionProperty","slug":"AudioSessionProperty","permalink":"http://fangliquan.github.io/tags/AudioSessionProperty/"},{"name":"支付宝SDK","slug":"支付宝SDK","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9DSDK/"},{"name":"支付宝","slug":"支付宝","permalink":"http://fangliquan.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"},{"name":"多线程","slug":"多线程","permalink":"http://fangliquan.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"xcode","slug":"xcode","permalink":"http://fangliquan.github.io/tags/xcode/"},{"name":"iOS多线程","slug":"iOS多线程","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"NSThread","slug":"NSThread","permalink":"http://fangliquan.github.io/tags/NSThread/"},{"name":"GCD","slug":"GCD","permalink":"http://fangliquan.github.io/tags/GCD/"},{"name":"iOS视频播放器","slug":"iOS视频播放器","permalink":"http://fangliquan.github.io/tags/iOS%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8/"},{"name":"blogs","slug":"blogs","permalink":"http://fangliquan.github.io/tags/blogs/"},{"name":"hexo","slug":"hexo","permalink":"http://fangliquan.github.io/tags/hexo/"},{"name":"iOS多图文","slug":"iOS多图文","permalink":"http://fangliquan.github.io/tags/iOS%E5%A4%9A%E5%9B%BE%E6%96%87/"},{"name":"图文混排","slug":"图文混排","permalink":"http://fangliquan.github.io/tags/%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92/"},{"name":"Frame模型","slug":"Frame模型","permalink":"http://fangliquan.github.io/tags/Frame%E6%A8%A1%E5%9E%8B/"},{"name":"runtime","slug":"runtime","permalink":"http://fangliquan.github.io/tags/runtime/"},{"name":"iOS9新特性","slug":"iOS9新特性","permalink":"http://fangliquan.github.io/tags/iOS9%E6%96%B0%E7%89%B9%E6%80%A7/"},{"name":"swift","slug":"swift","permalink":"http://fangliquan.github.io/tags/swift/"}]}